/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type { FunctionFragment, Result } from '@ethersproject/abi';
import type { Listener, Provider } from '@ethersproject/providers';
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from 'ethers';

import type {
  OnEvent,
  TypedEvent,
  TypedEventFilter,
  TypedListener,
} from '../common.js';

export type CheckpointStruct = {
  origin: BigNumberish;
  merkleTree: BytesLike;
  root: BytesLike;
  index: BigNumberish;
  messageId: BytesLike;
};

export type CheckpointStructOutput = [
  number,
  string,
  string,
  number,
  string,
] & {
  origin: number;
  merkleTree: string;
  root: string;
  index: number;
  messageId: string;
};

export interface CheckpointFraudProofsInterface extends utils.Interface {
  functions: {
    'PACKAGE_VERSION()': FunctionFragment;
    'isFraudulentMessageId((uint32,bytes32,bytes32,uint32,bytes32),bytes32[32],bytes32)': FunctionFragment;
    'isFraudulentRoot((uint32,bytes32,bytes32,uint32,bytes32),bytes32[32])': FunctionFragment;
    'isLocal((uint32,bytes32,bytes32,uint32,bytes32))': FunctionFragment;
    'isPremature((uint32,bytes32,bytes32,uint32,bytes32))': FunctionFragment;
    'storeLatestCheckpoint(address)': FunctionFragment;
    'storedCheckpointContainsMessage(address,uint32,bytes32,bytes32[32])': FunctionFragment;
    'storedCheckpoints(address,bytes32)': FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | 'PACKAGE_VERSION'
      | 'PACKAGE_VERSION()'
      | 'isFraudulentMessageId'
      | 'isFraudulentMessageId((uint32,bytes32,bytes32,uint32,bytes32),bytes32[32],bytes32)'
      | 'isFraudulentRoot'
      | 'isFraudulentRoot((uint32,bytes32,bytes32,uint32,bytes32),bytes32[32])'
      | 'isLocal'
      | 'isLocal((uint32,bytes32,bytes32,uint32,bytes32))'
      | 'isPremature'
      | 'isPremature((uint32,bytes32,bytes32,uint32,bytes32))'
      | 'storeLatestCheckpoint'
      | 'storeLatestCheckpoint(address)'
      | 'storedCheckpointContainsMessage'
      | 'storedCheckpointContainsMessage(address,uint32,bytes32,bytes32[32])'
      | 'storedCheckpoints'
      | 'storedCheckpoints(address,bytes32)',
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: 'PACKAGE_VERSION',
    values?: undefined,
  ): string;
  encodeFunctionData(
    functionFragment: 'PACKAGE_VERSION()',
    values?: undefined,
  ): string;
  encodeFunctionData(
    functionFragment: 'isFraudulentMessageId',
    values: [CheckpointStruct, BytesLike[], BytesLike],
  ): string;
  encodeFunctionData(
    functionFragment: 'isFraudulentMessageId((uint32,bytes32,bytes32,uint32,bytes32),bytes32[32],bytes32)',
    values: [CheckpointStruct, BytesLike[], BytesLike],
  ): string;
  encodeFunctionData(
    functionFragment: 'isFraudulentRoot',
    values: [CheckpointStruct, BytesLike[]],
  ): string;
  encodeFunctionData(
    functionFragment: 'isFraudulentRoot((uint32,bytes32,bytes32,uint32,bytes32),bytes32[32])',
    values: [CheckpointStruct, BytesLike[]],
  ): string;
  encodeFunctionData(
    functionFragment: 'isLocal',
    values: [CheckpointStruct],
  ): string;
  encodeFunctionData(
    functionFragment: 'isLocal((uint32,bytes32,bytes32,uint32,bytes32))',
    values: [CheckpointStruct],
  ): string;
  encodeFunctionData(
    functionFragment: 'isPremature',
    values: [CheckpointStruct],
  ): string;
  encodeFunctionData(
    functionFragment: 'isPremature((uint32,bytes32,bytes32,uint32,bytes32))',
    values: [CheckpointStruct],
  ): string;
  encodeFunctionData(
    functionFragment: 'storeLatestCheckpoint',
    values: [string],
  ): string;
  encodeFunctionData(
    functionFragment: 'storeLatestCheckpoint(address)',
    values: [string],
  ): string;
  encodeFunctionData(
    functionFragment: 'storedCheckpointContainsMessage',
    values: [string, BigNumberish, BytesLike, BytesLike[]],
  ): string;
  encodeFunctionData(
    functionFragment: 'storedCheckpointContainsMessage(address,uint32,bytes32,bytes32[32])',
    values: [string, BigNumberish, BytesLike, BytesLike[]],
  ): string;
  encodeFunctionData(
    functionFragment: 'storedCheckpoints',
    values: [string, BytesLike],
  ): string;
  encodeFunctionData(
    functionFragment: 'storedCheckpoints(address,bytes32)',
    values: [string, BytesLike],
  ): string;

  decodeFunctionResult(
    functionFragment: 'PACKAGE_VERSION',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'PACKAGE_VERSION()',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'isFraudulentMessageId',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'isFraudulentMessageId((uint32,bytes32,bytes32,uint32,bytes32),bytes32[32],bytes32)',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'isFraudulentRoot',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'isFraudulentRoot((uint32,bytes32,bytes32,uint32,bytes32),bytes32[32])',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(functionFragment: 'isLocal', data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: 'isLocal((uint32,bytes32,bytes32,uint32,bytes32))',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'isPremature',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'isPremature((uint32,bytes32,bytes32,uint32,bytes32))',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'storeLatestCheckpoint',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'storeLatestCheckpoint(address)',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'storedCheckpointContainsMessage',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'storedCheckpointContainsMessage(address,uint32,bytes32,bytes32[32])',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'storedCheckpoints',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'storedCheckpoints(address,bytes32)',
    data: BytesLike,
  ): Result;

  events: {};
}

export interface CheckpointFraudProofs extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: CheckpointFraudProofsInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined,
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>,
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>,
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    PACKAGE_VERSION(overrides?: CallOverrides): Promise<[string]>;

    'PACKAGE_VERSION()'(overrides?: CallOverrides): Promise<[string]>;

    isFraudulentMessageId(
      checkpoint: CheckpointStruct,
      proof: BytesLike[],
      actualMessageId: BytesLike,
      overrides?: CallOverrides,
    ): Promise<[boolean]>;

    'isFraudulentMessageId((uint32,bytes32,bytes32,uint32,bytes32),bytes32[32],bytes32)'(
      checkpoint: CheckpointStruct,
      proof: BytesLike[],
      actualMessageId: BytesLike,
      overrides?: CallOverrides,
    ): Promise<[boolean]>;

    isFraudulentRoot(
      checkpoint: CheckpointStruct,
      proof: BytesLike[],
      overrides?: CallOverrides,
    ): Promise<[boolean]>;

    'isFraudulentRoot((uint32,bytes32,bytes32,uint32,bytes32),bytes32[32])'(
      checkpoint: CheckpointStruct,
      proof: BytesLike[],
      overrides?: CallOverrides,
    ): Promise<[boolean]>;

    isLocal(
      checkpoint: CheckpointStruct,
      overrides?: CallOverrides,
    ): Promise<[boolean]>;

    'isLocal((uint32,bytes32,bytes32,uint32,bytes32))'(
      checkpoint: CheckpointStruct,
      overrides?: CallOverrides,
    ): Promise<[boolean]>;

    isPremature(
      checkpoint: CheckpointStruct,
      overrides?: CallOverrides,
    ): Promise<[boolean]>;

    'isPremature((uint32,bytes32,bytes32,uint32,bytes32))'(
      checkpoint: CheckpointStruct,
      overrides?: CallOverrides,
    ): Promise<[boolean]>;

    storeLatestCheckpoint(
      merkleTree: string,
      overrides?: Overrides & { from?: string },
    ): Promise<ContractTransaction>;

    'storeLatestCheckpoint(address)'(
      merkleTree: string,
      overrides?: Overrides & { from?: string },
    ): Promise<ContractTransaction>;

    storedCheckpointContainsMessage(
      merkleTree: string,
      index: BigNumberish,
      messageId: BytesLike,
      proof: BytesLike[],
      overrides?: CallOverrides,
    ): Promise<[boolean]>;

    'storedCheckpointContainsMessage(address,uint32,bytes32,bytes32[32])'(
      merkleTree: string,
      index: BigNumberish,
      messageId: BytesLike,
      proof: BytesLike[],
      overrides?: CallOverrides,
    ): Promise<[boolean]>;

    storedCheckpoints(
      merkleTree: string,
      root: BytesLike,
      overrides?: CallOverrides,
    ): Promise<[number, boolean] & { index: number; exists: boolean }>;

    'storedCheckpoints(address,bytes32)'(
      merkleTree: string,
      root: BytesLike,
      overrides?: CallOverrides,
    ): Promise<[number, boolean] & { index: number; exists: boolean }>;
  };

  PACKAGE_VERSION(overrides?: CallOverrides): Promise<string>;

  'PACKAGE_VERSION()'(overrides?: CallOverrides): Promise<string>;

  isFraudulentMessageId(
    checkpoint: CheckpointStruct,
    proof: BytesLike[],
    actualMessageId: BytesLike,
    overrides?: CallOverrides,
  ): Promise<boolean>;

  'isFraudulentMessageId((uint32,bytes32,bytes32,uint32,bytes32),bytes32[32],bytes32)'(
    checkpoint: CheckpointStruct,
    proof: BytesLike[],
    actualMessageId: BytesLike,
    overrides?: CallOverrides,
  ): Promise<boolean>;

  isFraudulentRoot(
    checkpoint: CheckpointStruct,
    proof: BytesLike[],
    overrides?: CallOverrides,
  ): Promise<boolean>;

  'isFraudulentRoot((uint32,bytes32,bytes32,uint32,bytes32),bytes32[32])'(
    checkpoint: CheckpointStruct,
    proof: BytesLike[],
    overrides?: CallOverrides,
  ): Promise<boolean>;

  isLocal(
    checkpoint: CheckpointStruct,
    overrides?: CallOverrides,
  ): Promise<boolean>;

  'isLocal((uint32,bytes32,bytes32,uint32,bytes32))'(
    checkpoint: CheckpointStruct,
    overrides?: CallOverrides,
  ): Promise<boolean>;

  isPremature(
    checkpoint: CheckpointStruct,
    overrides?: CallOverrides,
  ): Promise<boolean>;

  'isPremature((uint32,bytes32,bytes32,uint32,bytes32))'(
    checkpoint: CheckpointStruct,
    overrides?: CallOverrides,
  ): Promise<boolean>;

  storeLatestCheckpoint(
    merkleTree: string,
    overrides?: Overrides & { from?: string },
  ): Promise<ContractTransaction>;

  'storeLatestCheckpoint(address)'(
    merkleTree: string,
    overrides?: Overrides & { from?: string },
  ): Promise<ContractTransaction>;

  storedCheckpointContainsMessage(
    merkleTree: string,
    index: BigNumberish,
    messageId: BytesLike,
    proof: BytesLike[],
    overrides?: CallOverrides,
  ): Promise<boolean>;

  'storedCheckpointContainsMessage(address,uint32,bytes32,bytes32[32])'(
    merkleTree: string,
    index: BigNumberish,
    messageId: BytesLike,
    proof: BytesLike[],
    overrides?: CallOverrides,
  ): Promise<boolean>;

  storedCheckpoints(
    merkleTree: string,
    root: BytesLike,
    overrides?: CallOverrides,
  ): Promise<[number, boolean] & { index: number; exists: boolean }>;

  'storedCheckpoints(address,bytes32)'(
    merkleTree: string,
    root: BytesLike,
    overrides?: CallOverrides,
  ): Promise<[number, boolean] & { index: number; exists: boolean }>;

  callStatic: {
    PACKAGE_VERSION(overrides?: CallOverrides): Promise<string>;

    'PACKAGE_VERSION()'(overrides?: CallOverrides): Promise<string>;

    isFraudulentMessageId(
      checkpoint: CheckpointStruct,
      proof: BytesLike[],
      actualMessageId: BytesLike,
      overrides?: CallOverrides,
    ): Promise<boolean>;

    'isFraudulentMessageId((uint32,bytes32,bytes32,uint32,bytes32),bytes32[32],bytes32)'(
      checkpoint: CheckpointStruct,
      proof: BytesLike[],
      actualMessageId: BytesLike,
      overrides?: CallOverrides,
    ): Promise<boolean>;

    isFraudulentRoot(
      checkpoint: CheckpointStruct,
      proof: BytesLike[],
      overrides?: CallOverrides,
    ): Promise<boolean>;

    'isFraudulentRoot((uint32,bytes32,bytes32,uint32,bytes32),bytes32[32])'(
      checkpoint: CheckpointStruct,
      proof: BytesLike[],
      overrides?: CallOverrides,
    ): Promise<boolean>;

    isLocal(
      checkpoint: CheckpointStruct,
      overrides?: CallOverrides,
    ): Promise<boolean>;

    'isLocal((uint32,bytes32,bytes32,uint32,bytes32))'(
      checkpoint: CheckpointStruct,
      overrides?: CallOverrides,
    ): Promise<boolean>;

    isPremature(
      checkpoint: CheckpointStruct,
      overrides?: CallOverrides,
    ): Promise<boolean>;

    'isPremature((uint32,bytes32,bytes32,uint32,bytes32))'(
      checkpoint: CheckpointStruct,
      overrides?: CallOverrides,
    ): Promise<boolean>;

    storeLatestCheckpoint(
      merkleTree: string,
      overrides?: CallOverrides,
    ): Promise<[string, number] & { root: string; index: number }>;

    'storeLatestCheckpoint(address)'(
      merkleTree: string,
      overrides?: CallOverrides,
    ): Promise<[string, number] & { root: string; index: number }>;

    storedCheckpointContainsMessage(
      merkleTree: string,
      index: BigNumberish,
      messageId: BytesLike,
      proof: BytesLike[],
      overrides?: CallOverrides,
    ): Promise<boolean>;

    'storedCheckpointContainsMessage(address,uint32,bytes32,bytes32[32])'(
      merkleTree: string,
      index: BigNumberish,
      messageId: BytesLike,
      proof: BytesLike[],
      overrides?: CallOverrides,
    ): Promise<boolean>;

    storedCheckpoints(
      merkleTree: string,
      root: BytesLike,
      overrides?: CallOverrides,
    ): Promise<[number, boolean] & { index: number; exists: boolean }>;

    'storedCheckpoints(address,bytes32)'(
      merkleTree: string,
      root: BytesLike,
      overrides?: CallOverrides,
    ): Promise<[number, boolean] & { index: number; exists: boolean }>;
  };

  filters: {};

  estimateGas: {
    PACKAGE_VERSION(overrides?: CallOverrides): Promise<BigNumber>;

    'PACKAGE_VERSION()'(overrides?: CallOverrides): Promise<BigNumber>;

    isFraudulentMessageId(
      checkpoint: CheckpointStruct,
      proof: BytesLike[],
      actualMessageId: BytesLike,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    'isFraudulentMessageId((uint32,bytes32,bytes32,uint32,bytes32),bytes32[32],bytes32)'(
      checkpoint: CheckpointStruct,
      proof: BytesLike[],
      actualMessageId: BytesLike,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    isFraudulentRoot(
      checkpoint: CheckpointStruct,
      proof: BytesLike[],
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    'isFraudulentRoot((uint32,bytes32,bytes32,uint32,bytes32),bytes32[32])'(
      checkpoint: CheckpointStruct,
      proof: BytesLike[],
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    isLocal(
      checkpoint: CheckpointStruct,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    'isLocal((uint32,bytes32,bytes32,uint32,bytes32))'(
      checkpoint: CheckpointStruct,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    isPremature(
      checkpoint: CheckpointStruct,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    'isPremature((uint32,bytes32,bytes32,uint32,bytes32))'(
      checkpoint: CheckpointStruct,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    storeLatestCheckpoint(
      merkleTree: string,
      overrides?: Overrides & { from?: string },
    ): Promise<BigNumber>;

    'storeLatestCheckpoint(address)'(
      merkleTree: string,
      overrides?: Overrides & { from?: string },
    ): Promise<BigNumber>;

    storedCheckpointContainsMessage(
      merkleTree: string,
      index: BigNumberish,
      messageId: BytesLike,
      proof: BytesLike[],
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    'storedCheckpointContainsMessage(address,uint32,bytes32,bytes32[32])'(
      merkleTree: string,
      index: BigNumberish,
      messageId: BytesLike,
      proof: BytesLike[],
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    storedCheckpoints(
      merkleTree: string,
      root: BytesLike,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    'storedCheckpoints(address,bytes32)'(
      merkleTree: string,
      root: BytesLike,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    PACKAGE_VERSION(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    'PACKAGE_VERSION()'(
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    isFraudulentMessageId(
      checkpoint: CheckpointStruct,
      proof: BytesLike[],
      actualMessageId: BytesLike,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    'isFraudulentMessageId((uint32,bytes32,bytes32,uint32,bytes32),bytes32[32],bytes32)'(
      checkpoint: CheckpointStruct,
      proof: BytesLike[],
      actualMessageId: BytesLike,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    isFraudulentRoot(
      checkpoint: CheckpointStruct,
      proof: BytesLike[],
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    'isFraudulentRoot((uint32,bytes32,bytes32,uint32,bytes32),bytes32[32])'(
      checkpoint: CheckpointStruct,
      proof: BytesLike[],
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    isLocal(
      checkpoint: CheckpointStruct,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    'isLocal((uint32,bytes32,bytes32,uint32,bytes32))'(
      checkpoint: CheckpointStruct,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    isPremature(
      checkpoint: CheckpointStruct,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    'isPremature((uint32,bytes32,bytes32,uint32,bytes32))'(
      checkpoint: CheckpointStruct,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    storeLatestCheckpoint(
      merkleTree: string,
      overrides?: Overrides & { from?: string },
    ): Promise<PopulatedTransaction>;

    'storeLatestCheckpoint(address)'(
      merkleTree: string,
      overrides?: Overrides & { from?: string },
    ): Promise<PopulatedTransaction>;

    storedCheckpointContainsMessage(
      merkleTree: string,
      index: BigNumberish,
      messageId: BytesLike,
      proof: BytesLike[],
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    'storedCheckpointContainsMessage(address,uint32,bytes32,bytes32[32])'(
      merkleTree: string,
      index: BigNumberish,
      messageId: BytesLike,
      proof: BytesLike[],
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    storedCheckpoints(
      merkleTree: string,
      root: BytesLike,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    'storedCheckpoints(address,bytes32)'(
      merkleTree: string,
      root: BytesLike,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;
  };
}
