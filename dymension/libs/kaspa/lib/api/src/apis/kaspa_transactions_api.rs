/*
 * Kaspa REST-API server
 *
 * This server is to communicate with kaspa network via REST-API
 *
 * The version of the OpenAPI document: a6a9569
 *
 * Generated by: https://openapi-generator.tech
 */

use super::{configuration, ContentType, Error};
use crate::{apis::ResponseContent, models};
use reqwest;
use serde::{de::Error as _, Deserialize, Serialize};

/// struct for passing parameters to the method [`calculate_transaction_mass_transactions_mass_post`]
#[derive(Clone, Debug)]
pub struct CalculateTransactionMassTransactionsMassPostParams {
    pub submit_tx_model: models::SubmitTxModel,
}

/// struct for passing parameters to the method [`get_transaction_acceptance_transactions_acceptance_post`]
#[derive(Clone, Debug)]
pub struct GetTransactionAcceptanceTransactionsAcceptancePostParams {
    pub tx_acceptance_request: models::TxAcceptanceRequest,
}

/// struct for passing parameters to the method [`get_transaction_transactions_transaction_id_get`]
#[derive(Clone, Debug)]
pub struct GetTransactionTransactionsTransactionIdGetParams {
    pub transaction_id: String,
    /// Specify a containing block (if known) for faster lookup
    pub block_hash: Option<String>,
    pub inputs: Option<bool>,
    pub outputs: Option<bool>,
    /// Use this parameter if you want to fetch the TransactionInput previous outpoint details. Light fetches only the address and amount. Full fetches the whole TransactionOutput and adds it into each TxInput.
    pub resolve_previous_outpoints: Option<String>,
}

/// struct for passing parameters to the method [`search_for_transactions_transactions_search_post`]
#[derive(Clone, Debug)]
pub struct SearchForTransactionsTransactionsSearchPostParams {
    pub tx_search: models::TxSearch,
    pub fields: Option<String>,
    /// Use this parameter if you want to fetch the TransactionInput previous outpoint details. Light fetches only the address and amount. Full fetches the whole TransactionOutput and adds it into each TxInput.
    pub resolve_previous_outpoints: Option<models::PreviousOutpointLookupMode>,
    /// Only used when searching using transactionIds
    pub acceptance: Option<models::AcceptanceMode>,
}

/// struct for passing parameters to the method [`submit_a_new_transaction_transactions_post`]
#[derive(Clone, Debug)]
pub struct SubmitANewTransactionTransactionsPostParams {
    pub submit_transaction_request: models::SubmitTransactionRequest,
    /// Replace an existing transaction in the mempool
    pub replace_by_fee: Option<bool>,
}

/// struct for typed errors of method [`calculate_transaction_mass_transactions_mass_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CalculateTransactionMassTransactionsMassPostError {
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_transaction_acceptance_transactions_acceptance_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTransactionAcceptanceTransactionsAcceptancePostError {
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_transaction_transactions_transaction_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTransactionTransactionsTransactionIdGetError {
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`search_for_transactions_transactions_search_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SearchForTransactionsTransactionsSearchPostError {
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`submit_a_new_transaction_transactions_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SubmitANewTransactionTransactionsPostError {
    Status400(models::SubmitTransactionResponse),
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// This function calculates and returns the mass of a transaction, which is essential for determining the minimum fee. The mass calculation takes into account the storage mass as defined in KIP-0009.  Note: Be aware that if the transaction has a very low output amount or a high number of outputs, the mass can become significantly large.
pub async fn calculate_transaction_mass_transactions_mass_post(
    configuration: &configuration::Configuration,
    params: CalculateTransactionMassTransactionsMassPostParams,
) -> Result<models::TxMass, Error<CalculateTransactionMassTransactionsMassPostError>> {
    let uri_str = format!("{}/transactions/mass", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&params.submit_tx_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TxMass`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TxMass`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CalculateTransactionMassTransactionsMassPostError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Given a list of transaction_ids, return whether each one is accepted
pub async fn get_transaction_acceptance_transactions_acceptance_post(
    configuration: &configuration::Configuration,
    params: GetTransactionAcceptanceTransactionsAcceptancePostParams,
) -> Result<
    Vec<models::TxAcceptanceResponse>,
    Error<GetTransactionAcceptanceTransactionsAcceptancePostError>,
> {
    let uri_str = format!("{}/transactions/acceptance", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&params.tx_acceptance_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::TxAcceptanceResponse&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::TxAcceptanceResponse&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTransactionAcceptanceTransactionsAcceptancePostError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get details for a given transaction id
pub async fn get_transaction_transactions_transaction_id_get(
    configuration: &configuration::Configuration,
    params: GetTransactionTransactionsTransactionIdGetParams,
) -> Result<models::TxModel, Error<GetTransactionTransactionsTransactionIdGetError>> {
    let uri_str = format!(
        "{}/transactions/{transactionId}",
        configuration.base_path,
        transactionId = crate::apis::urlencode(params.transaction_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.block_hash {
        req_builder = req_builder.query(&[("blockHash", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.inputs {
        req_builder = req_builder.query(&[("inputs", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.outputs {
        req_builder = req_builder.query(&[("outputs", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.resolve_previous_outpoints {
        req_builder =
            req_builder.query(&[("resolve_previous_outpoints", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TxModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TxModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTransactionTransactionsTransactionIdGetError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Search for transactions by transaction_ids or blue_score
pub async fn search_for_transactions_transactions_search_post(
    configuration: &configuration::Configuration,
    params: SearchForTransactionsTransactionsSearchPostParams,
) -> Result<Vec<models::TxModel>, Error<SearchForTransactionsTransactionsSearchPostError>> {
    let uri_str = format!("{}/transactions/search", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = params.fields {
        req_builder = req_builder.query(&[("fields", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.resolve_previous_outpoints {
        req_builder =
            req_builder.query(&[("resolve_previous_outpoints", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.acceptance {
        req_builder = req_builder.query(&[("acceptance", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&params.tx_search);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::TxModel&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::TxModel&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SearchForTransactionsTransactionsSearchPostError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn submit_a_new_transaction_transactions_post(
    configuration: &configuration::Configuration,
    params: SubmitANewTransactionTransactionsPostParams,
) -> Result<models::SubmitTransactionResponse, Error<SubmitANewTransactionTransactionsPostError>> {
    let uri_str = format!("{}/transactions", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = params.replace_by_fee {
        req_builder = req_builder.query(&[("replaceByFee", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&params.submit_transaction_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SubmitTransactionResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SubmitTransactionResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SubmitANewTransactionTransactionsPostError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}
