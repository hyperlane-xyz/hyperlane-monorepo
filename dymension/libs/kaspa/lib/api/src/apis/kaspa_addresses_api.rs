/*
 * Kaspa REST-API server
 *
 * This server is to communicate with kaspa network via REST-API
 *
 * The version of the OpenAPI document: a6a9569
 *
 * Generated by: https://openapi-generator.tech
 */

use super::{configuration, ContentType, Error};
use crate::{apis::ResponseContent, models};
use reqwest;
use serde::{de::Error as _, Deserialize, Serialize};

/// struct for passing parameters to the method [`get_addresses_active_addresses_active_post`]
#[derive(Clone, Debug)]
pub struct GetAddressesActiveAddressesActivePostParams {
    pub addresses_active_request: models::AddressesActiveRequest,
}

/// struct for passing parameters to the method [`get_balance_from_kaspa_address_addresses_kaspa_address_balance_get`]
#[derive(Clone, Debug)]
pub struct GetBalanceFromKaspaAddressAddressesKaspaAddressBalanceGetParams {
    /// Kaspa address as string e.g. kaspa:qqkqkzjvr7zwxxmjxjkmxxdwju9kjs6e9u82uh59z07vgaks6gg62v8707g73
    pub kaspa_address: String,
}

/// struct for passing parameters to the method [`get_balances_from_kaspa_addresses_addresses_balances_post`]
#[derive(Clone, Debug)]
pub struct GetBalancesFromKaspaAddressesAddressesBalancesPostParams {
    pub balance_request: models::BalanceRequest,
}

/// struct for passing parameters to the method [`get_full_transactions_for_address_addresses_kaspa_address_full_transactions_get`]
#[derive(Clone, Debug)]
pub struct GetFullTransactionsForAddressAddressesKaspaAddressFullTransactionsGetParams {
    /// Kaspa address as string e.g. kaspa:qqkqkzjvr7zwxxmjxjkmxxdwju9kjs6e9u82uh59z07vgaks6gg62v8707g73
    pub kaspa_address: String,
    /// The number of records to get
    pub limit: Option<i64>,
    /// The offset from which to get records
    pub offset: Option<i64>,
    pub fields: Option<String>,
    /// Use this parameter if you want to fetch the TransactionInput previous outpoint details. Light fetches only the adress and amount. Full fetches the whole TransactionOutput and adds it into each TxInput.
    pub resolve_previous_outpoints: Option<String>,
}

/// struct for passing parameters to the method [`get_full_transactions_for_address_page_addresses_kaspa_address_full_transactions_page_get`]
#[derive(Clone, Debug)]
pub struct GetFullTransactionsForAddressPageAddressesKaspaAddressFullTransactionsPageGetParams {
    /// Kaspa address as string e.g. kaspa:qqkqkzjvr7zwxxmjxjkmxxdwju9kjs6e9u82uh59z07vgaks6gg62v8707g73
    pub kaspa_address: String,
    /// The max number of records to get. For paging combine with using 'before/after' from oldest previous result. Use value of X-Next-Page-Before/-After as long as header is present to continue paging. The actual number of transactions returned for each page can be > limit.
    pub limit: Option<i64>,
    /// Only include transactions with block time before this (epoch-millis)
    pub before: Option<i64>,
    /// Only include transactions with block time after this (epoch-millis)
    pub after: Option<i64>,
    pub fields: Option<String>,
    /// Use this parameter if you want to fetch the TransactionInput previous outpoint details. Light fetches only the adress and amount. Full fetches the whole TransactionOutput and adds it into each TxInput.
    pub resolve_previous_outpoints: Option<String>,
    pub acceptance: Option<models::AcceptanceMode>,
}

/// struct for passing parameters to the method [`get_name_for_address_addresses_kaspa_address_name_get`]
#[derive(Clone, Debug)]
pub struct GetNameForAddressAddressesKaspaAddressNameGetParams {
    /// Kaspa address as string e.g. kaspa:qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqkx9awp4e
    pub kaspa_address: String,
}

/// struct for passing parameters to the method [`get_transaction_count_for_address_addresses_kaspa_address_transactions_count_get`]
#[derive(Clone, Debug)]
pub struct GetTransactionCountForAddressAddressesKaspaAddressTransactionsCountGetParams {
    /// Kaspa address as string e.g. kaspa:qqkqkzjvr7zwxxmjxjkmxxdwju9kjs6e9u82uh59z07vgaks6gg62v8707g73
    pub kaspa_address: String,
}

/// struct for passing parameters to the method [`get_utxos_for_address_addresses_kaspa_address_utxos_get`]
#[derive(Clone, Debug)]
pub struct GetUtxosForAddressAddressesKaspaAddressUtxosGetParams {
    /// Kaspa address as string e.g. kaspa:qqkqkzjvr7zwxxmjxjkmxxdwju9kjs6e9u82uh59z07vgaks6gg62v8707g73
    pub kaspa_address: String,
}

/// struct for passing parameters to the method [`get_utxos_for_addresses_addresses_utxos_post`]
#[derive(Clone, Debug)]
pub struct GetUtxosForAddressesAddressesUtxosPostParams {
    pub utxo_request: models::UtxoRequest,
}

/// struct for typed errors of method [`get_addresses_active_addresses_active_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAddressesActiveAddressesActivePostError {
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_addresses_names_addresses_names_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAddressesNamesAddressesNamesGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_balance_from_kaspa_address_addresses_kaspa_address_balance_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetBalanceFromKaspaAddressAddressesKaspaAddressBalanceGetError {
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_balances_from_kaspa_addresses_addresses_balances_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetBalancesFromKaspaAddressesAddressesBalancesPostError {
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_full_transactions_for_address_addresses_kaspa_address_full_transactions_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetFullTransactionsForAddressAddressesKaspaAddressFullTransactionsGetError {
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_full_transactions_for_address_page_addresses_kaspa_address_full_transactions_page_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetFullTransactionsForAddressPageAddressesKaspaAddressFullTransactionsPageGetError {
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_name_for_address_addresses_kaspa_address_name_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetNameForAddressAddressesKaspaAddressNameGetError {
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_transaction_count_for_address_addresses_kaspa_address_transactions_count_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTransactionCountForAddressAddressesKaspaAddressTransactionsCountGetError {
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_utxos_for_address_addresses_kaspa_address_utxos_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetUtxosForAddressAddressesKaspaAddressUtxosGetError {
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_utxos_for_addresses_addresses_utxos_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetUtxosForAddressesAddressesUtxosPostError {
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// This endpoint checks if addresses have had any transaction activity in the past. It is specifically designed for HD Wallets to verify historical address activity.
pub async fn get_addresses_active_addresses_active_post(
    configuration: &configuration::Configuration,
    params: GetAddressesActiveAddressesActivePostParams,
) -> Result<Vec<models::TxIdResponse>, Error<GetAddressesActiveAddressesActivePostError>> {
    let uri_str = format!("{}/addresses/active", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&params.addresses_active_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::TxIdResponse&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::TxIdResponse&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetAddressesActiveAddressesActivePostError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get the name for an address
pub async fn get_addresses_names_addresses_names_get(
    configuration: &configuration::Configuration,
) -> Result<Vec<models::AddressName>, Error<GetAddressesNamesAddressesNamesGetError>> {
    let uri_str = format!("{}/addresses/names", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::AddressName&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::AddressName&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetAddressesNamesAddressesNamesGetError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get balance for a given kaspa address
pub async fn get_balance_from_kaspa_address_addresses_kaspa_address_balance_get(
    configuration: &configuration::Configuration,
    params: GetBalanceFromKaspaAddressAddressesKaspaAddressBalanceGetParams,
) -> Result<
    models::BalanceResponse,
    Error<GetBalanceFromKaspaAddressAddressesKaspaAddressBalanceGetError>,
> {
    let uri_str = format!(
        "{}/addresses/{kaspaAddress}/balance",
        configuration.base_path,
        kaspaAddress = crate::apis::urlencode(params.kaspa_address)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BalanceResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BalanceResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetBalanceFromKaspaAddressAddressesKaspaAddressBalanceGetError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get balances for multiple kaspa addresses
pub async fn get_balances_from_kaspa_addresses_addresses_balances_post(
    configuration: &configuration::Configuration,
    params: GetBalancesFromKaspaAddressesAddressesBalancesPostParams,
) -> Result<
    Vec<models::BalancesByAddressEntry>,
    Error<GetBalancesFromKaspaAddressesAddressesBalancesPostError>,
> {
    let uri_str = format!("{}/addresses/balances", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&params.balance_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::BalancesByAddressEntry&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::BalancesByAddressEntry&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetBalancesFromKaspaAddressesAddressesBalancesPostError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get all transactions for a given address from database. And then get their related full transaction data
pub async fn get_full_transactions_for_address_addresses_kaspa_address_full_transactions_get(
    configuration: &configuration::Configuration,
    params: GetFullTransactionsForAddressAddressesKaspaAddressFullTransactionsGetParams,
) -> Result<
    Vec<models::TxModel>,
    Error<GetFullTransactionsForAddressAddressesKaspaAddressFullTransactionsGetError>,
> {
    let uri_str = format!(
        "{}/addresses/{kaspaAddress}/full-transactions",
        configuration.base_path,
        kaspaAddress = crate::apis::urlencode(params.kaspa_address)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.fields {
        req_builder = req_builder.query(&[("fields", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.resolve_previous_outpoints {
        req_builder =
            req_builder.query(&[("resolve_previous_outpoints", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::TxModel&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::TxModel&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<
            GetFullTransactionsForAddressAddressesKaspaAddressFullTransactionsGetError,
        > = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get all transactions for a given address from database. And then get their related full transaction data
pub async fn get_full_transactions_for_address_page_addresses_kaspa_address_full_transactions_page_get(
    configuration: &configuration::Configuration,
    params: GetFullTransactionsForAddressPageAddressesKaspaAddressFullTransactionsPageGetParams,
) -> Result<
    Vec<models::TxModel>,
    Error<GetFullTransactionsForAddressPageAddressesKaspaAddressFullTransactionsPageGetError>,
> {
    let uri_str = format!(
        "{}/addresses/{kaspaAddress}/full-transactions-page",
        configuration.base_path,
        kaspaAddress = crate::apis::urlencode(params.kaspa_address)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.before {
        req_builder = req_builder.query(&[("before", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.after {
        req_builder = req_builder.query(&[("after", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.fields {
        req_builder = req_builder.query(&[("fields", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.resolve_previous_outpoints {
        req_builder =
            req_builder.query(&[("resolve_previous_outpoints", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.acceptance {
        req_builder = req_builder.query(&[("acceptance", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::TxModel&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::TxModel&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<
            GetFullTransactionsForAddressPageAddressesKaspaAddressFullTransactionsPageGetError,
        > = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get the name for an address
pub async fn get_name_for_address_addresses_kaspa_address_name_get(
    configuration: &configuration::Configuration,
    params: GetNameForAddressAddressesKaspaAddressNameGetParams,
) -> Result<models::AddressName, Error<GetNameForAddressAddressesKaspaAddressNameGetError>> {
    let uri_str = format!(
        "{}/addresses/{kaspaAddress}/name",
        configuration.base_path,
        kaspaAddress = crate::apis::urlencode(params.kaspa_address)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AddressName`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AddressName`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetNameForAddressAddressesKaspaAddressNameGetError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Count the number of transactions associated with this address
pub async fn get_transaction_count_for_address_addresses_kaspa_address_transactions_count_get(
    configuration: &configuration::Configuration,
    params: GetTransactionCountForAddressAddressesKaspaAddressTransactionsCountGetParams,
) -> Result<
    models::TransactionCount,
    Error<GetTransactionCountForAddressAddressesKaspaAddressTransactionsCountGetError>,
> {
    let uri_str = format!(
        "{}/addresses/{kaspaAddress}/transactions-count",
        configuration.base_path,
        kaspaAddress = crate::apis::urlencode(params.kaspa_address)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TransactionCount`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TransactionCount`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<
            GetTransactionCountForAddressAddressesKaspaAddressTransactionsCountGetError,
        > = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Lists all open utxo for a given kaspa address
pub async fn get_utxos_for_address_addresses_kaspa_address_utxos_get(
    configuration: &configuration::Configuration,
    params: GetUtxosForAddressAddressesKaspaAddressUtxosGetParams,
) -> Result<Vec<models::UtxoResponse>, Error<GetUtxosForAddressAddressesKaspaAddressUtxosGetError>>
{
    let uri_str = format!(
        "{}/addresses/{kaspaAddress}/utxos",
        configuration.base_path,
        kaspaAddress = crate::apis::urlencode(params.kaspa_address)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::UtxoResponse&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::UtxoResponse&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetUtxosForAddressAddressesKaspaAddressUtxosGetError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Lists all open utxo for a given kaspa address
pub async fn get_utxos_for_addresses_addresses_utxos_post(
    configuration: &configuration::Configuration,
    params: GetUtxosForAddressesAddressesUtxosPostParams,
) -> Result<Vec<models::UtxoResponse>, Error<GetUtxosForAddressesAddressesUtxosPostError>> {
    let uri_str = format!("{}/addresses/utxos", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&params.utxo_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::UtxoResponse&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::UtxoResponse&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetUtxosForAddressesAddressesUtxosPostError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}
