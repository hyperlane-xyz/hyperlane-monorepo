/*
 * Kaspa REST-API server
 *
 * This server is to communicate with kaspa network via REST-API
 *
 * The version of the OpenAPI document: a6a9569
 *
 * Generated by: https://openapi-generator.tech
 */

use super::{configuration, ContentType, Error};
use crate::{apis::ResponseContent, models};
use reqwest;
use serde::{de::Error as _, Deserialize, Serialize};

/// struct for passing parameters to the method [`get_blockreward_info_blockreward_get`]
#[derive(Clone, Debug)]
pub struct GetBlockrewardInfoBlockrewardGetParams {
    pub string_only: Option<bool>,
}

/// struct for passing parameters to the method [`get_circulating_coins_info_coinsupply_circulating_get`]
#[derive(Clone, Debug)]
pub struct GetCirculatingCoinsInfoCoinsupplyCirculatingGetParams {
    pub in_billion: Option<bool>,
}

/// struct for passing parameters to the method [`get_halving_info_halving_get`]
#[derive(Clone, Debug)]
pub struct GetHalvingInfoHalvingGetParams {
    pub field: Option<String>,
}

/// struct for passing parameters to the method [`get_hashrate_history_info_hashrate_history_get`]
#[derive(Clone, Debug)]
pub struct GetHashrateHistoryInfoHashrateHistoryGetParams {
    pub resolution: Option<String>,
}

/// struct for passing parameters to the method [`get_hashrate_info_hashrate_get`]
#[derive(Clone, Debug)]
pub struct GetHashrateInfoHashrateGetParams {
    pub string_only: Option<bool>,
}

/// struct for passing parameters to the method [`get_marketcap_info_marketcap_get`]
#[derive(Clone, Debug)]
pub struct GetMarketcapInfoMarketcapGetParams {
    pub string_only: Option<bool>,
}

/// struct for passing parameters to the method [`get_price_info_price_get`]
#[derive(Clone, Debug)]
pub struct GetPriceInfoPriceGetParams {
    pub string_only: Option<bool>,
}

/// struct for passing parameters to the method [`get_total_coins_info_coinsupply_total_get`]
#[derive(Clone, Debug)]
pub struct GetTotalCoinsInfoCoinsupplyTotalGetParams {
    pub in_billion: Option<bool>,
}

/// struct for typed errors of method [`get_blockdag_info_blockdag_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetBlockdagInfoBlockdagGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_blockreward_info_blockreward_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetBlockrewardInfoBlockrewardGetError {
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_circulating_coins_info_coinsupply_circulating_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetCirculatingCoinsInfoCoinsupplyCirculatingGetError {
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_coinsupply_info_coinsupply_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetCoinsupplyInfoCoinsupplyGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_fee_estimate_info_fee_estimate_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetFeeEstimateInfoFeeEstimateGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_halving_info_halving_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetHalvingInfoHalvingGetError {
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_hashrate_history_info_hashrate_history_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetHashrateHistoryInfoHashrateHistoryGetError {
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_hashrate_info_hashrate_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetHashrateInfoHashrateGetError {
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_kaspad_info_info_kaspad_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetKaspadInfoInfoKaspadGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_marketcap_info_marketcap_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetMarketcapInfoMarketcapGetError {
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_max_hashrate_info_hashrate_max_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetMaxHashrateInfoHashrateMaxGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_network_info_network_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetNetworkInfoNetworkGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_price_info_price_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetPriceInfoPriceGetError {
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_total_coins_info_coinsupply_total_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTotalCoinsInfoCoinsupplyTotalGetError {
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_virtual_selected_parent_blue_score_info_virtual_chain_blue_score_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetVirtualSelectedParentBlueScoreInfoVirtualChainBlueScoreGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`health_state_info_health_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum HealthStateInfoHealthGetError {
    UnknownValue(serde_json::Value),
}

/// Get Kaspa BlockDAG information
pub async fn get_blockdag_info_blockdag_get(
    configuration: &configuration::Configuration,
) -> Result<models::BlockdagResponse, Error<GetBlockdagInfoBlockdagGetError>> {
    let uri_str = format!("{}/info/blockdag", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BlockdagResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BlockdagResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetBlockdagInfoBlockdagGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Returns the current blockreward in KAS/block
pub async fn get_blockreward_info_blockreward_get(
    configuration: &configuration::Configuration,
    params: GetBlockrewardInfoBlockrewardGetParams,
) -> Result<
    models::ResponseGetBlockrewardInfoBlockrewardGet,
    Error<GetBlockrewardInfoBlockrewardGetError>,
> {
    let uri_str = format!("{}/info/blockreward", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.string_only {
        req_builder = req_builder.query(&[("stringOnly", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ResponseGetBlockrewardInfoBlockrewardGet`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ResponseGetBlockrewardInfoBlockrewardGet`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetBlockrewardInfoBlockrewardGetError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get circulating amount of $KAS token as numerical value
pub async fn get_circulating_coins_info_coinsupply_circulating_get(
    configuration: &configuration::Configuration,
    params: GetCirculatingCoinsInfoCoinsupplyCirculatingGetParams,
) -> Result<String, Error<GetCirculatingCoinsInfoCoinsupplyCirculatingGetError>> {
    let uri_str = format!("{}/info/coinsupply/circulating", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.in_billion {
        req_builder = req_builder.query(&[("in_billion", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Ok(content),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `String`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetCirculatingCoinsInfoCoinsupplyCirculatingGetError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get $KAS coin supply information
pub async fn get_coinsupply_info_coinsupply_get(
    configuration: &configuration::Configuration,
) -> Result<models::CoinSupplyResponse, Error<GetCoinsupplyInfoCoinsupplyGetError>> {
    let uri_str = format!("{}/info/coinsupply", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CoinSupplyResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CoinSupplyResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetCoinsupplyInfoCoinsupplyGetError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get fee estimate from Kaspad.  For all buckets, feerate values represent fee/mass of a transaction in `sompi/gram` units.<br> Given a feerate value recommendation, calculate the required fee by taking the transaction mass and multiplying it by feerate: `fee = feerate * mass(tx)`
pub async fn get_fee_estimate_info_fee_estimate_get(
    configuration: &configuration::Configuration,
) -> Result<models::FeeEstimateResponse, Error<GetFeeEstimateInfoFeeEstimateGetError>> {
    let uri_str = format!("{}/info/fee-estimate", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::FeeEstimateResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::FeeEstimateResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetFeeEstimateInfoFeeEstimateGetError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Returns information about chromatic halving
pub async fn get_halving_info_halving_get(
    configuration: &configuration::Configuration,
    params: GetHalvingInfoHalvingGetParams,
) -> Result<models::ResponseGetHalvingInfoHalvingGet, Error<GetHalvingInfoHalvingGetError>> {
    let uri_str = format!("{}/info/halving", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.field {
        req_builder = req_builder.query(&[("field", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ResponseGetHalvingInfoHalvingGet`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ResponseGetHalvingInfoHalvingGet`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetHalvingInfoHalvingGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get historical hashrate samples with optional resolution (default = 1h)
pub async fn get_hashrate_history_info_hashrate_history_get(
    configuration: &configuration::Configuration,
    params: GetHashrateHistoryInfoHashrateHistoryGetParams,
) -> Result<
    Vec<models::HashrateHistoryResponse>,
    Error<GetHashrateHistoryInfoHashrateHistoryGetError>,
> {
    let uri_str = format!("{}/info/hashrate/history", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.resolution {
        req_builder = req_builder.query(&[("resolution", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::HashrateHistoryResponse&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::HashrateHistoryResponse&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetHashrateHistoryInfoHashrateHistoryGetError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Returns the current hashrate for Kaspa network in TH/s.
pub async fn get_hashrate_info_hashrate_get(
    configuration: &configuration::Configuration,
    params: GetHashrateInfoHashrateGetParams,
) -> Result<models::ResponseGetHashrateInfoHashrateGet, Error<GetHashrateInfoHashrateGetError>> {
    let uri_str = format!("{}/info/hashrate", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.string_only {
        req_builder = req_builder.query(&[("stringOnly", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ResponseGetHashrateInfoHashrateGet`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ResponseGetHashrateInfoHashrateGet`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetHashrateInfoHashrateGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get some information for kaspad instance, which is currently connected.
pub async fn get_kaspad_info_info_kaspad_get(
    configuration: &configuration::Configuration,
) -> Result<models::KaspadInfoResponse, Error<GetKaspadInfoInfoKaspadGetError>> {
    let uri_str = format!("{}/info/kaspad", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::KaspadInfoResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::KaspadInfoResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetKaspadInfoInfoKaspadGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get $KAS price and market cap. Price info is from coingecko.com
pub async fn get_marketcap_info_marketcap_get(
    configuration: &configuration::Configuration,
    params: GetMarketcapInfoMarketcapGetParams,
) -> Result<models::ResponseGetMarketcapInfoMarketcapGet, Error<GetMarketcapInfoMarketcapGetError>>
{
    let uri_str = format!("{}/info/marketcap", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.string_only {
        req_builder = req_builder.query(&[("stringOnly", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ResponseGetMarketcapInfoMarketcapGet`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ResponseGetMarketcapInfoMarketcapGet`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetMarketcapInfoMarketcapGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Returns the current hashrate for Kaspa network in TH/s.
pub async fn get_max_hashrate_info_hashrate_max_get(
    configuration: &configuration::Configuration,
) -> Result<models::MaxHashrateResponse, Error<GetMaxHashrateInfoHashrateMaxGetError>> {
    let uri_str = format!("{}/info/hashrate/max", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MaxHashrateResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MaxHashrateResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetMaxHashrateInfoHashrateMaxGetError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Alias for /info/blockdag
pub async fn get_network_info_network_get(
    configuration: &configuration::Configuration,
) -> Result<models::BlockdagResponse, Error<GetNetworkInfoNetworkGetError>> {
    let uri_str = format!("{}/info/network", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BlockdagResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BlockdagResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetNetworkInfoNetworkGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Returns the current price for Kaspa in USD.
pub async fn get_price_info_price_get(
    configuration: &configuration::Configuration,
    params: GetPriceInfoPriceGetParams,
) -> Result<models::ResponseGetPriceInfoPriceGet, Error<GetPriceInfoPriceGetError>> {
    let uri_str = format!("{}/info/price", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.string_only {
        req_builder = req_builder.query(&[("stringOnly", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ResponseGetPriceInfoPriceGet`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ResponseGetPriceInfoPriceGet`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetPriceInfoPriceGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get total amount of $KAS token as numerical value
pub async fn get_total_coins_info_coinsupply_total_get(
    configuration: &configuration::Configuration,
    params: GetTotalCoinsInfoCoinsupplyTotalGetParams,
) -> Result<String, Error<GetTotalCoinsInfoCoinsupplyTotalGetError>> {
    let uri_str = format!("{}/info/coinsupply/total", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.in_billion {
        req_builder = req_builder.query(&[("in_billion", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Ok(content),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `String`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTotalCoinsInfoCoinsupplyTotalGetError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Returns the blue score of the sink
pub async fn get_virtual_selected_parent_blue_score_info_virtual_chain_blue_score_get(
    configuration: &configuration::Configuration,
) -> Result<
    models::BlueScoreResponse,
    Error<GetVirtualSelectedParentBlueScoreInfoVirtualChainBlueScoreGetError>,
> {
    let uri_str = format!("{}/info/virtual-chain-blue-score", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BlueScoreResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BlueScoreResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetVirtualSelectedParentBlueScoreInfoVirtualChainBlueScoreGetError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Checks node and database health by comparing blue score and sync status. Returns health details or 503 if the database lags by ~10min or no nodes are synced.
pub async fn health_state_info_health_get(
    configuration: &configuration::Configuration,
) -> Result<models::HealthResponse, Error<HealthStateInfoHealthGetError>> {
    let uri_str = format!("{}/info/health", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::HealthResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::HealthResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<HealthStateInfoHealthGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}
