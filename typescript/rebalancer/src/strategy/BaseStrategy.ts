import { Logger } from 'pino';

import type { ChainName } from '@hyperlane-xyz/sdk';

import type {
  IStrategy,
  InflightContext,
  RawBalances,
  RebalancingRoute,
} from '../interfaces/IStrategy.js';
import { Metrics } from '../metrics/Metrics.js';

export type Delta = { chain: ChainName; amount: bigint };

/**
 * Base abstract class for rebalancing strategies
 */
export abstract class BaseStrategy implements IStrategy {
  protected readonly chains: ChainName[];
  protected readonly metrics?: Metrics;
  protected readonly logger: Logger;

  /** Optional bridge address to use for routes generated by this strategy */
  protected bridge?: string;

  constructor(chains: ChainName[], logger: Logger, metrics?: Metrics) {
    // Rebalancing makes sense only with more than one chain.
    if (chains.length < 2) {
      throw new Error('At least two chains must be configured');
    }
    this.chains = chains;
    this.logger = logger;
    this.metrics = metrics;
  }

  /**
   * Main method to get rebalancing routes
   * @param rawBalances Current on-chain balances
   * @param inflightContext Optional context about inflight messages
   */
  getRebalancingRoutes(
    rawBalances: RawBalances,
    inflightContext?: InflightContext,
  ): RebalancingRoute[] {
    this.logger.info(
      {
        context: this.constructor.name,
        rawBalances,
        hasPendingTransfers:
          (inflightContext?.pendingTransfers.length ?? 0) > 0,
        hasPendingRebalances:
          (inflightContext?.pendingRebalances.length ?? 0) > 0,
      },
      'Input rawBalances',
    );
    this.logger.info(
      {
        context: this.constructor.name,
      },
      'Calculating rebalancing routes',
    );

    // Phase 1: Reserve collateral for pending transfers
    const adjustedBalances = this.reserveCollateral(
      rawBalances,
      inflightContext?.pendingTransfers ?? [],
    );

    this.logger.debug(
      {
        context: this.constructor.name,
        adjustedBalances,
      },
      'Balances after collateral reservation',
    );

    // Phase 1.5: Fast-forward pending rebalances to see effective future balances
    const fastforwardedBalances = this.fastforwardRebalances(
      adjustedBalances,
      inflightContext?.pendingRebalances ?? [],
    );

    this.logger.debug(
      {
        context: this.constructor.name,
        fastforwardedBalances,
      },
      'Balances after fast-forwarding pending rebalances',
    );

    this.validateRawBalances(rawBalances);

    // Phase 2: Get balances categorized by surplus and deficit
    const { surpluses, deficits } = this.getCategorizedBalances(
      fastforwardedBalances,
      inflightContext?.pendingRebalances ?? [],
    );

    this.logger.debug(
      {
        context: this.constructor.name,
        surpluses,
      },
      'Surpluses calculated',
    );
    this.logger.debug(
      {
        context: this.constructor.name,
        deficits,
      },
      'Deficits calculated',
    );

    // Calculate sums of surpluses and deficits
    const totalSurplus = surpluses.reduce(
      (sum, surplus) => sum + surplus.amount,
      0n,
    );
    const totalDeficit = deficits.reduce(
      (sum, deficit) => sum + deficit.amount,
      0n,
    );

    this.logger.debug(
      {
        context: this.constructor.name,
        totalSurplus: totalSurplus.toString(),
      },
      'Total surplus calculated',
    );
    this.logger.debug(
      {
        context: this.constructor.name,
        totalDeficit: totalDeficit.toString(),
      },
      'Total deficit calculated',
    );

    // If total surplus is less than total deficit, scale down deficits proportionally
    if (totalSurplus < totalDeficit) {
      this.logger.warn(
        {
          context: this.constructor.name,
          totalSurplus: totalSurplus.toString(),
          totalDeficit: totalDeficit.toString(),
        },
        'Deficits are greater than surpluses. Scaling deficits',
      );

      // we consider this a failure because we cannot rebalance the route completely
      // however we can still transfer some amount of the deficit to reduce the imbalances
      this.metrics?.recordRebalancerFailure();

      for (const deficit of deficits) {
        const newAmount = (deficit.amount * totalSurplus) / totalDeficit;

        deficit.amount = newAmount;
      }

      this.logger.debug(
        {
          context: this.constructor.name,
          deficits,
        },
        'Scaled deficits',
      );
    }

    // Sort from largest to smallest amounts as to always transfer largest amounts
    // first and decrease the amount of routes required
    surpluses.sort((a, b) => (a.amount > b.amount ? -1 : 1));
    deficits.sort((a, b) => (a.amount > b.amount ? -1 : 1));

    const routes: RebalancingRoute[] = [];

    // Transfer from surplus to deficit until all deficits are balanced.
    while (deficits.length > 0 && surpluses.length > 0) {
      const surplus = surpluses[0];
      const deficit = deficits[0];

      // Transfers the whole surplus or just the amount to balance the deficit
      const transferAmount =
        surplus.amount > deficit.amount ? deficit.amount : surplus.amount;

      // Creates the balancing route
      routes.push({
        origin: surplus.chain,
        destination: deficit.chain,
        amount: transferAmount,
      });

      // Decreases the amounts for the following iterations
      deficit.amount -= transferAmount;
      surplus.amount -= transferAmount;

      // Removes the deficit if it is fully balanced
      if (!deficit.amount) {
        deficits.shift();
      }

      // Removes the surplus if it has been drained
      if (!surplus.amount) {
        surpluses.shift();
      }
    }

    // Phase 4: Add bridge to routes if configured
    const routesWithBridge = routes.map((route) =>
      this.bridge ? { ...route, bridge: this.bridge } : route,
    );

    // Phase 5: Filter routes based on pending rebalances
    const filteredRoutes = this.filterRebalances(
      routesWithBridge,
      inflightContext?.pendingRebalances ?? [],
    );

    this.logger.debug(
      {
        context: this.constructor.name,
        routes: filteredRoutes,
      },
      'Generated routes',
    );
    this.logger.info(
      {
        context: this.constructor.name,
        numberOfRoutes: filteredRoutes.length,
        filteredOut: routesWithBridge.length - filteredRoutes.length,
      },
      'Found rebalancing routes',
    );
    return filteredRoutes;
  }

  /**
   * Abstract method to get balances categorized by surplus and deficit
   * Each specific strategy should implement its own logic
   * @param rawBalances Adjusted balances after collateral reservation
   * @param pendingRebalances Pending rebalances that may affect categorization
   */
  protected abstract getCategorizedBalances(
    rawBalances: RawBalances,
    pendingRebalances: RebalancingRoute[],
  ): {
    surpluses: Delta[];
    deficits: Delta[];
  };

  /**
   * Validates the raw balances against the chains configuration
   * @param rawBalances Balances to validate
   * @param allowNegative Whether to allow negative balances (for adjusted balances)
   */
  protected validateRawBalances(
    rawBalances: RawBalances,
    allowNegative = false,
  ): void {
    const rawBalancesChains = Object.keys(rawBalances);

    if (this.chains.length !== rawBalancesChains.length) {
      throw new Error('Config chains do not match raw balances chains length');
    }

    for (const chain of this.chains) {
      const balance: bigint | undefined = rawBalances[chain];

      if (balance === undefined) {
        throw new Error(`Raw balance for chain ${chain} not found`);
      }

      if (!allowNegative && balance < 0n) {
        throw new Error(`Raw balance for chain ${chain} is negative`);
      }
    }
  }

  /**
   * Reserve collateral for pending transfers by subtracting their amounts
   * from the destination chain balances.
   *
   * This ensures strategies don't propose rebalances that would drain
   * collateral needed for pending deliveries.
   *
   * @param rawBalances Current on-chain balances
   * @param pendingTransfers Pending user transfers that need collateral
   * @returns Adjusted balances with reservations applied
   */
  protected reserveCollateral(
    rawBalances: RawBalances,
    pendingTransfers: RebalancingRoute[],
  ): RawBalances {
    if (pendingTransfers.length === 0) {
      return { ...rawBalances };
    }

    const adjusted: RawBalances = { ...rawBalances };

    for (const transfer of pendingTransfers) {
      const { destination, amount } = transfer;

      if (adjusted[destination] !== undefined) {
        adjusted[destination] -= amount;

        this.logger.debug(
          {
            context: this.constructor.name,
            destination,
            amount: amount.toString(),
            newBalance: adjusted[destination].toString(),
          },
          'Reserved collateral for pending transfer',
        );
      }
    }

    return adjusted;
  }

  /**
   * Fast-forward pending rebalances to see effective future balances.
   *
   * This simulates the effect of pending rebalances on balances so strategies
   * can make decisions based on expected future state.
   *
   * @param rawBalances Current balances (potentially adjusted)
   * @param pendingRebalances Pending rebalances to fast-forward
   * @returns Balances with pending rebalances applied
   */
  protected fastforwardRebalances(
    rawBalances: RawBalances,
    pendingRebalances: RebalancingRoute[],
  ): RawBalances {
    if (pendingRebalances.length === 0) {
      return { ...rawBalances };
    }

    const adjusted: RawBalances = { ...rawBalances };

    for (const rebalance of pendingRebalances) {
      const { origin, destination, amount } = rebalance;

      // Subtract from origin
      if (adjusted[origin] !== undefined) {
        adjusted[origin] -= amount;
      }

      // Add to destination
      if (adjusted[destination] !== undefined) {
        adjusted[destination] += amount;
      }

      this.logger.debug(
        {
          context: this.constructor.name,
          origin,
          destination,
          amount: amount.toString(),
        },
        'Fast-forwarded pending rebalance',
      );
    }

    return adjusted;
  }

  /**
   * Filter proposed rebalances based on pending rebalances.
   *
   * This removes routes that would fail because the actual router balance
   * is insufficient, or routes that are redundant given pending rebalances.
   *
   * @param proposedRoutes Routes proposed by the strategy
   * @param pendingRebalances Existing pending rebalances
   * @returns Filtered routes that should be executed
   */
  protected filterRebalances(
    proposedRoutes: RebalancingRoute[],
    pendingRebalances: RebalancingRoute[],
  ): RebalancingRoute[] {
    if (pendingRebalances.length === 0) {
      return proposedRoutes;
    }

    // Create a map of pending rebalances by destination
    const pendingByDest = new Map<string, bigint>();
    for (const rebalance of pendingRebalances) {
      const current = pendingByDest.get(rebalance.destination) ?? 0n;
      pendingByDest.set(rebalance.destination, current + rebalance.amount);
    }

    // Filter out routes that are redundant with pending rebalances
    return proposedRoutes.filter((route) => {
      const pendingToSameDest = pendingByDest.get(route.destination) ?? 0n;

      // If there's already a significant pending rebalance to this destination,
      // we might want to skip this route (depending on strategy)
      // For now, we allow all routes and let specific strategies override
      if (pendingToSameDest > 0n) {
        this.logger.debug(
          {
            context: this.constructor.name,
            route,
            pendingToSameDest: pendingToSameDest.toString(),
          },
          'Route overlaps with pending rebalance',
        );
      }

      return true;
    });
  }
}
