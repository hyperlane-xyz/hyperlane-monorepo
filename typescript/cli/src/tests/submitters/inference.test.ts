import { tmpdir } from 'os';

import { expect } from 'chai';
import sinon from 'sinon';
import { constants as ethersConstants } from 'ethers';

import {
  ISafe__factory,
  InterchainAccountRouter__factory,
  Ownable__factory,
  TimelockController__factory,
} from '@hyperlane-xyz/core';

import { TxSubmitterType } from '@hyperlane-xyz/sdk';
import { ProtocolType, eqAddress } from '@hyperlane-xyz/utils';

import { resolveSubmitterBatchesForTransactions } from '../../submitters/inference.js';
import { writeYamlOrJson } from '../../utils/files.js';

describe('resolveSubmitterBatchesForTransactions', () => {
  const CHAIN = 'anvil2';
  const SIGNER = '0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266';
  const TX = {
    to: '0x1111111111111111111111111111111111111111',
    data: '0x',
    chainId: 31338,
  };

  it('returns no batches when no transactions are provided', async () => {
    const batches = await resolveSubmitterBatchesForTransactions({
      chain: CHAIN,
      transactions: [],
      context: {
        multiProvider: {
          getProtocol: () => ProtocolType.Ethereum,
        },
      } as any,
    });

    expect(batches).to.deep.equal([]);
  });

  it('uses explicit strategy when provided', async () => {
    const strategyPath = `${tmpdir()}/submitter-inference-${Date.now()}.yaml`;
    writeYamlOrJson(strategyPath, {
      [CHAIN]: {
        submitter: {
          type: TxSubmitterType.GNOSIS_TX_BUILDER,
          chain: CHAIN,
          safeAddress: '0x2222222222222222222222222222222222222222',
          version: '1.0',
        },
      },
    });

    const batches = await resolveSubmitterBatchesForTransactions({
      chain: CHAIN,
      transactions: [TX as any, TX as any],
      context: {
        multiProvider: {
          getProtocol: () => ProtocolType.Ethereum,
        },
      } as any,
      strategyUrl: strategyPath,
    });

    expect(batches).to.have.length(1);
    expect(batches[0].config.submitter.type).to.equal(
      TxSubmitterType.GNOSIS_TX_BUILDER,
    );
    expect(batches[0].transactions).to.have.length(2);
  });

  it('uses explicit default submitter when protocol lookup fails', async () => {
    const strategyPath = `${tmpdir()}/submitter-inference-protocol-failure-explicit-${Date.now()}.yaml`;
    const overrideTarget = '0x9999999999999999999999999999999999999999';
    writeYamlOrJson(strategyPath, {
      [CHAIN]: {
        submitter: {
          type: TxSubmitterType.GNOSIS_TX_BUILDER,
          chain: CHAIN,
          safeAddress: '0x2222222222222222222222222222222222222222',
          version: '1.0',
        },
        submitterOverrides: {
          [overrideTarget]: {
            type: TxSubmitterType.TIMELOCK_CONTROLLER,
            chain: CHAIN,
            timelockAddress: '0x3333333333333333333333333333333333333333',
            proposerSubmitter: {
              type: TxSubmitterType.JSON_RPC,
              chain: CHAIN,
            },
          },
        },
      },
    });

    const batches = await resolveSubmitterBatchesForTransactions({
      chain: CHAIN,
      transactions: [TX as any, { ...TX, to: overrideTarget } as any],
      context: {
        multiProvider: {
          getProtocol: () => {
            throw new Error('missing chain metadata');
          },
        },
      } as any,
      strategyUrl: strategyPath,
    });

    expect(batches).to.have.length(1);
    expect(batches[0].config.submitter.type).to.equal(
      TxSubmitterType.GNOSIS_TX_BUILDER,
    );
    expect(batches[0].transactions).to.have.length(2);
  });

  it('falls back to jsonRpc when protocol lookup fails without explicit strategy', async () => {
    const batches = await resolveSubmitterBatchesForTransactions({
      chain: CHAIN,
      transactions: [TX as any],
      context: {
        multiProvider: {
          getProtocol: () => {
            throw new Error('missing chain metadata');
          },
        },
      } as any,
    });

    expect(batches).to.have.length(1);
    expect(batches[0].config.submitter.type).to.equal(TxSubmitterType.JSON_RPC);
  });

  it('reuses protocol lookup for inferred transaction batches', async () => {
    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => SIGNER,
    } as any);

    let protocolCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => {
          protocolCalls += 1;
          return ProtocolType.Ethereum;
        },
        getSignerAddress: async () => SIGNER,
        getProvider: () => ({}),
      },
      registry: {
        getAddresses: async () => ({}),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any, TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(protocolCalls).to.equal(1);
    } finally {
      ownableStub.restore();
    }
  });

  it('handles bigint-like explicit submitter fields in fingerprinting', async () => {
    const strategyPath = `${tmpdir()}/submitter-inference-timelock-delay-${Date.now()}.yaml`;
    writeYamlOrJson(strategyPath, {
      [CHAIN]: {
        submitter: {
          type: TxSubmitterType.TIMELOCK_CONTROLLER,
          chain: CHAIN,
          timelockAddress: '0x3333333333333333333333333333333333333333',
          delay: 0,
          proposerSubmitter: {
            type: TxSubmitterType.JSON_RPC,
            chain: CHAIN,
          },
        },
      },
    });

    const batches = await resolveSubmitterBatchesForTransactions({
      chain: CHAIN,
      transactions: [TX as any],
      context: {
        multiProvider: {
          getProtocol: () => ProtocolType.Ethereum,
        },
      } as any,
      strategyUrl: strategyPath,
    });

    expect(batches).to.have.length(1);
    expect(batches[0].config.submitter.type).to.equal(
      TxSubmitterType.TIMELOCK_CONTROLLER,
    );
  });

  it('falls back to inference when strategy file has no config for chain', async () => {
    const strategyPath = `${tmpdir()}/submitter-inference-missing-chain-${Date.now()}.yaml`;
    writeYamlOrJson(strategyPath, {
      anvil3: {
        submitter: {
          type: TxSubmitterType.GNOSIS_TX_BUILDER,
          chain: 'anvil3',
          safeAddress: '0x2222222222222222222222222222222222222222',
          version: '1.0',
        },
      },
    });

    const safeOwner = '0x2222222222222222222222222222222222222222';
    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => safeOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== safeOwner.toLowerCase()) {
          throw new Error('not safe');
        }

        return {
          getThreshold: async () => 1,
          nonce: async () => 0,
        } as any;
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => ({}),
      },
      registry: {
        getAddresses: async () => ({}),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
        strategyUrl: strategyPath,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.GNOSIS_TX_BUILDER,
      );
    } finally {
      ownableStub.restore();
      safeStub.restore();
    }
  });

  it('routes transactions using explicit per-target submitter overrides', async () => {
    const strategyPath = `${tmpdir()}/submitter-inference-overrides-${Date.now()}.yaml`;
    const overrideTarget = '0x9999999999999999999999999999999999999999';
    writeYamlOrJson(strategyPath, {
      [CHAIN]: {
        submitter: {
          type: TxSubmitterType.JSON_RPC,
          chain: CHAIN,
        },
        submitterOverrides: {
          [overrideTarget]: {
            type: TxSubmitterType.GNOSIS_TX_BUILDER,
            chain: CHAIN,
            safeAddress: '0x8888888888888888888888888888888888888888',
            version: '1.0',
          },
        },
      },
    });

    const txDefault = TX;
    const txOverride = { ...TX, to: overrideTarget };

    const batches = await resolveSubmitterBatchesForTransactions({
      chain: CHAIN,
      transactions: [txDefault as any, txOverride as any],
      context: {
        multiProvider: {
          getProtocol: () => ProtocolType.Ethereum,
        },
      } as any,
      strategyUrl: strategyPath,
    });

    expect(batches).to.have.length(2);
    expect(batches[0].config.submitter.type).to.equal(TxSubmitterType.JSON_RPC);
    expect(batches[1].config.submitter.type).to.equal(
      TxSubmitterType.GNOSIS_TX_BUILDER,
    );
  });

  it('matches explicit target-only override with mixed-case target address', async () => {
    const strategyPath = `${tmpdir()}/submitter-inference-overrides-target-case-${Date.now()}.yaml`;
    const overrideTargetMixedCase =
      '0xAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAa';
    writeYamlOrJson(strategyPath, {
      [CHAIN]: {
        submitter: {
          type: TxSubmitterType.JSON_RPC,
          chain: CHAIN,
        },
        submitterOverrides: {
          [overrideTargetMixedCase]: {
            type: TxSubmitterType.GNOSIS_TX_BUILDER,
            chain: CHAIN,
            safeAddress: '0x8888888888888888888888888888888888888888',
            version: '1.0',
          },
        },
      },
    });

    const txOverride = {
      ...TX,
      to: '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa',
    };

    const batches = await resolveSubmitterBatchesForTransactions({
      chain: CHAIN,
      transactions: [txOverride as any],
      context: {
        multiProvider: {
          getProtocol: () => ProtocolType.Ethereum,
        },
      } as any,
      strategyUrl: strategyPath,
    });

    expect(batches).to.have.length(1);
    expect(batches[0].config.submitter.type).to.equal(
      TxSubmitterType.GNOSIS_TX_BUILDER,
    );
  });

  it('keeps first target-only override when normalized EVM targets collide', async () => {
    const strategyPath = `${tmpdir()}/submitter-inference-overrides-target-collision-${Date.now()}.yaml`;
    const normalizedTarget = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa';
    const mixedCaseTarget = '0xAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAa';

    writeYamlOrJson(strategyPath, {
      [CHAIN]: {
        submitter: {
          type: TxSubmitterType.JSON_RPC,
          chain: CHAIN,
        },
        submitterOverrides: {
          [mixedCaseTarget]: {
            type: TxSubmitterType.GNOSIS_TX_BUILDER,
            chain: CHAIN,
            safeAddress: '0x1111111111111111111111111111111111111111',
            version: '1.0',
          },
          [normalizedTarget]: {
            type: TxSubmitterType.TIMELOCK_CONTROLLER,
            chain: CHAIN,
            timelockAddress: '0x2222222222222222222222222222222222222222',
            proposerSubmitter: {
              type: TxSubmitterType.JSON_RPC,
              chain: CHAIN,
            },
          },
        },
      },
    });

    const tx = { ...TX, to: normalizedTarget };
    const batches = await resolveSubmitterBatchesForTransactions({
      chain: CHAIN,
      transactions: [tx as any],
      context: {
        multiProvider: {
          getProtocol: () => ProtocolType.Ethereum,
        },
      } as any,
      strategyUrl: strategyPath,
    });

    expect(batches).to.have.length(1);
    expect(batches[0].config.submitter.type).to.equal(
      TxSubmitterType.GNOSIS_TX_BUILDER,
    );
  });

  it('matches explicit EVM override when transaction target has whitespace', async () => {
    const strategyPath = `${tmpdir()}/submitter-inference-overrides-target-whitespace-${Date.now()}.yaml`;
    const overrideTarget = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa';
    writeYamlOrJson(strategyPath, {
      [CHAIN]: {
        submitter: {
          type: TxSubmitterType.JSON_RPC,
          chain: CHAIN,
        },
        submitterOverrides: {
          [overrideTarget]: {
            type: TxSubmitterType.GNOSIS_TX_BUILDER,
            chain: CHAIN,
            safeAddress: '0x8888888888888888888888888888888888888888',
            version: '1.0',
          },
        },
      },
    });

    const txOverride = { ...TX, to: `  ${overrideTarget}  ` };

    const batches = await resolveSubmitterBatchesForTransactions({
      chain: CHAIN,
      transactions: [txOverride as any],
      context: {
        multiProvider: {
          getProtocol: () => ProtocolType.Ethereum,
        },
      } as any,
      strategyUrl: strategyPath,
    });

    expect(batches).to.have.length(1);
    expect(batches[0].config.submitter.type).to.equal(
      TxSubmitterType.GNOSIS_TX_BUILDER,
    );
  });

  it('matches explicit EVM override when transaction target has uppercase 0X prefix', async () => {
    const strategyPath = `${tmpdir()}/submitter-inference-overrides-target-upper-prefix-${Date.now()}.yaml`;
    const overrideTarget = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa';
    writeYamlOrJson(strategyPath, {
      [CHAIN]: {
        submitter: {
          type: TxSubmitterType.JSON_RPC,
          chain: CHAIN,
        },
        submitterOverrides: {
          [overrideTarget]: {
            type: TxSubmitterType.GNOSIS_TX_BUILDER,
            chain: CHAIN,
            safeAddress: '0x8888888888888888888888888888888888888888',
            version: '1.0',
          },
        },
      },
    });

    const txOverride = {
      ...TX,
      to: '  0Xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa  ',
    };

    const batches = await resolveSubmitterBatchesForTransactions({
      chain: CHAIN,
      transactions: [txOverride as any],
      context: {
        multiProvider: {
          getProtocol: () => ProtocolType.Ethereum,
        },
      } as any,
      strategyUrl: strategyPath,
    });

    expect(batches).to.have.length(1);
    expect(batches[0].config.submitter.type).to.equal(
      TxSubmitterType.GNOSIS_TX_BUILDER,
    );
  });

  it('matches explicit EVM override when override key has uppercase 0X prefix', async () => {
    const strategyPath = `${tmpdir()}/submitter-inference-overrides-key-upper-prefix-${Date.now()}.yaml`;
    const overrideTargetLower = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa';
    writeYamlOrJson(strategyPath, {
      [CHAIN]: {
        submitter: {
          type: TxSubmitterType.JSON_RPC,
          chain: CHAIN,
        },
        submitterOverrides: {
          '0Xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa': {
            type: TxSubmitterType.GNOSIS_TX_BUILDER,
            chain: CHAIN,
            safeAddress: '0x8888888888888888888888888888888888888888',
            version: '1.0',
          },
        },
      },
    });

    const txOverride = { ...TX, to: overrideTargetLower };

    const batches = await resolveSubmitterBatchesForTransactions({
      chain: CHAIN,
      transactions: [txOverride as any],
      context: {
        multiProvider: {
          getProtocol: () => ProtocolType.Ethereum,
        },
      } as any,
      strategyUrl: strategyPath,
    });

    expect(batches).to.have.length(1);
    expect(batches[0].config.submitter.type).to.equal(
      TxSubmitterType.GNOSIS_TX_BUILDER,
    );
  });

  it('preserves transaction order by splitting non-contiguous explicit submitter matches', async () => {
    const strategyPath = `${tmpdir()}/submitter-inference-overrides-order-${Date.now()}.yaml`;
    const overrideTarget = '0x9999999999999999999999999999999999999999';
    writeYamlOrJson(strategyPath, {
      [CHAIN]: {
        submitter: {
          type: TxSubmitterType.JSON_RPC,
          chain: CHAIN,
        },
        submitterOverrides: {
          [overrideTarget]: {
            type: TxSubmitterType.GNOSIS_TX_BUILDER,
            chain: CHAIN,
            safeAddress: '0x8888888888888888888888888888888888888888',
            version: '1.0',
          },
        },
      },
    });

    const txDefaultFirst = {
      ...TX,
      to: '0x1111111111111111111111111111111111111111',
    };
    const txOverride = { ...TX, to: overrideTarget };
    const txDefaultLast = {
      ...TX,
      to: '0x2222222222222222222222222222222222222222',
    };

    const batches = await resolveSubmitterBatchesForTransactions({
      chain: CHAIN,
      transactions: [
        txDefaultFirst as any,
        txOverride as any,
        txDefaultLast as any,
      ],
      context: {
        multiProvider: {
          getProtocol: () => ProtocolType.Ethereum,
        },
      } as any,
      strategyUrl: strategyPath,
    });

    expect(batches).to.have.length(3);
    expect(batches[0].config.submitter.type).to.equal(TxSubmitterType.JSON_RPC);
    expect(batches[1].config.submitter.type).to.equal(
      TxSubmitterType.GNOSIS_TX_BUILDER,
    );
    expect(batches[2].config.submitter.type).to.equal(TxSubmitterType.JSON_RPC);
    expect(batches[0].transactions).to.deep.equal([txDefaultFirst as any]);
    expect(batches[1].transactions).to.deep.equal([txOverride as any]);
    expect(batches[2].transactions).to.deep.equal([txDefaultLast as any]);
  });

  it('coalesces adjacent explicit submitter matches into single batches', async () => {
    const strategyPath = `${tmpdir()}/submitter-inference-overrides-adjacent-${Date.now()}.yaml`;
    const overrideTarget = '0x9999999999999999999999999999999999999999';
    writeYamlOrJson(strategyPath, {
      [CHAIN]: {
        submitter: {
          type: TxSubmitterType.JSON_RPC,
          chain: CHAIN,
        },
        submitterOverrides: {
          [overrideTarget]: {
            type: TxSubmitterType.GNOSIS_TX_BUILDER,
            chain: CHAIN,
            safeAddress: '0x8888888888888888888888888888888888888888',
            version: '1.0',
          },
        },
      },
    });

    const txDefaultFirst = {
      ...TX,
      to: '0x1111111111111111111111111111111111111111',
    };
    const txDefaultSecond = {
      ...TX,
      to: '0x2222222222222222222222222222222222222222',
    };
    const txOverrideFirst = { ...TX, to: overrideTarget };
    const txOverrideSecond = {
      ...TX,
      to: overrideTarget,
      data: '0xdeadbeef',
    };
    const txDefaultLast = {
      ...TX,
      to: '0x3333333333333333333333333333333333333333',
    };

    const batches = await resolveSubmitterBatchesForTransactions({
      chain: CHAIN,
      transactions: [
        txDefaultFirst as any,
        txDefaultSecond as any,
        txOverrideFirst as any,
        txOverrideSecond as any,
        txDefaultLast as any,
      ],
      context: {
        multiProvider: {
          getProtocol: () => ProtocolType.Ethereum,
        },
      } as any,
      strategyUrl: strategyPath,
    });

    expect(batches).to.have.length(3);
    expect(batches[0].config.submitter.type).to.equal(TxSubmitterType.JSON_RPC);
    expect(batches[1].config.submitter.type).to.equal(
      TxSubmitterType.GNOSIS_TX_BUILDER,
    );
    expect(batches[2].config.submitter.type).to.equal(TxSubmitterType.JSON_RPC);
    expect(batches[0].transactions).to.deep.equal([
      txDefaultFirst as any,
      txDefaultSecond as any,
    ]);
    expect(batches[1].transactions).to.deep.equal([
      txOverrideFirst as any,
      txOverrideSecond as any,
    ]);
    expect(batches[2].transactions).to.deep.equal([txDefaultLast as any]);
  });

  it('prioritizes selector-specific override over target override', async () => {
    const strategyPath = `${tmpdir()}/submitter-inference-selector-overrides-${Date.now()}.yaml`;
    const overrideTarget = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa';
    writeYamlOrJson(strategyPath, {
      [CHAIN]: {
        submitter: {
          type: TxSubmitterType.JSON_RPC,
          chain: CHAIN,
        },
        submitterOverrides: {
          [overrideTarget]: {
            type: TxSubmitterType.GNOSIS_TX_BUILDER,
            chain: CHAIN,
            safeAddress: '0x7777777777777777777777777777777777777777',
            version: '1.0',
          },
          [`${overrideTarget}@0xdeadbeef`]: {
            type: TxSubmitterType.TIMELOCK_CONTROLLER,
            chain: CHAIN,
            timelockAddress: '0x6666666666666666666666666666666666666666',
            proposerSubmitter: {
              type: TxSubmitterType.JSON_RPC,
              chain: CHAIN,
            },
          },
        },
      },
    });

    const txWithSelector = {
      ...TX,
      to: overrideTarget,
      data: '0xdeadbeef0000',
    };

    const batches = await resolveSubmitterBatchesForTransactions({
      chain: CHAIN,
      transactions: [txWithSelector as any],
      context: {
        multiProvider: {
          getProtocol: () => ProtocolType.Ethereum,
        },
      } as any,
      strategyUrl: strategyPath,
    });

    expect(batches).to.have.length(1);
    expect(batches[0].config.submitter.type).to.equal(
      TxSubmitterType.TIMELOCK_CONTROLLER,
    );
  });

  it('keeps first selector-specific override when normalized selector keys collide', async () => {
    const strategyPath = `${tmpdir()}/submitter-inference-selector-collision-${Date.now()}.yaml`;
    const target = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa';
    const selector = '0xdeadbeef';

    writeYamlOrJson(strategyPath, {
      [CHAIN]: {
        submitter: {
          type: TxSubmitterType.JSON_RPC,
          chain: CHAIN,
        },
        submitterOverrides: {
          [`0XAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA@0XDEADBEEF`]: {
            type: TxSubmitterType.TIMELOCK_CONTROLLER,
            chain: CHAIN,
            timelockAddress: '0x3333333333333333333333333333333333333333',
            proposerSubmitter: {
              type: TxSubmitterType.JSON_RPC,
              chain: CHAIN,
            },
          },
          [`${target}@${selector}`]: {
            type: TxSubmitterType.GNOSIS_TX_BUILDER,
            chain: CHAIN,
            safeAddress: '0x4444444444444444444444444444444444444444',
            version: '1.0',
          },
        },
      },
    });

    const tx = {
      ...TX,
      to: target,
      data: `${selector}0000`,
    };

    const batches = await resolveSubmitterBatchesForTransactions({
      chain: CHAIN,
      transactions: [tx as any],
      context: {
        multiProvider: {
          getProtocol: () => ProtocolType.Ethereum,
        },
      } as any,
      strategyUrl: strategyPath,
    });

    expect(batches).to.have.length(1);
    expect(batches[0].config.submitter.type).to.equal(
      TxSubmitterType.TIMELOCK_CONTROLLER,
    );
  });

  it('uses target-only override when selector-specific override does not match', async () => {
    const strategyPath = `${tmpdir()}/submitter-inference-selector-miss-${Date.now()}.yaml`;
    const overrideTarget = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa';
    writeYamlOrJson(strategyPath, {
      [CHAIN]: {
        submitter: {
          type: TxSubmitterType.JSON_RPC,
          chain: CHAIN,
        },
        submitterOverrides: {
          [overrideTarget]: {
            type: TxSubmitterType.GNOSIS_TX_BUILDER,
            chain: CHAIN,
            safeAddress: '0x7777777777777777777777777777777777777777',
            version: '1.0',
          },
          [`${overrideTarget}@0xdeadbeef`]: {
            type: TxSubmitterType.TIMELOCK_CONTROLLER,
            chain: CHAIN,
            timelockAddress: '0x6666666666666666666666666666666666666666',
            proposerSubmitter: {
              type: TxSubmitterType.JSON_RPC,
              chain: CHAIN,
            },
          },
        },
      },
    });

    const txWithDifferentSelector = {
      ...TX,
      to: overrideTarget,
      data: '0xfeedface0000',
    };

    const batches = await resolveSubmitterBatchesForTransactions({
      chain: CHAIN,
      transactions: [txWithDifferentSelector as any],
      context: {
        multiProvider: {
          getProtocol: () => ProtocolType.Ethereum,
        },
      } as any,
      strategyUrl: strategyPath,
    });

    expect(batches).to.have.length(1);
    expect(batches[0].config.submitter.type).to.equal(
      TxSubmitterType.GNOSIS_TX_BUILDER,
    );
  });

  it('ignores malformed selector override keys with extra separators', async () => {
    const strategyPath = `${tmpdir()}/submitter-inference-selector-malformed-key-${Date.now()}.yaml`;
    const overrideTarget = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa';
    writeYamlOrJson(strategyPath, {
      [CHAIN]: {
        submitter: {
          type: TxSubmitterType.JSON_RPC,
          chain: CHAIN,
        },
        submitterOverrides: {
          [overrideTarget]: {
            type: TxSubmitterType.GNOSIS_TX_BUILDER,
            chain: CHAIN,
            safeAddress: '0x7777777777777777777777777777777777777777',
            version: '1.0',
          },
          [`${overrideTarget}@0xdeadbeef@extra`]: {
            type: TxSubmitterType.TIMELOCK_CONTROLLER,
            chain: CHAIN,
            timelockAddress: '0x6666666666666666666666666666666666666666',
            proposerSubmitter: {
              type: TxSubmitterType.JSON_RPC,
              chain: CHAIN,
            },
          },
        },
      },
    });

    const txWithSelector = {
      ...TX,
      to: overrideTarget,
      data: '0xdeadbeef0000',
    };

    const batches = await resolveSubmitterBatchesForTransactions({
      chain: CHAIN,
      transactions: [txWithSelector as any],
      context: {
        multiProvider: {
          getProtocol: () => ProtocolType.Ethereum,
        },
      } as any,
      strategyUrl: strategyPath,
    });

    expect(batches).to.have.length(1);
    expect(batches[0].config.submitter.type).to.equal(
      TxSubmitterType.GNOSIS_TX_BUILDER,
    );
  });

  it('matches selector-specific override keys with whitespace padding', async () => {
    const strategyPath = `${tmpdir()}/submitter-inference-selector-whitespace-${Date.now()}.yaml`;
    const overrideTarget = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa';
    writeYamlOrJson(strategyPath, {
      [CHAIN]: {
        submitter: {
          type: TxSubmitterType.JSON_RPC,
          chain: CHAIN,
        },
        submitterOverrides: {
          [`  ${overrideTarget}  @  0xdeadbeef  `]: {
            type: TxSubmitterType.TIMELOCK_CONTROLLER,
            chain: CHAIN,
            timelockAddress: '0x6666666666666666666666666666666666666666',
            proposerSubmitter: {
              type: TxSubmitterType.JSON_RPC,
              chain: CHAIN,
            },
          },
        },
      },
    });

    const txWithSelector = {
      ...TX,
      to: overrideTarget,
      data: '0xdeadbeef0000',
    };

    const batches = await resolveSubmitterBatchesForTransactions({
      chain: CHAIN,
      transactions: [txWithSelector as any],
      context: {
        multiProvider: {
          getProtocol: () => ProtocolType.Ethereum,
        },
      } as any,
      strategyUrl: strategyPath,
    });

    expect(batches).to.have.length(1);
    expect(batches[0].config.submitter.type).to.equal(
      TxSubmitterType.TIMELOCK_CONTROLLER,
    );
  });

  it('matches selector-specific override when tx data selector is uppercase', async () => {
    const strategyPath = `${tmpdir()}/submitter-inference-selector-uppercase-data-${Date.now()}.yaml`;
    const overrideTarget = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa';
    writeYamlOrJson(strategyPath, {
      [CHAIN]: {
        submitter: {
          type: TxSubmitterType.JSON_RPC,
          chain: CHAIN,
        },
        submitterOverrides: {
          [`${overrideTarget}@0xdeadbeef`]: {
            type: TxSubmitterType.TIMELOCK_CONTROLLER,
            chain: CHAIN,
            timelockAddress: '0x6666666666666666666666666666666666666666',
            proposerSubmitter: {
              type: TxSubmitterType.JSON_RPC,
              chain: CHAIN,
            },
          },
        },
      },
    });

    const txWithUppercaseSelector = {
      ...TX,
      to: overrideTarget,
      data: '0xDEADBEEF0000',
    };

    const batches = await resolveSubmitterBatchesForTransactions({
      chain: CHAIN,
      transactions: [txWithUppercaseSelector as any],
      context: {
        multiProvider: {
          getProtocol: () => ProtocolType.Ethereum,
        },
      } as any,
      strategyUrl: strategyPath,
    });

    expect(batches).to.have.length(1);
    expect(batches[0].config.submitter.type).to.equal(
      TxSubmitterType.TIMELOCK_CONTROLLER,
    );
  });

  it('matches selector-specific override when tx data has whitespace padding', async () => {
    const strategyPath = `${tmpdir()}/submitter-inference-selector-data-whitespace-${Date.now()}.yaml`;
    const overrideTarget = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa';
    writeYamlOrJson(strategyPath, {
      [CHAIN]: {
        submitter: {
          type: TxSubmitterType.JSON_RPC,
          chain: CHAIN,
        },
        submitterOverrides: {
          [`${overrideTarget}@0xdeadbeef`]: {
            type: TxSubmitterType.TIMELOCK_CONTROLLER,
            chain: CHAIN,
            timelockAddress: '0x6666666666666666666666666666666666666666',
            proposerSubmitter: {
              type: TxSubmitterType.JSON_RPC,
              chain: CHAIN,
            },
          },
        },
      },
    });

    const txWithWhitespaceSelector = {
      ...TX,
      to: overrideTarget,
      data: '  0xdeadbeef0000  ',
    };

    const batches = await resolveSubmitterBatchesForTransactions({
      chain: CHAIN,
      transactions: [txWithWhitespaceSelector as any],
      context: {
        multiProvider: {
          getProtocol: () => ProtocolType.Ethereum,
        },
      } as any,
      strategyUrl: strategyPath,
    });

    expect(batches).to.have.length(1);
    expect(batches[0].config.submitter.type).to.equal(
      TxSubmitterType.TIMELOCK_CONTROLLER,
    );
  });

  it('matches selector-specific override when tx data has uppercase 0X prefix', async () => {
    const strategyPath = `${tmpdir()}/submitter-inference-selector-uppercase-prefix-${Date.now()}.yaml`;
    const overrideTarget = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa';
    writeYamlOrJson(strategyPath, {
      [CHAIN]: {
        submitter: {
          type: TxSubmitterType.JSON_RPC,
          chain: CHAIN,
        },
        submitterOverrides: {
          [`${overrideTarget}@0xdeadbeef`]: {
            type: TxSubmitterType.TIMELOCK_CONTROLLER,
            chain: CHAIN,
            timelockAddress: '0x6666666666666666666666666666666666666666',
            proposerSubmitter: {
              type: TxSubmitterType.JSON_RPC,
              chain: CHAIN,
            },
          },
        },
      },
    });

    const txWithUppercasePrefix = {
      ...TX,
      to: overrideTarget,
      data: '  0XDEADBEEF0000  ',
    };

    const batches = await resolveSubmitterBatchesForTransactions({
      chain: CHAIN,
      transactions: [txWithUppercasePrefix as any],
      context: {
        multiProvider: {
          getProtocol: () => ProtocolType.Ethereum,
        },
      } as any,
      strategyUrl: strategyPath,
    });

    expect(batches).to.have.length(1);
    expect(batches[0].config.submitter.type).to.equal(
      TxSubmitterType.TIMELOCK_CONTROLLER,
    );
  });

  it('matches selector-specific override when key target has uppercase 0X prefix', async () => {
    const strategyPath = `${tmpdir()}/submitter-inference-selector-key-upper-prefix-${Date.now()}.yaml`;
    const overrideTarget = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa';
    writeYamlOrJson(strategyPath, {
      [CHAIN]: {
        submitter: {
          type: TxSubmitterType.JSON_RPC,
          chain: CHAIN,
        },
        submitterOverrides: {
          '0Xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa@0xdeadbeef': {
            type: TxSubmitterType.TIMELOCK_CONTROLLER,
            chain: CHAIN,
            timelockAddress: '0x6666666666666666666666666666666666666666',
            proposerSubmitter: {
              type: TxSubmitterType.JSON_RPC,
              chain: CHAIN,
            },
          },
        },
      },
    });

    const txWithSelector = {
      ...TX,
      to: overrideTarget,
      data: '0xdeadbeef0000',
    };

    const batches = await resolveSubmitterBatchesForTransactions({
      chain: CHAIN,
      transactions: [txWithSelector as any],
      context: {
        multiProvider: {
          getProtocol: () => ProtocolType.Ethereum,
        },
      } as any,
      strategyUrl: strategyPath,
    });

    expect(batches).to.have.length(1);
    expect(batches[0].config.submitter.type).to.equal(
      TxSubmitterType.TIMELOCK_CONTROLLER,
    );
  });

  it('matches selector-specific override when key selector has uppercase 0X prefix', async () => {
    const strategyPath = `${tmpdir()}/submitter-inference-selector-key-selector-upper-prefix-${Date.now()}.yaml`;
    const overrideTarget = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa';
    writeYamlOrJson(strategyPath, {
      [CHAIN]: {
        submitter: {
          type: TxSubmitterType.JSON_RPC,
          chain: CHAIN,
        },
        submitterOverrides: {
          [`${overrideTarget}@0XDEADBEEF`]: {
            type: TxSubmitterType.TIMELOCK_CONTROLLER,
            chain: CHAIN,
            timelockAddress: '0x6666666666666666666666666666666666666666',
            proposerSubmitter: {
              type: TxSubmitterType.JSON_RPC,
              chain: CHAIN,
            },
          },
        },
      },
    });

    const txWithSelector = {
      ...TX,
      to: overrideTarget,
      data: '0xdeadbeef0000',
    };

    const batches = await resolveSubmitterBatchesForTransactions({
      chain: CHAIN,
      transactions: [txWithSelector as any],
      context: {
        multiProvider: {
          getProtocol: () => ProtocolType.Ethereum,
        },
      } as any,
      strategyUrl: strategyPath,
    });

    expect(batches).to.have.length(1);
    expect(batches[0].config.submitter.type).to.equal(
      TxSubmitterType.TIMELOCK_CONTROLLER,
    );
  });

  it('ignores invalid override keys and falls back to default explicit submitter', async () => {
    const strategyPath = `${tmpdir()}/submitter-inference-invalid-overrides-${Date.now()}.yaml`;
    writeYamlOrJson(strategyPath, {
      [CHAIN]: {
        submitter: {
          type: TxSubmitterType.JSON_RPC,
          chain: CHAIN,
        },
        submitterOverrides: {
          'not-an-address@invalid-selector': {
            type: TxSubmitterType.GNOSIS_TX_BUILDER,
            chain: CHAIN,
            safeAddress: '0x7777777777777777777777777777777777777777',
            version: '1.0',
          },
        },
      },
    });

    const batches = await resolveSubmitterBatchesForTransactions({
      chain: CHAIN,
      transactions: [TX as any],
      context: {
        multiProvider: {
          getProtocol: () => ProtocolType.Ethereum,
        },
      } as any,
      strategyUrl: strategyPath,
    });

    expect(batches).to.have.length(1);
    expect(batches[0].config.submitter.type).to.equal(TxSubmitterType.JSON_RPC);
  });

  it('ignores invalid EVM override target keys and falls back to default explicit submitter', async () => {
    const strategyPath = `${tmpdir()}/submitter-inference-invalid-evm-target-${Date.now()}.yaml`;
    writeYamlOrJson(strategyPath, {
      [CHAIN]: {
        submitter: {
          type: TxSubmitterType.JSON_RPC,
          chain: CHAIN,
        },
        submitterOverrides: {
          notAnAddress: {
            type: TxSubmitterType.GNOSIS_TX_BUILDER,
            chain: CHAIN,
            safeAddress: '0x7777777777777777777777777777777777777777',
            version: '1.0',
          },
        },
      },
    });

    const batches = await resolveSubmitterBatchesForTransactions({
      chain: CHAIN,
      transactions: [TX as any],
      context: {
        multiProvider: {
          getProtocol: () => ProtocolType.Ethereum,
        },
      } as any,
      strategyUrl: strategyPath,
    });

    expect(batches).to.have.length(1);
    expect(batches[0].config.submitter.type).to.equal(TxSubmitterType.JSON_RPC);
  });

  it('ignores empty EVM override keys and falls back to default explicit submitter', async () => {
    const strategyPath = `${tmpdir()}/submitter-inference-empty-evm-target-${Date.now()}.yaml`;
    writeYamlOrJson(strategyPath, {
      [CHAIN]: {
        submitter: {
          type: TxSubmitterType.JSON_RPC,
          chain: CHAIN,
        },
        submitterOverrides: {
          '   ': {
            type: TxSubmitterType.GNOSIS_TX_BUILDER,
            chain: CHAIN,
            safeAddress: '0x7777777777777777777777777777777777777777',
            version: '1.0',
          },
        },
      },
    });

    const batches = await resolveSubmitterBatchesForTransactions({
      chain: CHAIN,
      transactions: [TX as any],
      context: {
        multiProvider: {
          getProtocol: () => ProtocolType.Ethereum,
        },
      } as any,
      strategyUrl: strategyPath,
    });

    expect(batches).to.have.length(1);
    expect(batches[0].config.submitter.type).to.equal(TxSubmitterType.JSON_RPC);
  });

  it('falls back to default explicit submitter for malformed transaction target', async () => {
    const strategyPath = `${tmpdir()}/submitter-inference-malformed-target-${Date.now()}.yaml`;
    writeYamlOrJson(strategyPath, {
      [CHAIN]: {
        submitter: {
          type: TxSubmitterType.GNOSIS_TX_BUILDER,
          chain: CHAIN,
          safeAddress: '0x7777777777777777777777777777777777777777',
          version: '1.0',
        },
        submitterOverrides: {
          '0x1111111111111111111111111111111111111111': {
            type: TxSubmitterType.TIMELOCK_CONTROLLER,
            chain: CHAIN,
            timelockAddress: '0x6666666666666666666666666666666666666666',
            proposerSubmitter: {
              type: TxSubmitterType.JSON_RPC,
              chain: CHAIN,
            },
          },
        },
      },
    });

    const batches = await resolveSubmitterBatchesForTransactions({
      chain: CHAIN,
      transactions: [{ ...TX, to: 'not-an-evm-address' } as any],
      context: {
        multiProvider: {
          getProtocol: () => ProtocolType.Ethereum,
        },
      } as any,
      strategyUrl: strategyPath,
    });

    expect(batches).to.have.length(1);
    expect(batches[0].config.submitter.type).to.equal(
      TxSubmitterType.GNOSIS_TX_BUILDER,
    );
  });

  it('uses explicit submitter when overrides are absent even if tx target is malformed', async () => {
    const strategyPath = `${tmpdir()}/submitter-inference-explicit-no-overrides-${Date.now()}.yaml`;
    writeYamlOrJson(strategyPath, {
      [CHAIN]: {
        submitter: {
          type: TxSubmitterType.GNOSIS_TX_BUILDER,
          chain: CHAIN,
          safeAddress: '0x7777777777777777777777777777777777777777',
          version: '1.0',
        },
      },
    });

    const batches = await resolveSubmitterBatchesForTransactions({
      chain: CHAIN,
      transactions: [{ ...TX, to: 'not-an-evm-address' } as any],
      context: {
        multiProvider: {
          getProtocol: () => ProtocolType.Ethereum,
        },
      } as any,
      strategyUrl: strategyPath,
    });

    expect(batches).to.have.length(1);
    expect(batches[0].config.submitter.type).to.equal(
      TxSubmitterType.GNOSIS_TX_BUILDER,
    );
  });

  it('matches selector-specific override with mixed-case selector and target address', async () => {
    const strategyPath = `${tmpdir()}/submitter-inference-selector-case-${Date.now()}.yaml`;
    const overrideTarget = '0xAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAa';
    writeYamlOrJson(strategyPath, {
      [CHAIN]: {
        submitter: {
          type: TxSubmitterType.JSON_RPC,
          chain: CHAIN,
        },
        submitterOverrides: {
          [`${overrideTarget}@0xDeAdBeEf`]: {
            type: TxSubmitterType.TIMELOCK_CONTROLLER,
            chain: CHAIN,
            timelockAddress: '0x6666666666666666666666666666666666666666',
            proposerSubmitter: {
              type: TxSubmitterType.JSON_RPC,
              chain: CHAIN,
            },
          },
        },
      },
    });

    const txWithSelector = {
      ...TX,
      to: '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa',
      data: '0xdeadbeef0000',
    };

    const batches = await resolveSubmitterBatchesForTransactions({
      chain: CHAIN,
      transactions: [txWithSelector as any],
      context: {
        multiProvider: {
          getProtocol: () => ProtocolType.Ethereum,
        },
      } as any,
      strategyUrl: strategyPath,
    });

    expect(batches).to.have.length(1);
    expect(batches[0].config.submitter.type).to.equal(
      TxSubmitterType.TIMELOCK_CONTROLLER,
    );
  });

  it('falls back to jsonRpc when inference fails', async () => {
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => ({}),
      },
      registry: {
        getAddresses: async () => ({}),
      },
    } as any;

    const batches = await resolveSubmitterBatchesForTransactions({
      chain: CHAIN,
      transactions: [TX as any],
      context,
    });

    expect(batches).to.have.length(1);
    expect(batches[0].config.submitter.type).to.equal(TxSubmitterType.JSON_RPC);
  });

  it('caches provider lookup failures across inferred transactions', async () => {
    let providerCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getProvider: () => {
          providerCalls += 1;
          throw new Error('provider unavailable');
        },
      },
      registry: {
        getAddresses: async () => ({}),
      },
    } as any;

    const batches = await resolveSubmitterBatchesForTransactions({
      chain: CHAIN,
      transactions: [TX as any, TX as any],
      context,
    });

    expect(batches).to.have.length(1);
    expect(batches[0].config.submitter.type).to.equal(TxSubmitterType.JSON_RPC);
    expect(providerCalls).to.equal(1);
  });

  it('reuses provider lookup across owner, safe, and timelock probes', async () => {
    const unknownOwner = '0x5555555555555555555555555555555555555555';
    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => unknownOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    let providerCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => {
          providerCalls += 1;
          return {};
        },
      },
      registry: {
        getAddresses: async () => ({}),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any, TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(ownableStub.callCount).to.equal(1);
      expect(safeStub.callCount).to.equal(1);
      expect(timelockStub.callCount).to.equal(1);
      expect(providerCalls).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
    }
  });

  it('falls back to jsonRpc when inference throws on malformed transaction target', async () => {
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => ({}),
      },
      registry: {
        getAddresses: async () => ({}),
      },
    } as any;

    const batches = await resolveSubmitterBatchesForTransactions({
      chain: CHAIN,
      transactions: [{ ...TX, to: 'not-an-evm-address' } as any],
      context,
    });

    expect(batches).to.have.length(1);
    expect(batches[0].config.submitter.type).to.equal(TxSubmitterType.JSON_RPC);
  });

  it('falls back to jsonRpc when destination signer lookup fails during owner inference', async () => {
    const safeOwner = '0x4444444444444444444444444444444444444444';
    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => safeOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('safe probe should not run'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('timelock probe should not run'));

    let signerAddressCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => {
          signerAddressCalls += 1;
          throw new Error('missing signer');
        },
        getProvider: () => ({}),
      },
      registry: {
        getAddresses: async () => ({}),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any, TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(ownableStub.callCount).to.equal(1);
      expect(safeStub.callCount).to.equal(0);
      expect(timelockStub.callCount).to.equal(0);
      expect(signerAddressCalls).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
    }
  });

  it('falls back to jsonRpc when destination signer is zero address during owner inference', async () => {
    const safeOwner = '0x4444444444444444444444444444444444444444';
    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => safeOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('safe probe should not run'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('timelock probe should not run'));

    let signerAddressCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => {
          signerAddressCalls += 1;
          return ethersConstants.AddressZero;
        },
        getProvider: () => ({}),
      },
      registry: {
        getAddresses: async () => ({}),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any, TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(ownableStub.callCount).to.equal(1);
      expect(safeStub.callCount).to.equal(0);
      expect(timelockStub.callCount).to.equal(0);
      expect(signerAddressCalls).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
    }
  });

  it('falls back to jsonRpc when destination signer is malformed during owner inference', async () => {
    const safeOwner = '0x4444444444444444444444444444444444444444';
    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => safeOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('safe probe should not run'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('timelock probe should not run'));

    let signerAddressCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => {
          signerAddressCalls += 1;
          return 'not-an-evm-address';
        },
        getProvider: () => ({}),
      },
      registry: {
        getAddresses: async () => ({}),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any, TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(ownableStub.callCount).to.equal(1);
      expect(safeStub.callCount).to.equal(0);
      expect(timelockStub.callCount).to.equal(0);
      expect(signerAddressCalls).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
    }
  });

  it('uses transaction from fallback when transaction target is malformed', async () => {
    const fromSafe = '0x4444444444444444444444444444444444444444';
    const ownableStub = sinon.stub(Ownable__factory, 'connect');
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== fromSafe.toLowerCase()) {
          throw new Error('not safe');
        }

        return {
          getThreshold: async () => 1,
          nonce: async () => 0,
        } as any;
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => ({}),
      },
      registry: {
        getAddresses: async () => ({}),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          {
            ...TX,
            to: 'not-an-evm-address',
            from: ` ${fromSafe} `,
          } as any,
        ],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.GNOSIS_TX_BUILDER,
      );
      expect(ownableStub.callCount).to.equal(0);
    } finally {
      ownableStub.restore();
      safeStub.restore();
    }
  });

  it('uses transaction from fallback when owner read returns malformed address', async () => {
    const fromSafe = '0x4444444444444444444444444444444444444444';
    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => 'not-an-evm-address',
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== fromSafe.toLowerCase()) {
          throw new Error('not safe');
        }

        return {
          getThreshold: async () => 1,
          nonce: async () => 0,
        } as any;
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => ({}),
      },
      registry: {
        getAddresses: async () => ({}),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          {
            ...TX,
            to: '0x1111111111111111111111111111111111111111',
            from: fromSafe,
          } as any,
        ],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.GNOSIS_TX_BUILDER,
      );
      expect(ownableStub.callCount).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
    }
  });

  it('uses transaction from fallback when owner read returns zero address', async () => {
    const fromSafe = '0x4444444444444444444444444444444444444444';
    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => ethersConstants.AddressZero,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== fromSafe.toLowerCase()) {
          throw new Error('not safe');
        }

        return {
          getThreshold: async () => 1,
          nonce: async () => 0,
        } as any;
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => ({}),
      },
      registry: {
        getAddresses: async () => ({}),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          {
            ...TX,
            to: '0x1111111111111111111111111111111111111111',
            from: fromSafe,
          } as any,
        ],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.GNOSIS_TX_BUILDER,
      );
      expect(ownableStub.callCount).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
    }
  });

  it('caches failed owner reads while still using from-based fallback inference', async () => {
    const fromSafe = '0x4444444444444444444444444444444444444444';
    let ownerReads = 0;
    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => {
        ownerReads += 1;
        throw new Error('owner read failed');
      },
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== fromSafe.toLowerCase()) {
          throw new Error('not safe');
        }

        return {
          getThreshold: async () => 1,
          nonce: async () => 0,
        } as any;
      });
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => ({}),
      },
      registry: {
        getAddresses: async () => ({}),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          {
            ...TX,
            from: fromSafe,
          } as any,
          {
            ...TX,
            from: fromSafe,
            data: '0xdeadbeef',
          } as any,
        ],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.GNOSIS_TX_BUILDER,
      );
      expect(ownerReads).to.equal(1);
      expect(safeStub.callCount).to.equal(1);
      expect(timelockStub.callCount).to.equal(0);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
    }
  });

  it('caches zero owner reads while still using from-based fallback inference', async () => {
    const fromSafe = '0x4444444444444444444444444444444444444444';
    let ownerReads = 0;
    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => {
        ownerReads += 1;
        return ethersConstants.AddressZero;
      },
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== fromSafe.toLowerCase()) {
          throw new Error('not safe');
        }

        return {
          getThreshold: async () => 1,
          nonce: async () => 0,
        } as any;
      });
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => ({}),
      },
      registry: {
        getAddresses: async () => ({}),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          {
            ...TX,
            from: fromSafe,
          } as any,
          {
            ...TX,
            from: fromSafe,
            data: '0xdeadbeef',
          } as any,
        ],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.GNOSIS_TX_BUILDER,
      );
      expect(ownerReads).to.equal(1);
      expect(safeStub.callCount).to.equal(1);
      expect(timelockStub.callCount).to.equal(0);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
    }
  });

  it('normalizes owner address from ownable read before submitter inference', async () => {
    const safeOwner = '0x4444444444444444444444444444444444444444';
    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => '  0X4444444444444444444444444444444444444444  ',
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== safeOwner.toLowerCase()) {
          throw new Error('not safe');
        }

        return {
          getThreshold: async () => 1,
          nonce: async () => 0,
        } as any;
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => ({}),
      },
      registry: {
        getAddresses: async () => ({}),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.GNOSIS_TX_BUILDER,
      );
      expect(ownableStub.callCount).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
    }
  });

  it('treats whitespace-padded uppercase signer owner as jsonRpc inferable', async () => {
    let ownerReads = 0;
    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => {
        ownerReads += 1;
        return `  0X${SIGNER.slice(2).toUpperCase()}  `;
      },
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => `  0X${SIGNER.slice(2).toUpperCase()}  `,
        getProvider: () => ({}),
      },
      registry: {
        getAddresses: async () => ({}),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any, { ...TX, data: '0xdeadbeef' } as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].transactions).to.have.length(2);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(ownerReads).to.equal(1);
      expect(safeStub.callCount).to.equal(0);
      expect(timelockStub.callCount).to.equal(0);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
    }
  });

  it('caches owner reads for repeated transaction targets', async () => {
    const safeOwner = '0x4444444444444444444444444444444444444444';
    let ownerReads = 0;
    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => {
        ownerReads += 1;
        return safeOwner;
      },
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== safeOwner.toLowerCase()) {
          throw new Error('not safe');
        }

        return {
          getThreshold: async () => 1,
          nonce: async () => 0,
        } as any;
      });
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => ({}),
      },
      registry: {
        getAddresses: async () => ({}),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any, { ...TX, data: '0xdeadbeef' } as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.GNOSIS_TX_BUILDER,
      );
      expect(ownerReads).to.equal(1);
      expect(safeStub.callCount).to.equal(1);
      expect(timelockStub.callCount).to.equal(0);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
    }
  });

  it('caches failed owner reads for repeated transaction targets', async () => {
    let ownerReads = 0;
    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => {
        ownerReads += 1;
        throw new Error('owner read failed');
      },
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => ({}),
      },
      registry: {
        getAddresses: async () => ({}),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any, { ...TX, data: '0xdeadbeef' } as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(ownerReads).to.equal(1);
      expect(safeStub.callCount).to.equal(1);
      expect(timelockStub.callCount).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
    }
  });

  it('falls back to jsonRpc when owner is unknown submitter type', async () => {
    const unknownOwner = '0x5555555555555555555555555555555555555555';
    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => unknownOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => {
          throw new Error('not timelock');
        },
      } as any);

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => ({}),
      },
      registry: {
        getAddresses: async () => ({}),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
    }
  });

  it('falls back to jsonRpc when ownable read fails and transaction from is malformed', async () => {
    const ownableStub = sinon
      .stub(Ownable__factory, 'connect')
      .throws(new Error('not ownable'));

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => ({}),
      },
      registry: {
        getAddresses: async () => ({}),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [{ ...TX, from: 'not-an-evm-address' } as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
    } finally {
      ownableStub.restore();
    }
  });

  it('falls back to jsonRpc when ownable read fails and transaction from is zero address', async () => {
    const ownableStub = sinon
      .stub(Ownable__factory, 'connect')
      .throws(new Error('not ownable'));
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('safe probe should not run'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('timelock probe should not run'));

    let signerAddressCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => {
          signerAddressCalls += 1;
          return SIGNER;
        },
        getProvider: () => ({}),
      },
      registry: {
        getAddresses: async () => ({}),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [{ ...TX, from: ethersConstants.AddressZero } as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(safeStub.callCount).to.equal(0);
      expect(timelockStub.callCount).to.equal(0);
      expect(signerAddressCalls).to.equal(0);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
    }
  });

  it('ignores explicit strategy on extended chains', async () => {
    const strategyPath = `${tmpdir()}/submitter-inference-extended-${Date.now()}.yaml`;
    writeYamlOrJson(strategyPath, {
      [CHAIN]: {
        submitter: {
          type: TxSubmitterType.GNOSIS_TX_BUILDER,
          chain: CHAIN,
          safeAddress: '0x3333333333333333333333333333333333333333',
          version: '1.0',
        },
      },
    });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => ({}),
      },
      registry: {
        getAddresses: async () => ({}),
      },
    } as any;

    const batches = await resolveSubmitterBatchesForTransactions({
      chain: CHAIN,
      transactions: [TX as any],
      context,
      strategyUrl: strategyPath,
      isExtendedChain: true,
    });

    expect(batches).to.have.length(1);
    expect(batches[0].config.submitter.type).to.equal(TxSubmitterType.JSON_RPC);
  });

  it('ignores explicit submitterOverrides on extended chains', async () => {
    const strategyPath = `${tmpdir()}/submitter-inference-extended-overrides-${Date.now()}.yaml`;
    writeYamlOrJson(strategyPath, {
      [CHAIN]: {
        submitter: {
          type: TxSubmitterType.JSON_RPC,
          chain: CHAIN,
        },
        submitterOverrides: {
          '0x1111111111111111111111111111111111111111': {
            type: TxSubmitterType.GNOSIS_TX_BUILDER,
            chain: CHAIN,
            safeAddress: '0x3333333333333333333333333333333333333333',
            version: '1.0',
          },
        },
      },
    });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => ({}),
      },
      registry: {
        getAddresses: async () => ({}),
      },
    } as any;

    const batches = await resolveSubmitterBatchesForTransactions({
      chain: CHAIN,
      transactions: [TX as any],
      context,
      strategyUrl: strategyPath,
      isExtendedChain: true,
    });

    expect(batches).to.have.length(1);
    expect(batches[0].config.submitter.type).to.equal(TxSubmitterType.JSON_RPC);
  });

  it('uses default jsonRpc for non-ethereum chains', async () => {
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.CosmosNative,
      },
    } as any;

    const batches = await resolveSubmitterBatchesForTransactions({
      chain: CHAIN,
      transactions: [TX as any],
      context,
    });

    expect(batches).to.have.length(1);
    expect(batches[0].config.submitter.type).to.equal(TxSubmitterType.JSON_RPC);
  });

  it('uses non-ethereum default when strategy file has no config for chain', async () => {
    const strategyPath = `${tmpdir()}/submitter-inference-non-evm-missing-chain-${Date.now()}.yaml`;
    writeYamlOrJson(strategyPath, {
      anvil3: {
        submitter: {
          type: TxSubmitterType.GNOSIS_TX_BUILDER,
          chain: 'anvil3',
          safeAddress: '0x2222222222222222222222222222222222222222',
          version: '1.0',
        },
      },
    });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.CosmosNative,
      },
    } as any;

    const batches = await resolveSubmitterBatchesForTransactions({
      chain: CHAIN,
      transactions: [TX as any],
      context,
      strategyUrl: strategyPath,
    });

    expect(batches).to.have.length(1);
    expect(batches[0].config.submitter.type).to.equal(TxSubmitterType.JSON_RPC);
  });

  it('routes non-ethereum explicit overrides by exact target key', async () => {
    const strategyPath = `${tmpdir()}/submitter-inference-cosmos-overrides-${Date.now()}.yaml`;
    const overrideTarget = 'cosmos1overrideaddress000000000000000000000000';
    writeYamlOrJson(strategyPath, {
      [CHAIN]: {
        submitter: {
          type: TxSubmitterType.JSON_RPC,
          chain: CHAIN,
        },
        submitterOverrides: {
          [overrideTarget]: {
            type: TxSubmitterType.GNOSIS_TX_BUILDER,
            chain: CHAIN,
            safeAddress: '0x8888888888888888888888888888888888888888',
            version: '1.0',
          },
        },
      },
    });

    const txDefault = {
      ...TX,
      to: 'cosmos1defaultaddress0000000000000000000000000',
    };
    const txOverride = {
      ...TX,
      to: overrideTarget,
    };

    const batches = await resolveSubmitterBatchesForTransactions({
      chain: CHAIN,
      transactions: [txDefault as any, txOverride as any],
      context: {
        multiProvider: {
          getProtocol: () => ProtocolType.CosmosNative,
        },
      } as any,
      strategyUrl: strategyPath,
    });

    expect(batches).to.have.length(2);
    expect(batches[0].config.submitter.type).to.equal(TxSubmitterType.JSON_RPC);
    expect(batches[1].config.submitter.type).to.equal(
      TxSubmitterType.GNOSIS_TX_BUILDER,
    );
  });

  it('matches non-ethereum explicit override keys with whitespace padding', async () => {
    const strategyPath = `${tmpdir()}/submitter-inference-cosmos-overrides-whitespace-${Date.now()}.yaml`;
    const overrideTarget = 'cosmos1overrideaddress000000000000000000000000';
    writeYamlOrJson(strategyPath, {
      [CHAIN]: {
        submitter: {
          type: TxSubmitterType.JSON_RPC,
          chain: CHAIN,
        },
        submitterOverrides: {
          [`  ${overrideTarget}  `]: {
            type: TxSubmitterType.GNOSIS_TX_BUILDER,
            chain: CHAIN,
            safeAddress: '0x8888888888888888888888888888888888888888',
            version: '1.0',
          },
        },
      },
    });

    const txOverride = {
      ...TX,
      to: overrideTarget,
    };

    const batches = await resolveSubmitterBatchesForTransactions({
      chain: CHAIN,
      transactions: [txOverride as any],
      context: {
        multiProvider: {
          getProtocol: () => ProtocolType.CosmosNative,
        },
      } as any,
      strategyUrl: strategyPath,
    });

    expect(batches).to.have.length(1);
    expect(batches[0].config.submitter.type).to.equal(
      TxSubmitterType.GNOSIS_TX_BUILDER,
    );
  });

  it('matches non-ethereum explicit override when transaction target has whitespace', async () => {
    const strategyPath = `${tmpdir()}/submitter-inference-cosmos-overrides-target-whitespace-${Date.now()}.yaml`;
    const overrideTarget = 'cosmos1overrideaddress000000000000000000000000';
    writeYamlOrJson(strategyPath, {
      [CHAIN]: {
        submitter: {
          type: TxSubmitterType.JSON_RPC,
          chain: CHAIN,
        },
        submitterOverrides: {
          [overrideTarget]: {
            type: TxSubmitterType.GNOSIS_TX_BUILDER,
            chain: CHAIN,
            safeAddress: '0x8888888888888888888888888888888888888888',
            version: '1.0',
          },
        },
      },
    });

    const txOverride = {
      ...TX,
      to: `  ${overrideTarget}  `,
    };

    const batches = await resolveSubmitterBatchesForTransactions({
      chain: CHAIN,
      transactions: [txOverride as any],
      context: {
        multiProvider: {
          getProtocol: () => ProtocolType.CosmosNative,
        },
      } as any,
      strategyUrl: strategyPath,
    });

    expect(batches).to.have.length(1);
    expect(batches[0].config.submitter.type).to.equal(
      TxSubmitterType.GNOSIS_TX_BUILDER,
    );
  });

  it('ignores empty non-ethereum override keys and falls back to default explicit submitter', async () => {
    const strategyPath = `${tmpdir()}/submitter-inference-cosmos-empty-key-${Date.now()}.yaml`;
    writeYamlOrJson(strategyPath, {
      [CHAIN]: {
        submitter: {
          type: TxSubmitterType.JSON_RPC,
          chain: CHAIN,
        },
        submitterOverrides: {
          '   ': {
            type: TxSubmitterType.GNOSIS_TX_BUILDER,
            chain: CHAIN,
            safeAddress: '0x8888888888888888888888888888888888888888',
            version: '1.0',
          },
        },
      },
    });

    const txDefault = {
      ...TX,
      to: 'cosmos1defaultaddress0000000000000000000000000',
    };

    const batches = await resolveSubmitterBatchesForTransactions({
      chain: CHAIN,
      transactions: [txDefault as any],
      context: {
        multiProvider: {
          getProtocol: () => ProtocolType.CosmosNative,
        },
      } as any,
      strategyUrl: strategyPath,
    });

    expect(batches).to.have.length(1);
    expect(batches[0].config.submitter.type).to.equal(TxSubmitterType.JSON_RPC);
  });

  it('keeps first non-ethereum override when trimmed keys collide', async () => {
    const strategyPath = `${tmpdir()}/submitter-inference-cosmos-collision-${Date.now()}.yaml`;
    const overrideTarget = 'cosmos1overrideaddress000000000000000000000000';
    writeYamlOrJson(strategyPath, {
      [CHAIN]: {
        submitter: {
          type: TxSubmitterType.JSON_RPC,
          chain: CHAIN,
        },
        submitterOverrides: {
          [`  ${overrideTarget}  `]: {
            type: TxSubmitterType.GNOSIS_TX_BUILDER,
            chain: CHAIN,
            safeAddress: '0x8888888888888888888888888888888888888888',
            version: '1.0',
          },
          [overrideTarget]: {
            type: TxSubmitterType.TIMELOCK_CONTROLLER,
            chain: CHAIN,
            timelockAddress: '0x9999999999999999999999999999999999999999',
            proposerSubmitter: {
              type: TxSubmitterType.JSON_RPC,
              chain: CHAIN,
            },
          },
        },
      },
    });

    const txOverride = {
      ...TX,
      to: overrideTarget,
    };

    const batches = await resolveSubmitterBatchesForTransactions({
      chain: CHAIN,
      transactions: [txOverride as any],
      context: {
        multiProvider: {
          getProtocol: () => ProtocolType.CosmosNative,
        },
      } as any,
      strategyUrl: strategyPath,
    });

    expect(batches).to.have.length(1);
    expect(batches[0].config.submitter.type).to.equal(
      TxSubmitterType.GNOSIS_TX_BUILDER,
    );
  });

  it('splits non-ethereum explicit overrides when matches are non-contiguous', async () => {
    const strategyPath = `${tmpdir()}/submitter-inference-cosmos-order-${Date.now()}.yaml`;
    const overrideTarget = 'cosmos1overrideaddress000000000000000000000000';
    writeYamlOrJson(strategyPath, {
      [CHAIN]: {
        submitter: {
          type: TxSubmitterType.JSON_RPC,
          chain: CHAIN,
        },
        submitterOverrides: {
          [overrideTarget]: {
            type: TxSubmitterType.GNOSIS_TX_BUILDER,
            chain: CHAIN,
            safeAddress: '0x8888888888888888888888888888888888888888',
            version: '1.0',
          },
        },
      },
    });

    const txDefaultFirst = {
      ...TX,
      to: 'cosmos1defaultfirst0000000000000000000000000',
    };
    const txOverride = {
      ...TX,
      to: overrideTarget,
    };
    const txDefaultLast = {
      ...TX,
      to: 'cosmos1defaultlast00000000000000000000000000',
    };

    const batches = await resolveSubmitterBatchesForTransactions({
      chain: CHAIN,
      transactions: [
        txDefaultFirst as any,
        txOverride as any,
        txDefaultLast as any,
      ],
      context: {
        multiProvider: {
          getProtocol: () => ProtocolType.CosmosNative,
        },
      } as any,
      strategyUrl: strategyPath,
    });

    expect(batches).to.have.length(3);
    expect(batches[0].config.submitter.type).to.equal(TxSubmitterType.JSON_RPC);
    expect(batches[1].config.submitter.type).to.equal(
      TxSubmitterType.GNOSIS_TX_BUILDER,
    );
    expect(batches[2].config.submitter.type).to.equal(TxSubmitterType.JSON_RPC);
    expect(batches[0].transactions).to.deep.equal([txDefaultFirst as any]);
    expect(batches[1].transactions).to.deep.equal([txOverride as any]);
    expect(batches[2].transactions).to.deep.equal([txDefaultLast as any]);
  });

  it('routes same-chain transactions to different inferred submitters', async () => {
    const safeOwner = '0x2222222222222222222222222222222222222222';
    const txSignerOwned = {
      ...TX,
      to: '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa',
    };
    const txSafeOwned = {
      ...TX,
      to: '0xbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb',
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () =>
            targetAddress.toLowerCase() === txSignerOwned.to.toLowerCase()
              ? SIGNER
              : safeOwner,
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== safeOwner.toLowerCase()) {
          throw new Error('not safe');
        }

        return {
          getThreshold: async () => 1,
          nonce: async () => 0,
        } as any;
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => ({}),
      },
      registry: {
        getAddresses: async () => ({}),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [txSignerOwned as any, txSafeOwned as any],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.GNOSIS_TX_BUILDER,
      );
      expect(batches[0].transactions).to.deep.equal([txSignerOwned as any]);
      expect(batches[1].transactions).to.deep.equal([txSafeOwned as any]);
    } finally {
      ownableStub.restore();
      safeStub.restore();
    }
  });

  it('preserves transaction order by splitting non-contiguous inferred submitter matches', async () => {
    const safeOwner = '0x2222222222222222222222222222222222222222';
    const txSignerFirst = {
      ...TX,
      to: '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa',
    };
    const txSafeOwned = {
      ...TX,
      to: '0xbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb',
    };
    const txSignerLast = {
      ...TX,
      to: '0xcccccccccccccccccccccccccccccccccccccccc',
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () =>
            targetAddress.toLowerCase() === txSafeOwned.to.toLowerCase()
              ? safeOwner
              : SIGNER,
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== safeOwner.toLowerCase()) {
          throw new Error('not safe');
        }

        return {
          getThreshold: async () => 1,
          nonce: async () => 0,
        } as any;
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => ({}),
      },
      registry: {
        getAddresses: async () => ({}),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          txSignerFirst as any,
          txSafeOwned as any,
          txSignerLast as any,
        ],
        context,
      });

      expect(batches).to.have.length(3);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.GNOSIS_TX_BUILDER,
      );
      expect(batches[2].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(batches[0].transactions).to.deep.equal([txSignerFirst as any]);
      expect(batches[1].transactions).to.deep.equal([txSafeOwned as any]);
      expect(batches[2].transactions).to.deep.equal([txSignerLast as any]);
    } finally {
      ownableStub.restore();
      safeStub.restore();
    }
  });

  it('coalesces adjacent inferred submitter matches into single batches', async () => {
    const safeOwner = '0x2222222222222222222222222222222222222222';
    const txSignerFirst = {
      ...TX,
      to: '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa',
    };
    const txSignerSecond = {
      ...TX,
      to: '0xabababababababababababababababababababab',
    };
    const txSafeFirst = {
      ...TX,
      to: '0xbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb',
    };
    const txSafeSecond = {
      ...TX,
      to: '0xbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbc',
    };
    const txSignerLast = {
      ...TX,
      to: '0xcccccccccccccccccccccccccccccccccccccccc',
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () =>
            targetAddress.toLowerCase() === txSafeFirst.to.toLowerCase() ||
            targetAddress.toLowerCase() === txSafeSecond.to.toLowerCase()
              ? safeOwner
              : SIGNER,
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== safeOwner.toLowerCase()) {
          throw new Error('not safe');
        }

        return {
          getThreshold: async () => 1,
          nonce: async () => 0,
        } as any;
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => ({}),
      },
      registry: {
        getAddresses: async () => ({}),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          txSignerFirst as any,
          txSignerSecond as any,
          txSafeFirst as any,
          txSafeSecond as any,
          txSignerLast as any,
        ],
        context,
      });

      expect(batches).to.have.length(3);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.GNOSIS_TX_BUILDER,
      );
      expect(batches[2].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(batches[0].transactions).to.deep.equal([
        txSignerFirst as any,
        txSignerSecond as any,
      ]);
      expect(batches[1].transactions).to.deep.equal([
        txSafeFirst as any,
        txSafeSecond as any,
      ]);
      expect(batches[2].transactions).to.deep.equal([txSignerLast as any]);
    } finally {
      ownableStub.restore();
      safeStub.restore();
    }
  });

  it('uses transaction from as fallback inference source when ownable read fails', async () => {
    const fromSafe = '0x4444444444444444444444444444444444444444';
    const ownableStub = sinon
      .stub(Ownable__factory, 'connect')
      .throws(new Error('not ownable'));
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== fromSafe.toLowerCase()) {
          throw new Error('not safe');
        }

        return {
          getThreshold: async () => 1,
          nonce: async () => 0,
        } as any;
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => ({}),
      },
      registry: {
        getAddresses: async () => ({}),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [{ ...TX, from: fromSafe } as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.GNOSIS_TX_BUILDER,
      );
    } finally {
      ownableStub.restore();
      safeStub.restore();
    }
  });

  it('normalizes uppercase 0X transaction from before fallback inference', async () => {
    const fromSafe = '0x4444444444444444444444444444444444444444';
    const ownableStub = sinon
      .stub(Ownable__factory, 'connect')
      .throws(new Error('not ownable'));
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== fromSafe.toLowerCase()) {
          throw new Error('not safe');
        }

        return {
          getThreshold: async () => 1,
          nonce: async () => 0,
        } as any;
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => ({}),
      },
      registry: {
        getAddresses: async () => ({}),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          {
            ...TX,
            from: '  0X4444444444444444444444444444444444444444  ',
          } as any,
        ],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.GNOSIS_TX_BUILDER,
      );
    } finally {
      ownableStub.restore();
      safeStub.restore();
    }
  });

  it('normalizes uppercase 0X transaction target before inference owner lookup', async () => {
    const safeOwner = '0x2222222222222222222222222222222222222222';
    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (_targetAddressInput: string) =>
        ({
          owner: async () => safeOwner,
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== safeOwner.toLowerCase()) {
          throw new Error('not safe');
        }

        return {
          getThreshold: async () => 1,
          nonce: async () => 0,
        } as any;
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => ({}),
      },
      registry: {
        getAddresses: async () => ({}),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          {
            ...TX,
            to: '  0Xbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb  ',
          } as any,
        ],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.GNOSIS_TX_BUILDER,
      );
    } finally {
      ownableStub.restore();
      safeStub.restore();
    }
  });

  it('falls back to jsonRpc when inferred ICA owner origin signer is unavailable', async () => {
    const inferredIcaOwner = '0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee';
    const destinationRouterAddress =
      '0x9999999999999999999999999999999999999999';
    const originRouterAddress = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              inferredIcaOwner,
          } as any;
        }

        throw new Error('unexpected router');
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => (chainName === CHAIN ? {} : null),
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('falls back to jsonRpc when origin signer lookup fails and tryGetSigner is unavailable', async () => {
    const inferredIcaOwner = '0xabababababababababababababababababababab';
    const destinationRouterAddress =
      '0xbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbc';
    const originRouterAddress = '0xcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcd';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              inferredIcaOwner,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let signerAddressCalls = 0;
    let providerCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCalls += 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error('origin signer unavailable');
        },
        getProvider: (chainName: string) => {
          providerCalls += 1;
          if (chainName === CHAIN) {
            return provider;
          }
          throw new Error('origin provider unavailable');
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any, TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(provider.getLogs.callCount).to.equal(1);
      expect(signerAddressCalls).to.equal(2);
      expect(providerCalls).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches no-tryGetSigner origin signer lookup failures across direct ICA inferences', async () => {
    const inferredIcaOwnerA = '0xd6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6';
    const inferredIcaOwnerB = '0xe7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7';
    const destinationRouterAddress =
      '0xf8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8';
    const originRouterAddress = '0xf9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': inferredIcaOwnerA,
      '0x2222222222222222222222222222222222222222': inferredIcaOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              inferredIcaOwnerA,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let signerAddressCalls = 0;
    let providerCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCalls += 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error('origin signer unavailable');
        },
        getProvider: (chainName: string) => {
          providerCalls += 1;
          if (chainName === CHAIN) {
            return provider;
          }
          throw new Error('origin provider unavailable');
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].transactions).to.have.length(2);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(provider.getLogs.callCount).to.equal(2);
      expect(signerAddressCalls).to.equal(2);
      expect(providerCalls).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches successful origin signer lookup without tryGetSigner across direct ICA inferences', async () => {
    const inferredIcaOwner = '0x0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a';
    const destinationRouterAddress =
      '0x0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b';
    const originRouterAddress = '0x0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': inferredIcaOwner,
      '0x2222222222222222222222222222222222222222': inferredIcaOwner,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([]),
    };

    let originDerivationCalls = 0;
    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']:
              async () => {
                originDerivationCalls += 1;
                return inferredIcaOwner;
              },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let providerCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN || chainName === 'anvil3') {
            return SIGNER;
          }
          throw new Error(`unknown signer lookup for ${chainName}`);
        },
        getProvider: (chainName: string) => {
          providerCalls += 1;
          if (chainName === CHAIN || chainName === 'anvil3') {
            return provider;
          }
          throw new Error(`unexpected provider lookup for ${chainName}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].transactions).to.have.length(2);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      const submitter = batches[0].config.submitter as any;
      expect(submitter.chain).to.equal('anvil3');
      expect(submitter.owner).to.equal(SIGNER);
      expect(submitter.internalSubmitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(provider.getLogs.callCount).to.equal(1);
      expect(originDerivationCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(providerCalls).to.equal(2);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('falls back to jsonRpc when event-derived ICA origin signer is unavailable', async () => {
    const inferredIcaOwner = '0x1212121212121212121212121212121212121212';
    const destinationRouterAddress =
      '0x3434343434343434343434343434343434343434';
    const originRouterAddress = '0x5656565656565656565656565656565656565656';
    const originRouterBytes32 =
      '0x0000000000000000000000005656565656565656565656565656565656565656';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([{ topics: [], data: '0x' }]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
            interface: {
              parseLog: (_log: unknown) => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: SIGNER,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              inferredIcaOwner,
          } as any;
        }

        throw new Error('unexpected router');
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) return 'anvil3';
          throw new Error('unknown domain');
        },
        tryGetSigner: (chainName: string) => (chainName === CHAIN ? {} : null),
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches null when ICA event log parsing fails', async () => {
    const inferredIcaOwner = '0x7878787878787878787878787878787878787878';
    const destinationRouterAddress =
      '0x9090909090909090909090909090909090909090';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([{ topics: [], data: '0x' }]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
            interface: {
              parseLog: () => {
                throw new Error('malformed ICA event');
              },
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any, TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(provider.getLogs.callCount).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('falls back to next-latest ICA event when latest log parsing fails', async () => {
    const inferredIcaOwner = '0x7878787878787878787878787878787878787878';
    const destinationRouterAddress =
      '0x9090909090909090909090909090909090909090';
    const originRouterAddress = '0x9191919191919191919191919191919191919191';
    const signerBytes32 =
      `0x000000000000000000000000${SIGNER.slice(2)}` as const;
    const originRouterBytes32 =
      `0x000000000000000000000000${originRouterAddress.slice(2)}` as const;

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const validOlderLog = {
      topics: ['0xvalid-older'],
      data: '0x',
      blockNumber: 100,
      transactionIndex: 0,
      logIndex: 0,
    };
    const malformedLatestLog = {
      topics: ['0xmalformed-latest'],
      data: '0x',
      blockNumber: 101,
      transactionIndex: 0,
      logIndex: 0,
    };
    const provider = {
      getLogs: sinon.stub().resolves([validOlderLog, malformedLatestLog]),
    };

    const parseLogStub = sinon.stub().callsFake((log: any) => {
      if (log === malformedLatestLog) {
        throw new Error('malformed ICA event');
      }
      if (log === validOlderLog) {
        return {
          args: {
            origin: 31347,
            router: originRouterBytes32,
            owner: signerBytes32,
            ism: ethersConstants.AddressZero,
          },
        };
      }
      throw new Error('unexpected log');
    });

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
            interface: {
              parseLog: parseLogStub,
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) return 'anvil3';
          throw new Error('unknown domain');
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      expect((batches[0].config.submitter as any).chain).to.equal('anvil3');
      expect(provider.getLogs.callCount).to.equal(1);
      expect(parseLogStub.callCount).to.equal(2);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('falls back to next-latest ICA event when latest parsed origin domain is unknown', async () => {
    const inferredIcaOwner = '0x7878787878787878787878787878787878787878';
    const destinationRouterAddress =
      '0x9090909090909090909090909090909090909090';
    const originRouterAddress = '0x9191919191919191919191919191919191919191';
    const signerBytes32 =
      `0x000000000000000000000000${SIGNER.slice(2)}` as const;
    const originRouterBytes32 =
      `0x000000000000000000000000${originRouterAddress.slice(2)}` as const;

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const validOlderLog = {
      topics: ['0xvalid-older'],
      data: '0x',
      blockNumber: 100,
      transactionIndex: 0,
      logIndex: 0,
    };
    const unknownLatestLog = {
      topics: ['0xunknown-latest'],
      data: '0x',
      blockNumber: 101,
      transactionIndex: 0,
      logIndex: 0,
    };
    const provider = {
      getLogs: sinon.stub().resolves([validOlderLog, unknownLatestLog]),
    };

    const parseLogStub = sinon.stub().callsFake((log: any) => {
      if (log === unknownLatestLog) {
        return {
          args: {
            origin: 999999,
            router: originRouterBytes32,
            owner: signerBytes32,
            ism: ethersConstants.AddressZero,
          },
        };
      }
      if (log === validOlderLog) {
        return {
          args: {
            origin: 31347,
            router: originRouterBytes32,
            owner: signerBytes32,
            ism: ethersConstants.AddressZero,
          },
        };
      }
      throw new Error('unexpected log');
    });

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
            interface: {
              parseLog: parseLogStub,
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      expect((batches[0].config.submitter as any).chain).to.equal('anvil3');
      expect(provider.getLogs.callCount).to.equal(1);
      expect(parseLogStub.callCount).to.equal(2);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('falls back to next-latest ICA event when latest parsed origin domain is malformed', async () => {
    const inferredIcaOwner = '0x7878787878787878787878787878787878787878';
    const destinationRouterAddress =
      '0x9090909090909090909090909090909090909090';
    const originRouterAddress = '0x9191919191919191919191919191919191919191';
    const signerBytes32 =
      `0x000000000000000000000000${SIGNER.slice(2)}` as const;
    const originRouterBytes32 =
      `0x000000000000000000000000${originRouterAddress.slice(2)}` as const;

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const validOlderLog = {
      topics: ['0xvalid-older'],
      data: '0x',
      blockNumber: 100,
      transactionIndex: 0,
      logIndex: 0,
    };
    const malformedLatestLog = {
      topics: ['0xmalformed-origin-domain-latest'],
      data: '0x',
      blockNumber: 101,
      transactionIndex: 0,
      logIndex: 0,
    };
    const provider = {
      getLogs: sinon.stub().resolves([validOlderLog, malformedLatestLog]),
    };

    const parseLogStub = sinon.stub().callsFake((log: any) => {
      if (log === malformedLatestLog) {
        return {
          args: {
            origin: 'not-a-number',
            router: originRouterBytes32,
            owner: signerBytes32,
            ism: ethersConstants.AddressZero,
          },
        };
      }
      if (log === validOlderLog) {
        return {
          args: {
            origin: 31347,
            router: originRouterBytes32,
            owner: signerBytes32,
            ism: ethersConstants.AddressZero,
          },
        };
      }
      throw new Error('unexpected log');
    });

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
            interface: {
              parseLog: parseLogStub,
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      expect((batches[0].config.submitter as any).chain).to.equal('anvil3');
      expect(provider.getLogs.callCount).to.equal(1);
      expect(parseLogStub.callCount).to.equal(2);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('falls back to next-latest ICA event when latest parsed origin domain is out of uint32 range', async () => {
    const inferredIcaOwner = '0x7878787878787878787878787878787878787878';
    const destinationRouterAddress =
      '0x9090909090909090909090909090909090909090';
    const originRouterAddress = '0x9191919191919191919191919191919191919191';
    const signerBytes32 =
      `0x000000000000000000000000${SIGNER.slice(2)}` as const;
    const originRouterBytes32 =
      `0x000000000000000000000000${originRouterAddress.slice(2)}` as const;

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const validOlderLog = {
      topics: ['0xvalid-older'],
      data: '0x',
      blockNumber: 100,
      transactionIndex: 0,
      logIndex: 0,
    };
    const malformedLatestLog = {
      topics: ['0xmalformed-origin-domain-range-latest'],
      data: '0x',
      blockNumber: 101,
      transactionIndex: 0,
      logIndex: 0,
    };
    const provider = {
      getLogs: sinon.stub().resolves([validOlderLog, malformedLatestLog]),
    };

    const parseLogStub = sinon.stub().callsFake((log: any) => {
      if (log === malformedLatestLog) {
        return {
          args: {
            origin: 4294967296,
            router: originRouterBytes32,
            owner: signerBytes32,
            ism: ethersConstants.AddressZero,
          },
        };
      }
      if (log === validOlderLog) {
        return {
          args: {
            origin: 31347,
            router: originRouterBytes32,
            owner: signerBytes32,
            ism: ethersConstants.AddressZero,
          },
        };
      }
      throw new Error('unexpected log');
    });

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
            interface: {
              parseLog: parseLogStub,
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      expect((batches[0].config.submitter as any).chain).to.equal('anvil3');
      expect(provider.getLogs.callCount).to.equal(1);
      expect(parseLogStub.callCount).to.equal(2);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('falls back to next-latest ICA event when latest parsed origin chain has no signer', async () => {
    const inferredIcaOwner = '0x7878787878787878787878787878787878787878';
    const destinationRouterAddress =
      '0x9090909090909090909090909090909090909090';
    const originRouterAddress = '0x9191919191919191919191919191919191919191';
    const signerBytes32 =
      `0x000000000000000000000000${SIGNER.slice(2)}` as const;
    const originRouterBytes32 =
      `0x000000000000000000000000${originRouterAddress.slice(2)}` as const;

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const validOlderLog = {
      topics: ['0xvalid-older'],
      data: '0x',
      blockNumber: 100,
      transactionIndex: 0,
      logIndex: 0,
    };
    const noSignerLatestLog = {
      topics: ['0xno-signer-latest'],
      data: '0x',
      blockNumber: 101,
      transactionIndex: 0,
      logIndex: 0,
    };
    const provider = {
      getLogs: sinon.stub().resolves([validOlderLog, noSignerLatestLog]),
    };

    const parseLogStub = sinon.stub().callsFake((log: any) => {
      if (log === noSignerLatestLog) {
        return {
          args: {
            origin: 31348,
            router: originRouterBytes32,
            owner: signerBytes32,
            ism: ethersConstants.AddressZero,
          },
        };
      }
      if (log === validOlderLog) {
        return {
          args: {
            origin: 31347,
            router: originRouterBytes32,
            owner: signerBytes32,
            ism: ethersConstants.AddressZero,
          },
        };
      }
      throw new Error('unexpected log');
    });

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
            interface: {
              parseLog: parseLogStub,
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === 'anvil4') {
            return null;
          }
          return SIGNER;
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31348) return 'anvil4';
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      expect((batches[0].config.submitter as any).chain).to.equal('anvil3');
      expect(provider.getLogs.callCount).to.equal(1);
      expect(parseLogStub.callCount).to.equal(2);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('falls back to next-latest ICA event when latest parsed bytes32 fields are malformed', async () => {
    const inferredIcaOwner = '0x7878787878787878787878787878787878787878';
    const destinationRouterAddress =
      '0x9090909090909090909090909090909090909090';
    const originRouterAddress = '0x9191919191919191919191919191919191919191';
    const signerBytes32 =
      `0x000000000000000000000000${SIGNER.slice(2)}` as const;
    const originRouterBytes32 =
      `0x000000000000000000000000${originRouterAddress.slice(2)}` as const;

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const validOlderLog = {
      topics: ['0xvalid-older'],
      data: '0x',
      blockNumber: 100,
      transactionIndex: 0,
      logIndex: 0,
    };
    const malformedLatestLog = {
      topics: ['0xmalformed-latest'],
      data: '0x',
      blockNumber: 101,
      transactionIndex: 0,
      logIndex: 0,
    };
    const provider = {
      getLogs: sinon.stub().resolves([validOlderLog, malformedLatestLog]),
    };

    const parseLogStub = sinon.stub().callsFake((log: any) => {
      if (log === malformedLatestLog) {
        return {
          args: {
            origin: 31347,
            router: '0x1234',
            owner: signerBytes32,
            ism: ethersConstants.AddressZero,
          },
        };
      }
      if (log === validOlderLog) {
        return {
          args: {
            origin: 31347,
            router: originRouterBytes32,
            owner: signerBytes32,
            ism: ethersConstants.AddressZero,
          },
        };
      }
      throw new Error('unexpected log');
    });

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
            interface: {
              parseLog: parseLogStub,
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      expect((batches[0].config.submitter as any).chain).to.equal('anvil3');
      expect(provider.getLogs.callCount).to.equal(1);
      expect(parseLogStub.callCount).to.equal(2);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('falls back to next-latest ICA event when latest parsed owner bytes32 is malformed', async () => {
    const inferredIcaOwner = '0x7878787878787878787878787878787878787878';
    const destinationRouterAddress =
      '0x9090909090909090909090909090909090909090';
    const originRouterAddress = '0x9191919191919191919191919191919191919191';
    const signerBytes32 =
      `0x000000000000000000000000${SIGNER.slice(2)}` as const;
    const originRouterBytes32 =
      `0x000000000000000000000000${originRouterAddress.slice(2)}` as const;

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const validOlderLog = {
      topics: ['0xvalid-older'],
      data: '0x',
      blockNumber: 100,
      transactionIndex: 0,
      logIndex: 0,
    };
    const malformedLatestLog = {
      topics: ['0xmalformed-owner-latest'],
      data: '0x',
      blockNumber: 101,
      transactionIndex: 0,
      logIndex: 0,
    };
    const provider = {
      getLogs: sinon.stub().resolves([validOlderLog, malformedLatestLog]),
    };

    const parseLogStub = sinon.stub().callsFake((log: any) => {
      if (log === malformedLatestLog) {
        return {
          args: {
            origin: 31347,
            router: originRouterBytes32,
            owner: '0x1234',
            ism: ethersConstants.AddressZero,
          },
        };
      }
      if (log === validOlderLog) {
        return {
          args: {
            origin: 31347,
            router: originRouterBytes32,
            owner: signerBytes32,
            ism: ethersConstants.AddressZero,
          },
        };
      }
      throw new Error('unexpected log');
    });

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
            interface: {
              parseLog: parseLogStub,
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      expect((batches[0].config.submitter as any).chain).to.equal('anvil3');
      expect(provider.getLogs.callCount).to.equal(1);
      expect(parseLogStub.callCount).to.equal(2);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('falls back to next-latest ICA event when latest parsed owner is zero address', async () => {
    const inferredIcaOwner = '0x7878787878787878787878787878787878787878';
    const destinationRouterAddress =
      '0x9090909090909090909090909090909090909090';
    const originRouterAddress = '0x9191919191919191919191919191919191919191';
    const signerBytes32 =
      `0x000000000000000000000000${SIGNER.slice(2)}` as const;
    const zeroBytes32 = `0x${'0'.repeat(64)}` as const;
    const originRouterBytes32 =
      `0x000000000000000000000000${originRouterAddress.slice(2)}` as const;

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const validOlderLog = {
      topics: ['0xvalid-older'],
      data: '0x',
      blockNumber: 100,
      transactionIndex: 0,
      logIndex: 0,
    };
    const malformedLatestLog = {
      topics: ['0xmalformed-owner-zero-latest'],
      data: '0x',
      blockNumber: 101,
      transactionIndex: 0,
      logIndex: 0,
    };
    const provider = {
      getLogs: sinon.stub().resolves([validOlderLog, malformedLatestLog]),
    };

    const parseLogStub = sinon.stub().callsFake((log: any) => {
      if (log === malformedLatestLog) {
        return {
          args: {
            origin: 31347,
            router: originRouterBytes32,
            owner: zeroBytes32,
            ism: ethersConstants.AddressZero,
          },
        };
      }
      if (log === validOlderLog) {
        return {
          args: {
            origin: 31347,
            router: originRouterBytes32,
            owner: signerBytes32,
            ism: ethersConstants.AddressZero,
          },
        };
      }
      throw new Error('unexpected log');
    });

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
            interface: {
              parseLog: parseLogStub,
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      expect((batches[0].config.submitter as any).chain).to.equal('anvil3');
      expect(provider.getLogs.callCount).to.equal(1);
      expect(parseLogStub.callCount).to.equal(2);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('falls back to next-latest ICA event when latest parsed origin router is zero address', async () => {
    const inferredIcaOwner = '0x7878787878787878787878787878787878787878';
    const destinationRouterAddress =
      '0x9090909090909090909090909090909090909090';
    const originRouterAddress = '0x9191919191919191919191919191919191919191';
    const signerBytes32 =
      `0x000000000000000000000000${SIGNER.slice(2)}` as const;
    const zeroBytes32 = `0x${'0'.repeat(64)}` as const;
    const originRouterBytes32 =
      `0x000000000000000000000000${originRouterAddress.slice(2)}` as const;

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const validOlderLog = {
      topics: ['0xvalid-older'],
      data: '0x',
      blockNumber: 100,
      transactionIndex: 0,
      logIndex: 0,
    };
    const malformedLatestLog = {
      topics: ['0xmalformed-router-zero-latest'],
      data: '0x',
      blockNumber: 101,
      transactionIndex: 0,
      logIndex: 0,
    };
    const provider = {
      getLogs: sinon.stub().resolves([validOlderLog, malformedLatestLog]),
    };

    const parseLogStub = sinon.stub().callsFake((log: any) => {
      if (log === malformedLatestLog) {
        return {
          args: {
            origin: 31347,
            router: zeroBytes32,
            owner: signerBytes32,
            ism: ethersConstants.AddressZero,
          },
        };
      }
      if (log === validOlderLog) {
        return {
          args: {
            origin: 31347,
            router: originRouterBytes32,
            owner: signerBytes32,
            ism: ethersConstants.AddressZero,
          },
        };
      }
      throw new Error('unexpected log');
    });

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
            interface: {
              parseLog: parseLogStub,
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      expect((batches[0].config.submitter as any).chain).to.equal('anvil3');
      expect(provider.getLogs.callCount).to.equal(1);
      expect(parseLogStub.callCount).to.equal(2);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('falls back to next-latest ICA event when latest parsed ism field is malformed', async () => {
    const inferredIcaOwner = '0x7878787878787878787878787878787878787878';
    const destinationRouterAddress =
      '0x9090909090909090909090909090909090909090';
    const originRouterAddress = '0x9191919191919191919191919191919191919191';
    const signerBytes32 =
      `0x000000000000000000000000${SIGNER.slice(2)}` as const;
    const originRouterBytes32 =
      `0x000000000000000000000000${originRouterAddress.slice(2)}` as const;

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const validOlderLog = {
      topics: ['0xvalid-older'],
      data: '0x',
      blockNumber: 100,
      transactionIndex: 0,
      logIndex: 0,
    };
    const malformedLatestLog = {
      topics: ['0xmalformed-latest'],
      data: '0x',
      blockNumber: 101,
      transactionIndex: 0,
      logIndex: 0,
    };
    const provider = {
      getLogs: sinon.stub().resolves([validOlderLog, malformedLatestLog]),
    };

    const parseLogStub = sinon.stub().callsFake((log: any) => {
      if (log === malformedLatestLog) {
        return {
          args: {
            origin: 31347,
            router: originRouterBytes32,
            owner: signerBytes32,
            ism: 'not-an-address',
          },
        };
      }
      if (log === validOlderLog) {
        return {
          args: {
            origin: 31347,
            router: originRouterBytes32,
            owner: signerBytes32,
            ism: ethersConstants.AddressZero,
          },
        };
      }
      throw new Error('unexpected log');
    });

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
            interface: {
              parseLog: parseLogStub,
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      expect((batches[0].config.submitter as any).chain).to.equal('anvil3');
      expect(provider.getLogs.callCount).to.equal(1);
      expect(parseLogStub.callCount).to.equal(2);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('falls back to next-latest ICA event when latest origin signer lookup throws', async () => {
    const inferredIcaOwner = '0x7878787878787878787878787878787878787878';
    const destinationRouterAddress =
      '0x9090909090909090909090909090909090909090';
    const originRouterAddress = '0x9191919191919191919191919191919191919191';
    const signerBytes32 =
      `0x000000000000000000000000${SIGNER.slice(2)}` as const;
    const originRouterBytes32 =
      `0x000000000000000000000000${originRouterAddress.slice(2)}` as const;

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const validOlderLog = {
      topics: ['0xvalid-older'],
      data: '0x',
      blockNumber: 100,
      transactionIndex: 0,
      logIndex: 0,
    };
    const noSignerLatestLog = {
      topics: ['0xno-signer-latest'],
      data: '0x',
      blockNumber: 101,
      transactionIndex: 0,
      logIndex: 0,
    };
    const provider = {
      getLogs: sinon.stub().resolves([validOlderLog, noSignerLatestLog]),
    };

    const parseLogStub = sinon.stub().callsFake((log: any) => {
      if (log === noSignerLatestLog) {
        return {
          args: {
            origin: 31348,
            router: originRouterBytes32,
            owner: signerBytes32,
            ism: ethersConstants.AddressZero,
          },
        };
      }
      if (log === validOlderLog) {
        return {
          args: {
            origin: 31347,
            router: originRouterBytes32,
            owner: signerBytes32,
            ism: ethersConstants.AddressZero,
          },
        };
      }
      throw new Error('unexpected log');
    });

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
            interface: {
              parseLog: parseLogStub,
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === 'anvil4') {
            throw new Error('signer lookup failed');
          }
          return SIGNER;
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31348) return 'anvil4';
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      expect((batches[0].config.submitter as any).chain).to.equal('anvil3');
      expect(provider.getLogs.callCount).to.equal(1);
      expect(parseLogStub.callCount).to.equal(2);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches null when ICA event log has malformed bytes32 fields', async () => {
    const inferredIcaOwner = '0x7979797979797979797979797979797979797979';
    const destinationRouterAddress =
      '0x9090909090909090909090909090909090909090';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([{ topics: [], data: '0x' }]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: '0x1234', // malformed bytes32
                  owner: `0x000000000000000000000000${SIGNER.slice(2)}`,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any, TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(provider.getLogs.callCount).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches null when ICA event log has malformed origin domain field', async () => {
    const inferredIcaOwner = '0x7979797979797979797979797979797979797979';
    const destinationRouterAddress =
      '0x9090909090909090909090909090909090909090';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([{ topics: [], data: '0x' }]),
    };

    let chainNameCalls = 0;
    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 'not-a-number',
                  router: `0x000000000000000000000000${SIGNER.slice(2)}`,
                  owner: `0x000000000000000000000000${SIGNER.slice(2)}`,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
        getChainName: (_domain: number) => {
          chainNameCalls += 1;
          throw new Error('unknown domain');
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any, TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(provider.getLogs.callCount).to.equal(1);
      expect(chainNameCalls).to.equal(0);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches null when ICA event log has out-of-range origin domain field', async () => {
    const inferredIcaOwner = '0x7979797979797979797979797979797979797979';
    const destinationRouterAddress =
      '0x9090909090909090909090909090909090909090';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([{ topics: [], data: '0x' }]),
    };

    let chainNameCalls = 0;
    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 4294967296,
                  router: `0x000000000000000000000000${SIGNER.slice(2)}`,
                  owner: `0x000000000000000000000000${SIGNER.slice(2)}`,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
        getChainName: (_domain: number) => {
          chainNameCalls += 1;
          throw new Error('unknown domain');
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any, TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(provider.getLogs.callCount).to.equal(1);
      expect(chainNameCalls).to.equal(0);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches null when ICA event log has malformed owner bytes32 field', async () => {
    const inferredIcaOwner = '0x7979797979797979797979797979797979797979';
    const destinationRouterAddress =
      '0x9090909090909090909090909090909090909090';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([{ topics: [], data: '0x' }]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: `0x000000000000000000000000${SIGNER.slice(2)}`,
                  owner: '0x1234',
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any, TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(provider.getLogs.callCount).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches null when ICA event log has zero owner address field', async () => {
    const inferredIcaOwner = '0x7979797979797979797979797979797979797979';
    const destinationRouterAddress =
      '0x9090909090909090909090909090909090909090';
    const zeroBytes32 = `0x${'0'.repeat(64)}` as const;

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([{ topics: [], data: '0x' }]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: `0x000000000000000000000000${SIGNER.slice(2)}`,
                  owner: zeroBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any, TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(provider.getLogs.callCount).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches null when ICA event log has zero origin router address field', async () => {
    const inferredIcaOwner = '0x7979797979797979797979797979797979797979';
    const destinationRouterAddress =
      '0x9090909090909090909090909090909090909090';
    const zeroBytes32 = `0x${'0'.repeat(64)}` as const;

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([{ topics: [], data: '0x' }]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: zeroBytes32,
                  owner: `0x000000000000000000000000${SIGNER.slice(2)}`,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any, TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(provider.getLogs.callCount).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches null when ICA event log has malformed ism field', async () => {
    const inferredIcaOwner = '0x7979797979797979797979797979797979797979';
    const destinationRouterAddress =
      '0x9090909090909090909090909090909090909090';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([{ topics: [], data: '0x' }]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: `0x000000000000000000000000${SIGNER.slice(2)}`,
                  owner: `0x000000000000000000000000${SIGNER.slice(2)}`,
                  ism: 'invalid-ism-address',
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any, TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(provider.getLogs.callCount).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches unknown origin domain lookups across ICA event-derived inferences', async () => {
    const inferredIcaOwnerA = '0x7676767676767676767676767676767676767676';
    const inferredIcaOwnerB = '0x8686868686868686868686868686868686868686';
    const destinationRouterAddress =
      '0x9090909090909090909090909090909090909090';
    const originOwnerBytes32 =
      `0x000000000000000000000000${SIGNER.slice(2)}` as const;

    const ownerByTarget: Record<string, string> = {
      '0xabababababababababababababababababababab': inferredIcaOwnerA,
      '0xcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcd': inferredIcaOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([{ topics: [], data: '0x' }]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 999999,
                  router:
                    '0x0000000000000000000000009191919191919191919191919191919191919191',
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let providerCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => {
          providerCalls += 1;
          return provider;
        },
        getChainName: () => {
          chainNameCalls += 1;
          throw new Error('unknown domain');
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0xABABABABABABABABABABABABABABABABABABABAB' } as any,
          { ...TX, to: '0xCDCDCDCDCDCDCDCDCDCDCDCDCDCDCDCDCDCDCDCD' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(provider.getLogs.callCount).to.equal(2);
      expect(chainNameCalls).to.equal(1);
      expect(providerCalls).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('uses latest ICA event log by on-chain position when provider logs are unsorted', async () => {
    const inferredIcaOwner = '0x8787878787878787878787878787878787878787';
    const destinationRouterAddress =
      '0x9090909090909090909090909090909090909090';
    const originRouterAddress = '0x9191919191919191919191919191919191919191';
    const signerBytes32 =
      `0x000000000000000000000000${SIGNER.slice(2)}` as const;
    const originRouterBytes32 =
      `0x000000000000000000000000${originRouterAddress.slice(2)}` as const;

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const newerLog = {
      topics: ['0xnewer'],
      data: '0x',
      blockNumber: 102,
      transactionIndex: 0,
      logIndex: 1,
    };
    const olderLog = {
      topics: ['0xolder'],
      data: '0x',
      blockNumber: 101,
      transactionIndex: 0,
      logIndex: 1,
    };
    const provider = {
      getLogs: sinon.stub().resolves([newerLog, olderLog]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== destinationRouterAddress.toLowerCase()) {
          throw new Error('unexpected router');
        }

        return {
          filters: {
            InterchainAccountCreated: (_accountAddress: string) => ({}),
          },
          interface: {
            parseLog: (log: any) => {
              if (log === newerLog) {
                return {
                  args: {
                    origin: 31347,
                    router: originRouterBytes32,
                    owner: signerBytes32,
                    ism: ethersConstants.AddressZero,
                  },
                };
              }
              return {
                args: {
                  origin: 999999,
                  router: originRouterBytes32,
                  owner: signerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              };
            },
          },
        } as any;
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) {
            return 'anvil3';
          }
          throw new Error(`unknown domain ${domainId}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      expect((batches[0].config.submitter as any).chain).to.equal('anvil3');
      expect(provider.getLogs.callCount).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('treats malformed blockNumber as lower for ICA event ordering even with higher tx/log indexes', async () => {
    const inferredIcaOwner = '0x8787878787878787878787878787878787878787';
    const destinationRouterAddress =
      '0x9090909090909090909090909090909090909090';
    const originRouterAddress = '0x9191919191919191919191919191919191919191';
    const signerBytes32 =
      `0x000000000000000000000000${SIGNER.slice(2)}` as const;
    const originRouterBytes32 =
      `0x000000000000000000000000${originRouterAddress.slice(2)}` as const;

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const validLog = {
      topics: ['0xvalid'],
      data: '0x',
      blockNumber: 199,
      transactionIndex: 0,
      logIndex: 0,
    };
    const malformedBlockLog = {
      topics: ['0xmalformed-block'],
      data: '0x',
      blockNumber: 'not-a-number',
      transactionIndex: 999,
      logIndex: 999,
    };
    const provider = {
      getLogs: sinon.stub().resolves([malformedBlockLog, validLog]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== destinationRouterAddress.toLowerCase()) {
          throw new Error('unexpected router');
        }

        return {
          filters: {
            InterchainAccountCreated: (_accountAddress: string) => ({}),
          },
          interface: {
            parseLog: (log: any) => {
              if (log === validLog) {
                return {
                  args: {
                    origin: 31347,
                    router: originRouterBytes32,
                    owner: signerBytes32,
                    ism: ethersConstants.AddressZero,
                  },
                };
              }
              return {
                args: {
                  origin: 999999,
                  router: originRouterBytes32,
                  owner: signerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              };
            },
          },
        } as any;
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) {
            return 'anvil3';
          }
          throw new Error(`unknown domain ${domainId}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      expect((batches[0].config.submitter as any).chain).to.equal('anvil3');
      expect(provider.getLogs.callCount).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('uses transaction/log index ordering when ICA event logs share block number', async () => {
    const inferredIcaOwner = '0x8888888888888888888888888888888888888888';
    const destinationRouterAddress =
      '0x9090909090909090909090909090909090909090';
    const originRouterAddress = '0x9191919191919191919191919191919191919191';
    const signerBytes32 =
      `0x000000000000000000000000${SIGNER.slice(2)}` as const;
    const originRouterBytes32 =
      `0x000000000000000000000000${originRouterAddress.slice(2)}` as const;

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const newerLog = {
      topics: ['0xnewer'],
      data: '0x',
      blockNumber: 200,
      transactionIndex: 9,
      logIndex: 1,
    };
    const olderLog = {
      topics: ['0xolder'],
      data: '0x',
      blockNumber: 200,
      transactionIndex: 8,
      logIndex: 50,
    };
    const provider = {
      // intentionally unsorted newest-first to ensure array tail is not trusted
      getLogs: sinon.stub().resolves([newerLog, olderLog]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== destinationRouterAddress.toLowerCase()) {
          throw new Error('unexpected router');
        }

        return {
          filters: {
            InterchainAccountCreated: (_accountAddress: string) => ({}),
          },
          interface: {
            parseLog: (log: any) => {
              if (log === newerLog) {
                return {
                  args: {
                    origin: 31347,
                    router: originRouterBytes32,
                    owner: signerBytes32,
                    ism: ethersConstants.AddressZero,
                  },
                };
              }
              return {
                args: {
                  origin: 999999,
                  router: originRouterBytes32,
                  owner: signerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              };
            },
          },
        } as any;
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) {
            return 'anvil3';
          }
          throw new Error(`unknown domain ${domainId}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      expect((batches[0].config.submitter as any).chain).to.equal('anvil3');
      expect(provider.getLogs.callCount).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('treats malformed transactionIndex as lower when ICA event logs share block number', async () => {
    const inferredIcaOwner = '0x8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f';
    const destinationRouterAddress =
      '0x9090909090909090909090909090909090909090';
    const originRouterAddress = '0x9191919191919191919191919191919191919191';
    const signerBytes32 =
      `0x000000000000000000000000${SIGNER.slice(2)}` as const;
    const originRouterBytes32 =
      `0x000000000000000000000000${originRouterAddress.slice(2)}` as const;

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const validLog = {
      topics: ['0xvalid'],
      data: '0x',
      blockNumber: 210,
      transactionIndex: 1,
      logIndex: 1,
    };
    const malformedTxIndexLog = {
      topics: ['0xmalformed-tx-index'],
      data: '0x',
      blockNumber: 210,
      transactionIndex: -1,
      logIndex: 999,
    };
    const provider = {
      getLogs: sinon.stub().resolves([malformedTxIndexLog, validLog]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== destinationRouterAddress.toLowerCase()) {
          throw new Error('unexpected router');
        }

        return {
          filters: {
            InterchainAccountCreated: (_accountAddress: string) => ({}),
          },
          interface: {
            parseLog: (log: any) => {
              if (log === validLog) {
                return {
                  args: {
                    origin: 31347,
                    router: originRouterBytes32,
                    owner: signerBytes32,
                    ism: ethersConstants.AddressZero,
                  },
                };
              }
              return {
                args: {
                  origin: 999999,
                  router: originRouterBytes32,
                  owner: signerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              };
            },
          },
        } as any;
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) {
            return 'anvil3';
          }
          throw new Error(`unknown domain ${domainId}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      expect((batches[0].config.submitter as any).chain).to.equal('anvil3');
      expect(provider.getLogs.callCount).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('treats non-integer string transactionIndex as lower when ICA event logs share block number', async () => {
    const inferredIcaOwner = '0x8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a';
    const destinationRouterAddress =
      '0x9090909090909090909090909090909090909090';
    const originRouterAddress = '0x9191919191919191919191919191919191919191';
    const signerBytes32 =
      `0x000000000000000000000000${SIGNER.slice(2)}` as const;
    const originRouterBytes32 =
      `0x000000000000000000000000${originRouterAddress.slice(2)}` as const;

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const validLog = {
      topics: ['0xvalid'],
      data: '0x',
      blockNumber: 210,
      transactionIndex: 1,
      logIndex: 1,
    };
    const malformedTxIndexLog = {
      topics: ['0xmalformed-string-tx-index'],
      data: '0x',
      blockNumber: 210,
      transactionIndex: '9999.9',
      logIndex: 999,
    };
    const provider = {
      getLogs: sinon.stub().resolves([malformedTxIndexLog, validLog]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== destinationRouterAddress.toLowerCase()) {
          throw new Error('unexpected router');
        }

        return {
          filters: {
            InterchainAccountCreated: (_accountAddress: string) => ({}),
          },
          interface: {
            parseLog: (log: any) => {
              if (log === validLog) {
                return {
                  args: {
                    origin: 31347,
                    router: originRouterBytes32,
                    owner: signerBytes32,
                    ism: ethersConstants.AddressZero,
                  },
                };
              }
              return {
                args: {
                  origin: 999999,
                  router: originRouterBytes32,
                  owner: signerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              };
            },
          },
        } as any;
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) {
            return 'anvil3';
          }
          throw new Error(`unknown domain ${domainId}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      expect((batches[0].config.submitter as any).chain).to.equal('anvil3');
      expect(provider.getLogs.callCount).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('treats non-finite transactionIndex as lower when ICA event logs share block number', async () => {
    const inferredIcaOwner = '0x8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d';
    const destinationRouterAddress =
      '0x9090909090909090909090909090909090909090';
    const originRouterAddress = '0x9191919191919191919191919191919191919191';
    const signerBytes32 =
      `0x000000000000000000000000${SIGNER.slice(2)}` as const;
    const originRouterBytes32 =
      `0x000000000000000000000000${originRouterAddress.slice(2)}` as const;

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const validLog = {
      topics: ['0xvalid'],
      data: '0x',
      blockNumber: 211,
      transactionIndex: 1,
      logIndex: 1,
    };
    const malformedInfinityTxIndexLog = {
      topics: ['0xmalformed-infinity-tx-index'],
      data: '0x',
      blockNumber: 211,
      transactionIndex: Number.POSITIVE_INFINITY,
      logIndex: 999,
    };
    const malformedNaNTxIndexLog = {
      topics: ['0xmalformed-nan-tx-index'],
      data: '0x',
      blockNumber: 211,
      transactionIndex: Number.NaN,
      logIndex: 999,
    };
    const malformedNegativeInfinityTxIndexLog = {
      topics: ['0xmalformed-negative-infinity-tx-index'],
      data: '0x',
      blockNumber: 211,
      transactionIndex: Number.NEGATIVE_INFINITY,
      logIndex: 999,
    };
    const provider = {
      getLogs: sinon
        .stub()
        .resolves([
          malformedInfinityTxIndexLog,
          malformedNaNTxIndexLog,
          malformedNegativeInfinityTxIndexLog,
          validLog,
        ]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== destinationRouterAddress.toLowerCase()) {
          throw new Error('unexpected router');
        }

        return {
          filters: {
            InterchainAccountCreated: (_accountAddress: string) => ({}),
          },
          interface: {
            parseLog: (log: any) => {
              if (log === validLog) {
                return {
                  args: {
                    origin: 31347,
                    router: originRouterBytes32,
                    owner: signerBytes32,
                    ism: ethersConstants.AddressZero,
                  },
                };
              }
              return {
                args: {
                  origin: 999999,
                  router: originRouterBytes32,
                  owner: signerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              };
            },
          },
        } as any;
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) {
            return 'anvil3';
          }
          throw new Error(`unknown domain ${domainId}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      expect((batches[0].config.submitter as any).chain).to.equal('anvil3');
      expect(provider.getLogs.callCount).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('treats unsafe-number transactionIndex as lower when ICA event logs share block number', async () => {
    const inferredIcaOwner = '0x8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c';
    const destinationRouterAddress =
      '0x9090909090909090909090909090909090909090';
    const originRouterAddress = '0x9191919191919191919191919191919191919191';
    const signerBytes32 =
      `0x000000000000000000000000${SIGNER.slice(2)}` as const;
    const originRouterBytes32 =
      `0x000000000000000000000000${originRouterAddress.slice(2)}` as const;

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const validLog = {
      topics: ['0xvalid'],
      data: '0x',
      blockNumber: 212,
      transactionIndex: 1,
      logIndex: 1,
    };
    const malformedUnsafeTxIndexLog = {
      topics: ['0xmalformed-unsafe-tx-index'],
      data: '0x',
      blockNumber: 212,
      transactionIndex: Number.MAX_SAFE_INTEGER + 1,
      logIndex: 999,
    };
    const provider = {
      getLogs: sinon.stub().resolves([malformedUnsafeTxIndexLog, validLog]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== destinationRouterAddress.toLowerCase()) {
          throw new Error('unexpected router');
        }

        return {
          filters: {
            InterchainAccountCreated: (_accountAddress: string) => ({}),
          },
          interface: {
            parseLog: (log: any) => {
              if (log === validLog) {
                return {
                  args: {
                    origin: 31347,
                    router: originRouterBytes32,
                    owner: signerBytes32,
                    ism: ethersConstants.AddressZero,
                  },
                };
              }
              return {
                args: {
                  origin: 999999,
                  router: originRouterBytes32,
                  owner: signerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              };
            },
          },
        } as any;
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) {
            return 'anvil3';
          }
          throw new Error(`unknown domain ${domainId}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      expect((batches[0].config.submitter as any).chain).to.equal('anvil3');
      expect(provider.getLogs.callCount).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('uses log index ordering when ICA event logs share block and transaction index', async () => {
    const inferredIcaOwner = '0x8989898989898989898989898989898989898989';
    const destinationRouterAddress =
      '0x9090909090909090909090909090909090909090';
    const originRouterAddress = '0x9191919191919191919191919191919191919191';
    const signerBytes32 =
      `0x000000000000000000000000${SIGNER.slice(2)}` as const;
    const originRouterBytes32 =
      `0x000000000000000000000000${originRouterAddress.slice(2)}` as const;

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const newerLog = {
      topics: ['0xnewer'],
      data: '0x',
      blockNumber: 201,
      transactionIndex: 4,
      logIndex: 20,
    };
    const olderLog = {
      topics: ['0xolder'],
      data: '0x',
      blockNumber: 201,
      transactionIndex: 4,
      logIndex: 19,
    };
    const provider = {
      // intentionally unsorted newest-first so resolver cannot trust array order
      getLogs: sinon.stub().resolves([newerLog, olderLog]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== destinationRouterAddress.toLowerCase()) {
          throw new Error('unexpected router');
        }

        return {
          filters: {
            InterchainAccountCreated: (_accountAddress: string) => ({}),
          },
          interface: {
            parseLog: (log: any) => {
              if (log === newerLog) {
                return {
                  args: {
                    origin: 31347,
                    router: originRouterBytes32,
                    owner: signerBytes32,
                    ism: ethersConstants.AddressZero,
                  },
                };
              }
              return {
                args: {
                  origin: 999999,
                  router: originRouterBytes32,
                  owner: signerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              };
            },
          },
        } as any;
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) {
            return 'anvil3';
          }
          throw new Error(`unknown domain ${domainId}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      expect((batches[0].config.submitter as any).chain).to.equal('anvil3');
      expect(provider.getLogs.callCount).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('treats malformed logIndex as lower when ICA event logs share block and transaction index', async () => {
    const inferredIcaOwner = '0x8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d';
    const destinationRouterAddress =
      '0x9090909090909090909090909090909090909090';
    const originRouterAddress = '0x9191919191919191919191919191919191919191';
    const signerBytes32 =
      `0x000000000000000000000000${SIGNER.slice(2)}` as const;
    const originRouterBytes32 =
      `0x000000000000000000000000${originRouterAddress.slice(2)}` as const;

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const validLog = {
      topics: ['0xvalid'],
      data: '0x',
      blockNumber: 220,
      transactionIndex: 4,
      logIndex: 20,
    };
    const malformedLogIndexLog = {
      topics: ['0xmalformed-log-index'],
      data: '0x',
      blockNumber: 220,
      transactionIndex: 4,
      logIndex: -1,
    };
    const provider = {
      getLogs: sinon.stub().resolves([malformedLogIndexLog, validLog]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== destinationRouterAddress.toLowerCase()) {
          throw new Error('unexpected router');
        }

        return {
          filters: {
            InterchainAccountCreated: (_accountAddress: string) => ({}),
          },
          interface: {
            parseLog: (log: any) => {
              if (log === validLog) {
                return {
                  args: {
                    origin: 31347,
                    router: originRouterBytes32,
                    owner: signerBytes32,
                    ism: ethersConstants.AddressZero,
                  },
                };
              }
              return {
                args: {
                  origin: 999999,
                  router: originRouterBytes32,
                  owner: signerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              };
            },
          },
        } as any;
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) {
            return 'anvil3';
          }
          throw new Error(`unknown domain ${domainId}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      expect((batches[0].config.submitter as any).chain).to.equal('anvil3');
      expect(provider.getLogs.callCount).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('treats non-integer string logIndex as lower when ICA event logs share block and transaction index', async () => {
    const inferredIcaOwner = '0x8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e';
    const destinationRouterAddress =
      '0x9090909090909090909090909090909090909090';
    const originRouterAddress = '0x9191919191919191919191919191919191919191';
    const signerBytes32 =
      `0x000000000000000000000000${SIGNER.slice(2)}` as const;
    const originRouterBytes32 =
      `0x000000000000000000000000${originRouterAddress.slice(2)}` as const;

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const validLog = {
      topics: ['0xvalid'],
      data: '0x',
      blockNumber: 221,
      transactionIndex: 5,
      logIndex: 20,
    };
    const malformedLogIndexLog = {
      topics: ['0xmalformed-string-log-index'],
      data: '0x',
      blockNumber: 221,
      transactionIndex: 5,
      logIndex: '9999.9',
    };
    const provider = {
      getLogs: sinon.stub().resolves([malformedLogIndexLog, validLog]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== destinationRouterAddress.toLowerCase()) {
          throw new Error('unexpected router');
        }

        return {
          filters: {
            InterchainAccountCreated: (_accountAddress: string) => ({}),
          },
          interface: {
            parseLog: (log: any) => {
              if (log === validLog) {
                return {
                  args: {
                    origin: 31347,
                    router: originRouterBytes32,
                    owner: signerBytes32,
                    ism: ethersConstants.AddressZero,
                  },
                };
              }
              return {
                args: {
                  origin: 999999,
                  router: originRouterBytes32,
                  owner: signerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              };
            },
          },
        } as any;
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) {
            return 'anvil3';
          }
          throw new Error(`unknown domain ${domainId}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      expect((batches[0].config.submitter as any).chain).to.equal('anvil3');
      expect(provider.getLogs.callCount).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('treats non-finite logIndex as lower when ICA event logs share block and transaction index', async () => {
    const inferredIcaOwner = '0x8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f';
    const destinationRouterAddress =
      '0x9090909090909090909090909090909090909090';
    const originRouterAddress = '0x9191919191919191919191919191919191919191';
    const signerBytes32 =
      `0x000000000000000000000000${SIGNER.slice(2)}` as const;
    const originRouterBytes32 =
      `0x000000000000000000000000${originRouterAddress.slice(2)}` as const;

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const validLog = {
      topics: ['0xvalid'],
      data: '0x',
      blockNumber: 222,
      transactionIndex: 6,
      logIndex: 20,
    };
    const malformedInfinityLogIndexLog = {
      topics: ['0xmalformed-infinity-log-index'],
      data: '0x',
      blockNumber: 222,
      transactionIndex: 6,
      logIndex: Number.POSITIVE_INFINITY,
    };
    const malformedNaNLogIndexLog = {
      topics: ['0xmalformed-nan-log-index'],
      data: '0x',
      blockNumber: 222,
      transactionIndex: 6,
      logIndex: Number.NaN,
    };
    const malformedNegativeInfinityLogIndexLog = {
      topics: ['0xmalformed-negative-infinity-log-index'],
      data: '0x',
      blockNumber: 222,
      transactionIndex: 6,
      logIndex: Number.NEGATIVE_INFINITY,
    };
    const provider = {
      getLogs: sinon
        .stub()
        .resolves([
          malformedInfinityLogIndexLog,
          malformedNaNLogIndexLog,
          malformedNegativeInfinityLogIndexLog,
          validLog,
        ]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== destinationRouterAddress.toLowerCase()) {
          throw new Error('unexpected router');
        }

        return {
          filters: {
            InterchainAccountCreated: (_accountAddress: string) => ({}),
          },
          interface: {
            parseLog: (log: any) => {
              if (log === validLog) {
                return {
                  args: {
                    origin: 31347,
                    router: originRouterBytes32,
                    owner: signerBytes32,
                    ism: ethersConstants.AddressZero,
                  },
                };
              }
              return {
                args: {
                  origin: 999999,
                  router: originRouterBytes32,
                  owner: signerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              };
            },
          },
        } as any;
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) {
            return 'anvil3';
          }
          throw new Error(`unknown domain ${domainId}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      expect((batches[0].config.submitter as any).chain).to.equal('anvil3');
      expect(provider.getLogs.callCount).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('treats unsafe-number logIndex as lower when ICA event logs share block and transaction index', async () => {
    const inferredIcaOwner = '0x8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b';
    const destinationRouterAddress =
      '0x9090909090909090909090909090909090909090';
    const originRouterAddress = '0x9191919191919191919191919191919191919191';
    const signerBytes32 =
      `0x000000000000000000000000${SIGNER.slice(2)}` as const;
    const originRouterBytes32 =
      `0x000000000000000000000000${originRouterAddress.slice(2)}` as const;

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const validLog = {
      topics: ['0xvalid'],
      data: '0x',
      blockNumber: 223,
      transactionIndex: 7,
      logIndex: 20,
    };
    const malformedUnsafeLogIndexLog = {
      topics: ['0xmalformed-unsafe-log-index'],
      data: '0x',
      blockNumber: 223,
      transactionIndex: 7,
      logIndex: Number.MAX_SAFE_INTEGER + 1,
    };
    const provider = {
      getLogs: sinon.stub().resolves([malformedUnsafeLogIndexLog, validLog]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== destinationRouterAddress.toLowerCase()) {
          throw new Error('unexpected router');
        }

        return {
          filters: {
            InterchainAccountCreated: (_accountAddress: string) => ({}),
          },
          interface: {
            parseLog: (log: any) => {
              if (log === validLog) {
                return {
                  args: {
                    origin: 31347,
                    router: originRouterBytes32,
                    owner: signerBytes32,
                    ism: ethersConstants.AddressZero,
                  },
                };
              }
              return {
                args: {
                  origin: 999999,
                  router: originRouterBytes32,
                  owner: signerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              };
            },
          },
        } as any;
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) {
            return 'anvil3';
          }
          throw new Error(`unknown domain ${domainId}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      expect((batches[0].config.submitter as any).chain).to.equal('anvil3');
      expect(provider.getLogs.callCount).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('handles ICA event logs with missing positional fields deterministically', async () => {
    const inferredIcaOwner = '0x8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a';
    const destinationRouterAddress =
      '0x9090909090909090909090909090909090909090';
    const originRouterAddress = '0x9191919191919191919191919191919191919191';
    const signerBytes32 =
      `0x000000000000000000000000${SIGNER.slice(2)}` as const;
    const originRouterBytes32 =
      `0x000000000000000000000000${originRouterAddress.slice(2)}` as const;

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const logWithMissingIndices = {
      topics: ['0xmissing-indices'],
      data: '0x',
      blockNumber: undefined,
      transactionIndex: undefined,
      logIndex: undefined,
    };
    const fullyIndexedLog = {
      topics: ['0xindexed'],
      data: '0x',
      blockNumber: 202,
      transactionIndex: 1,
      logIndex: 1,
    };
    const provider = {
      // unsorted with partial data first
      getLogs: sinon.stub().resolves([logWithMissingIndices, fullyIndexedLog]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== destinationRouterAddress.toLowerCase()) {
          throw new Error('unexpected router');
        }

        return {
          filters: {
            InterchainAccountCreated: (_accountAddress: string) => ({}),
          },
          interface: {
            parseLog: (log: any) => {
              if (log === fullyIndexedLog) {
                return {
                  args: {
                    origin: 31347,
                    router: originRouterBytes32,
                    owner: signerBytes32,
                    ism: ethersConstants.AddressZero,
                  },
                };
              }
              return {
                args: {
                  origin: 999999,
                  router: originRouterBytes32,
                  owner: signerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              };
            },
          },
        } as any;
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) {
            return 'anvil3';
          }
          throw new Error(`unknown domain ${domainId}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      expect((batches[0].config.submitter as any).chain).to.equal('anvil3');
      expect(provider.getLogs.callCount).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('handles bigint ICA event positional fields deterministically', async () => {
    const inferredIcaOwner = '0x8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b';
    const destinationRouterAddress =
      '0x9090909090909090909090909090909090909090';
    const originRouterAddress = '0x9191919191919191919191919191919191919191';
    const signerBytes32 =
      `0x000000000000000000000000${SIGNER.slice(2)}` as const;
    const originRouterBytes32 =
      `0x000000000000000000000000${originRouterAddress.slice(2)}` as const;

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const olderLog = {
      topics: ['0xolder'],
      data: '0x',
      blockNumber: 500n,
      transactionIndex: 1n,
      logIndex: 1n,
    };
    const newerLog = {
      topics: ['0xnewer'],
      data: '0x',
      blockNumber: 501n,
      transactionIndex: 0n,
      logIndex: 0n,
    };
    const provider = {
      getLogs: sinon.stub().resolves([olderLog, newerLog]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== destinationRouterAddress.toLowerCase()) {
          throw new Error('unexpected router');
        }

        return {
          filters: {
            InterchainAccountCreated: (_accountAddress: string) => ({}),
          },
          interface: {
            parseLog: (log: any) => {
              if (log === newerLog) {
                return {
                  args: {
                    origin: 31347,
                    router: originRouterBytes32,
                    owner: signerBytes32,
                    ism: ethersConstants.AddressZero,
                  },
                };
              }
              return {
                args: {
                  origin: 999999,
                  router: originRouterBytes32,
                  owner: signerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              };
            },
          },
        } as any;
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) {
            return 'anvil3';
          }
          throw new Error(`unknown domain ${domainId}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      expect((batches[0].config.submitter as any).chain).to.equal('anvil3');
      expect(provider.getLogs.callCount).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('ignores negative-bigint ICA event positions during log ordering', async () => {
    const inferredIcaOwner = '0x8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c';
    const destinationRouterAddress =
      '0x9292929292929292929292929292929292929292';
    const originRouterAddress = '0x9393939393939393939393939393939393939393';
    const signerBytes32 =
      `0x000000000000000000000000${SIGNER.slice(2)}` as const;
    const originRouterBytes32 =
      `0x000000000000000000000000${originRouterAddress.slice(2)}` as const;

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const validLog = {
      topics: ['0xvalid'],
      data: '0x',
      blockNumber: 502n,
      transactionIndex: 0n,
      logIndex: 0n,
    };
    const malformedNegativeLog = {
      topics: ['0xmalformed-negative-bigint'],
      data: '0x',
      blockNumber: -1n,
      transactionIndex: 0n,
      logIndex: 0n,
    };
    const provider = {
      getLogs: sinon.stub().resolves([validLog, malformedNegativeLog]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== destinationRouterAddress.toLowerCase()) {
          throw new Error('unexpected router');
        }

        return {
          filters: {
            InterchainAccountCreated: (_accountAddress: string) => ({}),
          },
          interface: {
            parseLog: (log: any) => {
              if (log === validLog) {
                return {
                  args: {
                    origin: 31347,
                    router: originRouterBytes32,
                    owner: signerBytes32,
                    ism: ethersConstants.AddressZero,
                  },
                };
              }
              return {
                args: {
                  origin: 999999,
                  router: originRouterBytes32,
                  owner: signerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              };
            },
          },
        } as any;
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) {
            return 'anvil3';
          }
          throw new Error(`unknown domain ${domainId}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      expect((batches[0].config.submitter as any).chain).to.equal('anvil3');
      expect(provider.getLogs.callCount).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('handles very large bigint ICA event positions without precision loss', async () => {
    const inferredIcaOwner = '0x8a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a';
    const destinationRouterAddress =
      '0x9090909090909090909090909090909090909090';
    const originRouterAddress = '0x9191919191919191919191919191919191919191';
    const signerBytes32 =
      `0x000000000000000000000000${SIGNER.slice(2)}` as const;
    const originRouterBytes32 =
      `0x000000000000000000000000${originRouterAddress.slice(2)}` as const;

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const olderLog = {
      topics: ['0xolder'],
      data: '0x',
      blockNumber: 9007199254740993n,
      transactionIndex: 0n,
      logIndex: 0n,
    };
    const newerLog = {
      topics: ['0xnewer'],
      data: '0x',
      blockNumber: 9007199254740994n,
      transactionIndex: 0n,
      logIndex: 0n,
    };
    const provider = {
      // intentionally unsorted newest-first
      getLogs: sinon.stub().resolves([newerLog, olderLog]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== destinationRouterAddress.toLowerCase()) {
          throw new Error('unexpected router');
        }

        return {
          filters: {
            InterchainAccountCreated: (_accountAddress: string) => ({}),
          },
          interface: {
            parseLog: (log: any) => {
              if (log === newerLog) {
                return {
                  args: {
                    origin: 31347,
                    router: originRouterBytes32,
                    owner: signerBytes32,
                    ism: ethersConstants.AddressZero,
                  },
                };
              }
              return {
                args: {
                  origin: 999999,
                  router: originRouterBytes32,
                  owner: signerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              };
            },
          },
        } as any;
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) {
            return 'anvil3';
          }
          throw new Error(`unknown domain ${domainId}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      expect((batches[0].config.submitter as any).chain).to.equal('anvil3');
      expect(provider.getLogs.callCount).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('handles BigNumber-like ICA event positional fields deterministically', async () => {
    const inferredIcaOwner = '0x8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c';
    const destinationRouterAddress =
      '0x9090909090909090909090909090909090909090';
    const originRouterAddress = '0x9191919191919191919191919191919191919191';
    const signerBytes32 =
      `0x000000000000000000000000${SIGNER.slice(2)}` as const;
    const originRouterBytes32 =
      `0x000000000000000000000000${originRouterAddress.slice(2)}` as const;
    const asBigNumberLike = (value: string) =>
      ({
        toString: () => value,
      }) as any;

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const olderLog = {
      topics: ['0xolder'],
      data: '0x',
      blockNumber: asBigNumberLike('700'),
      transactionIndex: asBigNumberLike('2'),
      logIndex: asBigNumberLike('4'),
    };
    const newerLog = {
      topics: ['0xnewer'],
      data: '0x',
      blockNumber: asBigNumberLike('701'),
      transactionIndex: asBigNumberLike('0'),
      logIndex: asBigNumberLike('0'),
    };
    const provider = {
      // intentionally unsorted newest-last/first should not matter
      getLogs: sinon.stub().resolves([olderLog, newerLog]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== destinationRouterAddress.toLowerCase()) {
          throw new Error('unexpected router');
        }

        return {
          filters: {
            InterchainAccountCreated: (_accountAddress: string) => ({}),
          },
          interface: {
            parseLog: (log: any) => {
              if (log === newerLog) {
                return {
                  args: {
                    origin: 31347,
                    router: originRouterBytes32,
                    owner: signerBytes32,
                    ism: ethersConstants.AddressZero,
                  },
                };
              }
              return {
                args: {
                  origin: 999999,
                  router: originRouterBytes32,
                  owner: signerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              };
            },
          },
        } as any;
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) {
            return 'anvil3';
          }
          throw new Error(`unknown domain ${domainId}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      expect((batches[0].config.submitter as any).chain).to.equal('anvil3');
      expect(provider.getLogs.callCount).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('handles string-encoded ICA event positional fields deterministically', async () => {
    const inferredIcaOwner = '0x8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d';
    const destinationRouterAddress =
      '0x9090909090909090909090909090909090909090';
    const originRouterAddress = '0x9191919191919191919191919191919191919191';
    const signerBytes32 =
      `0x000000000000000000000000${SIGNER.slice(2)}` as const;
    const originRouterBytes32 =
      `0x000000000000000000000000${originRouterAddress.slice(2)}` as const;

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const olderLog = {
      topics: ['0xolder'],
      data: '0x',
      blockNumber: '900',
      transactionIndex: '2',
      logIndex: '3',
    };
    const newerLog = {
      topics: ['0xnewer'],
      data: '0x',
      blockNumber: ' 901 ',
      transactionIndex: '0',
      logIndex: '0',
    };
    const provider = {
      // intentionally unsorted newest-first
      getLogs: sinon.stub().resolves([newerLog, olderLog]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== destinationRouterAddress.toLowerCase()) {
          throw new Error('unexpected router');
        }

        return {
          filters: {
            InterchainAccountCreated: (_accountAddress: string) => ({}),
          },
          interface: {
            parseLog: (log: any) => {
              if (log === newerLog) {
                return {
                  args: {
                    origin: 31347,
                    router: originRouterBytes32,
                    owner: signerBytes32,
                    ism: ethersConstants.AddressZero,
                  },
                };
              }
              return {
                args: {
                  origin: 999999,
                  router: originRouterBytes32,
                  owner: signerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              };
            },
          },
        } as any;
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) {
            return 'anvil3';
          }
          throw new Error(`unknown domain ${domainId}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      expect((batches[0].config.submitter as any).chain).to.equal('anvil3');
      expect(provider.getLogs.callCount).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('handles hex-string ICA event positional fields deterministically', async () => {
    const inferredIcaOwner = '0x8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f';
    const destinationRouterAddress =
      '0x9090909090909090909090909090909090909090';
    const originRouterAddress = '0x9191919191919191919191919191919191919191';
    const signerBytes32 =
      `0x000000000000000000000000${SIGNER.slice(2)}` as const;
    const originRouterBytes32 =
      `0x000000000000000000000000${originRouterAddress.slice(2)}` as const;

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const olderLog = {
      topics: ['0xolder'],
      data: '0x',
      blockNumber: '0x400',
      transactionIndex: '0x1',
      logIndex: '0x2',
    };
    const newerLog = {
      topics: ['0xnewer'],
      data: '0x',
      blockNumber: '0x401',
      transactionIndex: '0x0',
      logIndex: '0x0',
    };
    const provider = {
      getLogs: sinon.stub().resolves([newerLog, olderLog]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== destinationRouterAddress.toLowerCase()) {
          throw new Error('unexpected router');
        }

        return {
          filters: {
            InterchainAccountCreated: (_accountAddress: string) => ({}),
          },
          interface: {
            parseLog: (log: any) => {
              if (log === newerLog) {
                return {
                  args: {
                    origin: 31347,
                    router: originRouterBytes32,
                    owner: signerBytes32,
                    ism: ethersConstants.AddressZero,
                  },
                };
              }
              return {
                args: {
                  origin: 999999,
                  router: originRouterBytes32,
                  owner: signerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              };
            },
          },
        } as any;
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) {
            return 'anvil3';
          }
          throw new Error(`unknown domain ${domainId}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      expect((batches[0].config.submitter as any).chain).to.equal('anvil3');
      expect(provider.getLogs.callCount).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('handles uppercase hex-string ICA event positional fields deterministically', async () => {
    const inferredIcaOwner = '0x9090909090909090909090909090909090909090';
    const destinationRouterAddress =
      '0x9191919191919191919191919191919191919191';
    const originRouterAddress = '0x9292929292929292929292929292929292929292';
    const signerBytes32 =
      `0x000000000000000000000000${SIGNER.slice(2)}` as const;
    const originRouterBytes32 =
      `0x000000000000000000000000${originRouterAddress.slice(2)}` as const;

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const olderLog = {
      topics: ['0xolder'],
      data: '0x',
      blockNumber: '0X500',
      transactionIndex: '0X1',
      logIndex: '0X2',
    };
    const newerLog = {
      topics: ['0xnewer'],
      data: '0x',
      blockNumber: '0X501',
      transactionIndex: '0X0',
      logIndex: '0X0',
    };
    const provider = {
      getLogs: sinon.stub().resolves([newerLog, olderLog]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== destinationRouterAddress.toLowerCase()) {
          throw new Error('unexpected router');
        }

        return {
          filters: {
            InterchainAccountCreated: (_accountAddress: string) => ({}),
          },
          interface: {
            parseLog: (log: any) => {
              if (log === newerLog) {
                return {
                  args: {
                    origin: 31347,
                    router: originRouterBytes32,
                    owner: signerBytes32,
                    ism: ethersConstants.AddressZero,
                  },
                };
              }
              return {
                args: {
                  origin: 999999,
                  router: originRouterBytes32,
                  owner: signerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              };
            },
          },
        } as any;
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) {
            return 'anvil3';
          }
          throw new Error(`unknown domain ${domainId}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      expect((batches[0].config.submitter as any).chain).to.equal('anvil3');
      expect(provider.getLogs.callCount).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('handles whitespace-padded hex ICA event positional fields deterministically', async () => {
    const inferredIcaOwner = '0x9191919191919191919191919191919191919191';
    const destinationRouterAddress =
      '0x9292929292929292929292929292929292929292';
    const originRouterAddress = '0x9393939393939393939393939393939393939393';
    const signerBytes32 =
      `0x000000000000000000000000${SIGNER.slice(2)}` as const;
    const originRouterBytes32 =
      `0x000000000000000000000000${originRouterAddress.slice(2)}` as const;

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const olderLog = {
      topics: ['0xolder'],
      data: '0x',
      blockNumber: ' 0x700 ',
      transactionIndex: ' 0x1 ',
      logIndex: ' 0x2 ',
    };
    const newerLog = {
      topics: ['0xnewer'],
      data: '0x',
      blockNumber: ' 0X701 ',
      transactionIndex: ' 0X0 ',
      logIndex: ' 0X0 ',
    };
    const provider = {
      getLogs: sinon.stub().resolves([newerLog, olderLog]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== destinationRouterAddress.toLowerCase()) {
          throw new Error('unexpected router');
        }

        return {
          filters: {
            InterchainAccountCreated: (_accountAddress: string) => ({}),
          },
          interface: {
            parseLog: (log: any) => {
              if (log === newerLog) {
                return {
                  args: {
                    origin: 31347,
                    router: originRouterBytes32,
                    owner: signerBytes32,
                    ism: ethersConstants.AddressZero,
                  },
                };
              }
              return {
                args: {
                  origin: 999999,
                  router: originRouterBytes32,
                  owner: signerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              };
            },
          },
        } as any;
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) {
            return 'anvil3';
          }
          throw new Error(`unknown domain ${domainId}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      expect((batches[0].config.submitter as any).chain).to.equal('anvil3');
      expect(provider.getLogs.callCount).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('handles very large decimal-string ICA event positions without precision loss', async () => {
    const inferredIcaOwner = '0xa0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0';
    const destinationRouterAddress =
      '0xa1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1';
    const originRouterAddress = '0xa2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2';
    const signerBytes32 =
      `0x000000000000000000000000${SIGNER.slice(2)}` as const;
    const originRouterBytes32 =
      `0x000000000000000000000000${originRouterAddress.slice(2)}` as const;

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const olderLog = {
      topics: ['0xolder'],
      data: '0x',
      blockNumber: '900719925474099312345678',
      transactionIndex: '0',
      logIndex: '0',
    };
    const newerLog = {
      topics: ['0xnewer'],
      data: '0x',
      blockNumber: '900719925474099312345679',
      transactionIndex: '0',
      logIndex: '0',
    };
    const provider = {
      // intentionally unsorted newest-first
      getLogs: sinon.stub().resolves([newerLog, olderLog]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== destinationRouterAddress.toLowerCase()) {
          throw new Error('unexpected router');
        }

        return {
          filters: {
            InterchainAccountCreated: (_accountAddress: string) => ({}),
          },
          interface: {
            parseLog: (log: any) => {
              if (log === newerLog) {
                return {
                  args: {
                    origin: 31347,
                    router: originRouterBytes32,
                    owner: signerBytes32,
                    ism: ethersConstants.AddressZero,
                  },
                };
              }
              return {
                args: {
                  origin: 999999,
                  router: originRouterBytes32,
                  owner: signerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              };
            },
          },
        } as any;
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) {
            return 'anvil3';
          }
          throw new Error(`unknown domain ${domainId}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      expect((batches[0].config.submitter as any).chain).to.equal('anvil3');
      expect(provider.getLogs.callCount).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('ignores malformed hex-string ICA event positions during log ordering', async () => {
    const inferredIcaOwner = '0xa3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3';
    const destinationRouterAddress =
      '0xa4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4';
    const originRouterAddress = '0xa5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5';
    const signerBytes32 =
      `0x000000000000000000000000${SIGNER.slice(2)}` as const;
    const originRouterBytes32 =
      `0x000000000000000000000000${originRouterAddress.slice(2)}` as const;

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const validLog = {
      topics: ['0xvalid'],
      data: '0x',
      blockNumber: '1001',
      transactionIndex: '0',
      logIndex: '0',
    };
    const malformedHigherLog = {
      topics: ['0xmalformed-high'],
      data: '0x',
      blockNumber: '0x3ZZ',
      transactionIndex: '0',
      logIndex: '0',
    };
    const provider = {
      // malformed hex should be treated as missing position and not outrank valid log
      getLogs: sinon.stub().resolves([validLog, malformedHigherLog]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== destinationRouterAddress.toLowerCase()) {
          throw new Error('unexpected router');
        }

        return {
          filters: {
            InterchainAccountCreated: (_accountAddress: string) => ({}),
          },
          interface: {
            parseLog: (log: any) => {
              if (log === validLog) {
                return {
                  args: {
                    origin: 31347,
                    router: originRouterBytes32,
                    owner: signerBytes32,
                    ism: ethersConstants.AddressZero,
                  },
                };
              }
              return {
                args: {
                  origin: 999999,
                  router: originRouterBytes32,
                  owner: signerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              };
            },
          },
        } as any;
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) {
            return 'anvil3';
          }
          throw new Error(`unknown domain ${domainId}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      expect((batches[0].config.submitter as any).chain).to.equal('anvil3');
      expect(provider.getLogs.callCount).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('ignores empty-hex-prefix ICA event positions during log ordering', async () => {
    const inferredIcaOwner = '0xa6a6a6a6a6a6a6a6a6a6a6a6a6a6a6a6a6a6a6a6';
    const destinationRouterAddress =
      '0xa7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a7';
    const originRouterAddress = '0xa8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8';
    const signerBytes32 =
      `0x000000000000000000000000${SIGNER.slice(2)}` as const;
    const originRouterBytes32 =
      `0x000000000000000000000000${originRouterAddress.slice(2)}` as const;

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const validLog = {
      topics: ['0xvalid'],
      data: '0x',
      blockNumber: '1002',
      transactionIndex: '0',
      logIndex: '0',
    };
    const malformedHexPrefixLog = {
      topics: ['0xmalformed-prefix'],
      data: '0x',
      blockNumber: '0x',
      transactionIndex: '0',
      logIndex: '0',
    };
    const provider = {
      // empty hex prefix must be ignored instead of treated as index zero
      getLogs: sinon.stub().resolves([validLog, malformedHexPrefixLog]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== destinationRouterAddress.toLowerCase()) {
          throw new Error('unexpected router');
        }

        return {
          filters: {
            InterchainAccountCreated: (_accountAddress: string) => ({}),
          },
          interface: {
            parseLog: (log: any) => {
              if (log === validLog) {
                return {
                  args: {
                    origin: 31347,
                    router: originRouterBytes32,
                    owner: signerBytes32,
                    ism: ethersConstants.AddressZero,
                  },
                };
              }
              return {
                args: {
                  origin: 999999,
                  router: originRouterBytes32,
                  owner: signerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              };
            },
          },
        } as any;
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) {
            return 'anvil3';
          }
          throw new Error(`unknown domain ${domainId}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      expect((batches[0].config.submitter as any).chain).to.equal('anvil3');
      expect(provider.getLogs.callCount).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('ignores non-integer string ICA event positions during log ordering', async () => {
    const inferredIcaOwner = '0x8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e';
    const destinationRouterAddress =
      '0x9090909090909090909090909090909090909090';
    const originRouterAddress = '0x9191919191919191919191919191919191919191';
    const signerBytes32 =
      `0x000000000000000000000000${SIGNER.slice(2)}` as const;
    const originRouterBytes32 =
      `0x000000000000000000000000${originRouterAddress.slice(2)}` as const;

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const validLog = {
      topics: ['0xvalid'],
      data: '0x',
      blockNumber: '1000',
      transactionIndex: '0',
      logIndex: '0',
    };
    const malformedHighLog = {
      topics: ['0xmalformed-high'],
      data: '0x',
      blockNumber: '9999.9',
      transactionIndex: '0',
      logIndex: '0',
    };
    const provider = {
      // malformed log appears later in raw response and should not outrank valid one
      getLogs: sinon.stub().resolves([validLog, malformedHighLog]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== destinationRouterAddress.toLowerCase()) {
          throw new Error('unexpected router');
        }

        return {
          filters: {
            InterchainAccountCreated: (_accountAddress: string) => ({}),
          },
          interface: {
            parseLog: (log: any) => {
              if (log === validLog) {
                return {
                  args: {
                    origin: 31347,
                    router: originRouterBytes32,
                    owner: signerBytes32,
                    ism: ethersConstants.AddressZero,
                  },
                };
              }
              return {
                args: {
                  origin: 999999,
                  router: originRouterBytes32,
                  owner: signerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              };
            },
          },
        } as any;
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) {
            return 'anvil3';
          }
          throw new Error(`unknown domain ${domainId}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      expect((batches[0].config.submitter as any).chain).to.equal('anvil3');
      expect(provider.getLogs.callCount).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('ignores object-default-string ICA event positions during log ordering', async () => {
    const inferredIcaOwner = '0xdededededededededededededededededededede';
    const destinationRouterAddress =
      '0xdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdf';
    const originRouterAddress = '0xe0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0';
    const signerBytes32 =
      `0x000000000000000000000000${SIGNER.slice(2)}` as const;
    const originRouterBytes32 =
      `0x000000000000000000000000${originRouterAddress.slice(2)}` as const;

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const validLog = {
      topics: ['0xvalid'],
      data: '0x',
      blockNumber: '1032',
      transactionIndex: '0',
      logIndex: '0',
    };
    const malformedObjectDefaultStringLog = {
      topics: ['0xmalformed-object-default-string'],
      data: '0x',
      blockNumber: '[object Object]',
      transactionIndex: '0',
      logIndex: '0',
    };
    const provider = {
      getLogs: sinon
        .stub()
        .resolves([validLog, malformedObjectDefaultStringLog]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== destinationRouterAddress.toLowerCase()) {
          throw new Error('unexpected router');
        }

        return {
          filters: {
            InterchainAccountCreated: (_accountAddress: string) => ({}),
          },
          interface: {
            parseLog: (log: any) => {
              if (log === validLog) {
                return {
                  args: {
                    origin: 31347,
                    router: originRouterBytes32,
                    owner: signerBytes32,
                    ism: ethersConstants.AddressZero,
                  },
                };
              }
              return {
                args: {
                  origin: 999999,
                  router: originRouterBytes32,
                  owner: signerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              };
            },
          },
        } as any;
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) {
            return 'anvil3';
          }
          throw new Error(`unknown domain ${domainId}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      expect((batches[0].config.submitter as any).chain).to.equal('anvil3');
      expect(provider.getLogs.callCount).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('ignores whitespace-padded object-default-string ICA event positions during log ordering', async () => {
    const inferredIcaOwner = '0xe3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3';
    const destinationRouterAddress =
      '0xe4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4';
    const originRouterAddress = '0xe5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5';
    const signerBytes32 =
      `0x000000000000000000000000${SIGNER.slice(2)}` as const;
    const originRouterBytes32 =
      `0x000000000000000000000000${originRouterAddress.slice(2)}` as const;

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const validLog = {
      topics: ['0xvalid'],
      data: '0x',
      blockNumber: '1034',
      transactionIndex: '0',
      logIndex: '0',
    };
    const malformedWhitespacePaddedObjectDefaultStringLog = {
      topics: ['0xmalformed-whitespace-padded-object-default-string'],
      data: '0x',
      blockNumber: '   [object Object]   ',
      transactionIndex: '0',
      logIndex: '0',
    };
    const provider = {
      getLogs: sinon
        .stub()
        .resolves([validLog, malformedWhitespacePaddedObjectDefaultStringLog]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== destinationRouterAddress.toLowerCase()) {
          throw new Error('unexpected router');
        }

        return {
          filters: {
            InterchainAccountCreated: (_accountAddress: string) => ({}),
          },
          interface: {
            parseLog: (log: any) => {
              if (log === validLog) {
                return {
                  args: {
                    origin: 31347,
                    router: originRouterBytes32,
                    owner: signerBytes32,
                    ism: ethersConstants.AddressZero,
                  },
                };
              }
              return {
                args: {
                  origin: 999999,
                  router: originRouterBytes32,
                  owner: signerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              };
            },
          },
        } as any;
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) {
            return 'anvil3';
          }
          throw new Error(`unknown domain ${domainId}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      expect((batches[0].config.submitter as any).chain).to.equal('anvil3');
      expect(provider.getLogs.callCount).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('ignores plus-prefixed decimal-string ICA event positions during log ordering', async () => {
    const inferredIcaOwner = '0xa9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9';
    const destinationRouterAddress =
      '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa';
    const originRouterAddress = '0xabababababababababababababababababababab';
    const signerBytes32 =
      `0x000000000000000000000000${SIGNER.slice(2)}` as const;
    const originRouterBytes32 =
      `0x000000000000000000000000${originRouterAddress.slice(2)}` as const;

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const validLog = {
      topics: ['0xvalid'],
      data: '0x',
      blockNumber: '1003',
      transactionIndex: '0',
      logIndex: '0',
    };
    const malformedPlusLog = {
      topics: ['0xmalformed-plus'],
      data: '0x',
      blockNumber: '+9999',
      transactionIndex: '0',
      logIndex: '0',
    };
    const provider = {
      // plus-prefixed decimal should be rejected by normalization
      getLogs: sinon.stub().resolves([validLog, malformedPlusLog]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== destinationRouterAddress.toLowerCase()) {
          throw new Error('unexpected router');
        }

        return {
          filters: {
            InterchainAccountCreated: (_accountAddress: string) => ({}),
          },
          interface: {
            parseLog: (log: any) => {
              if (log === validLog) {
                return {
                  args: {
                    origin: 31347,
                    router: originRouterBytes32,
                    owner: signerBytes32,
                    ism: ethersConstants.AddressZero,
                  },
                };
              }
              return {
                args: {
                  origin: 999999,
                  router: originRouterBytes32,
                  owner: signerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              };
            },
          },
        } as any;
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) {
            return 'anvil3';
          }
          throw new Error(`unknown domain ${domainId}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      expect((batches[0].config.submitter as any).chain).to.equal('anvil3');
      expect(provider.getLogs.callCount).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('ignores plus-prefixed hex-string ICA event positions during log ordering', async () => {
    const inferredIcaOwner = '0xc5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5';
    const destinationRouterAddress =
      '0xc6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6';
    const originRouterAddress = '0xc7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7';
    const signerBytes32 =
      `0x000000000000000000000000${SIGNER.slice(2)}` as const;
    const originRouterBytes32 =
      `0x000000000000000000000000${originRouterAddress.slice(2)}` as const;

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const validLog = {
      topics: ['0xvalid'],
      data: '0x',
      blockNumber: '1024',
      transactionIndex: '0',
      logIndex: '0',
    };
    const malformedPlusHexLog = {
      topics: ['0xmalformed-plus-hex'],
      data: '0x',
      blockNumber: '+0x270f',
      transactionIndex: '0',
      logIndex: '0',
    };
    const malformedUppercasePlusHexLog = {
      topics: ['0xmalformed-uppercase-plus-hex'],
      data: '0x',
      blockNumber: '+0X270f',
      transactionIndex: '0',
      logIndex: '0',
    };
    const malformedRawBoundaryPlusHexLog = {
      topics: ['0xmalformed-raw-boundary-plus-hex'],
      data: '0x',
      blockNumber: `+0x${'0'.repeat(4093)}`,
      transactionIndex: '0',
      logIndex: '0',
    };
    const malformedRawPlusOnePlusHexLog = {
      topics: ['0xmalformed-raw-plus-one-plus-hex'],
      data: '0x',
      blockNumber: `+0x${'0'.repeat(4094)}`,
      transactionIndex: '0',
      logIndex: '0',
    };
    const provider = {
      getLogs: sinon
        .stub()
        .resolves([
          validLog,
          malformedPlusHexLog,
          malformedUppercasePlusHexLog,
          malformedRawBoundaryPlusHexLog,
          malformedRawPlusOnePlusHexLog,
        ]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== destinationRouterAddress.toLowerCase()) {
          throw new Error('unexpected router');
        }

        return {
          filters: {
            InterchainAccountCreated: (_accountAddress: string) => ({}),
          },
          interface: {
            parseLog: (log: any) => {
              if (log === validLog) {
                return {
                  args: {
                    origin: 31347,
                    router: originRouterBytes32,
                    owner: signerBytes32,
                    ism: ethersConstants.AddressZero,
                  },
                };
              }
              return {
                args: {
                  origin: 999999,
                  router: originRouterBytes32,
                  owner: signerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              };
            },
          },
        } as any;
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) {
            return 'anvil3';
          }
          throw new Error(`unknown domain ${domainId}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      expect((batches[0].config.submitter as any).chain).to.equal('anvil3');
      expect(provider.getLogs.callCount).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('ignores minus-prefixed hex-string ICA event positions during log ordering', async () => {
    const inferredIcaOwner = '0xc8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8';
    const destinationRouterAddress =
      '0xc9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9';
    const originRouterAddress = '0xcacacacacacacacacacacacacacacacacacacaca';
    const signerBytes32 =
      `0x000000000000000000000000${SIGNER.slice(2)}` as const;
    const originRouterBytes32 =
      `0x000000000000000000000000${originRouterAddress.slice(2)}` as const;

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const validLog = {
      topics: ['0xvalid'],
      data: '0x',
      blockNumber: '1025',
      transactionIndex: '0',
      logIndex: '0',
    };
    const malformedMinusHexLog = {
      topics: ['0xmalformed-minus-hex'],
      data: '0x',
      blockNumber: '-0x270f',
      transactionIndex: '0',
      logIndex: '0',
    };
    const malformedUppercaseMinusHexLog = {
      topics: ['0xmalformed-uppercase-minus-hex'],
      data: '0x',
      blockNumber: '-0X270f',
      transactionIndex: '0',
      logIndex: '0',
    };
    const malformedRawBoundaryMinusHexLog = {
      topics: ['0xmalformed-raw-boundary-minus-hex'],
      data: '0x',
      blockNumber: `-0x${'0'.repeat(4093)}`,
      transactionIndex: '0',
      logIndex: '0',
    };
    const malformedRawPlusOneMinusHexLog = {
      topics: ['0xmalformed-raw-plus-one-minus-hex'],
      data: '0x',
      blockNumber: `-0x${'0'.repeat(4094)}`,
      transactionIndex: '0',
      logIndex: '0',
    };
    const provider = {
      getLogs: sinon
        .stub()
        .resolves([
          validLog,
          malformedMinusHexLog,
          malformedUppercaseMinusHexLog,
          malformedRawBoundaryMinusHexLog,
          malformedRawPlusOneMinusHexLog,
        ]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== destinationRouterAddress.toLowerCase()) {
          throw new Error('unexpected router');
        }

        return {
          filters: {
            InterchainAccountCreated: (_accountAddress: string) => ({}),
          },
          interface: {
            parseLog: (log: any) => {
              if (log === validLog) {
                return {
                  args: {
                    origin: 31347,
                    router: originRouterBytes32,
                    owner: signerBytes32,
                    ism: ethersConstants.AddressZero,
                  },
                };
              }
              return {
                args: {
                  origin: 999999,
                  router: originRouterBytes32,
                  owner: signerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              };
            },
          },
        } as any;
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) {
            return 'anvil3';
          }
          throw new Error(`unknown domain ${domainId}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      expect((batches[0].config.submitter as any).chain).to.equal('anvil3');
      expect(provider.getLogs.callCount).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('ignores signed empty-hex-prefix ICA event positions during log ordering', async () => {
    const inferredIcaOwner = '0xcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcf';
    const destinationRouterAddress =
      '0xd0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0';
    const originRouterAddress = '0xd1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1';
    const signerBytes32 =
      `0x000000000000000000000000${SIGNER.slice(2)}` as const;
    const originRouterBytes32 =
      `0x000000000000000000000000${originRouterAddress.slice(2)}` as const;

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const validLog = {
      topics: ['0xvalid'],
      data: '0x',
      blockNumber: '1028',
      transactionIndex: '0',
      logIndex: '0',
    };
    const malformedPlusEmptyHexLog = {
      topics: ['0xmalformed-plus-empty-hex'],
      data: '0x',
      blockNumber: '+0x',
      transactionIndex: '0',
      logIndex: '0',
    };
    const malformedMinusEmptyHexLog = {
      topics: ['0xmalformed-minus-empty-hex'],
      data: '0x',
      blockNumber: '-0x',
      transactionIndex: '0',
      logIndex: '0',
    };
    const malformedUppercasePlusEmptyHexLog = {
      topics: ['0xmalformed-uppercase-plus-empty-hex'],
      data: '0x',
      blockNumber: '+0X',
      transactionIndex: '0',
      logIndex: '0',
    };
    const malformedUppercaseMinusEmptyHexLog = {
      topics: ['0xmalformed-uppercase-minus-empty-hex'],
      data: '0x',
      blockNumber: '-0X',
      transactionIndex: '0',
      logIndex: '0',
    };
    const provider = {
      getLogs: sinon
        .stub()
        .resolves([
          validLog,
          malformedPlusEmptyHexLog,
          malformedMinusEmptyHexLog,
          malformedUppercasePlusEmptyHexLog,
          malformedUppercaseMinusEmptyHexLog,
        ]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== destinationRouterAddress.toLowerCase()) {
          throw new Error('unexpected router');
        }

        return {
          filters: {
            InterchainAccountCreated: (_accountAddress: string) => ({}),
          },
          interface: {
            parseLog: (log: any) => {
              if (log === validLog) {
                return {
                  args: {
                    origin: 31347,
                    router: originRouterBytes32,
                    owner: signerBytes32,
                    ism: ethersConstants.AddressZero,
                  },
                };
              }
              return {
                args: {
                  origin: 999999,
                  router: originRouterBytes32,
                  owner: signerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              };
            },
          },
        } as any;
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) {
            return 'anvil3';
          }
          throw new Error(`unknown domain ${domainId}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      expect((batches[0].config.submitter as any).chain).to.equal('anvil3');
      expect(provider.getLogs.callCount).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('ignores raw-length-boundary plus-prefixed ICA event positions during ordering', async () => {
    const inferredIcaOwner = '0xb1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1';
    const destinationRouterAddress =
      '0xb2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2';
    const originRouterAddress = '0xb3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3';
    const signerBytes32 =
      `0x000000000000000000000000${SIGNER.slice(2)}` as const;
    const originRouterBytes32 =
      `0x000000000000000000000000${originRouterAddress.slice(2)}` as const;

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const validLog = {
      topics: ['0xvalid'],
      data: '0x',
      blockNumber: '1016',
      transactionIndex: '0',
      logIndex: '0',
    };
    const malformedRawBoundaryLog = {
      topics: ['0xmalformed-raw-boundary-plus'],
      data: '0x',
      blockNumber: `+${'0'.repeat(4095)}`,
      transactionIndex: '0',
      logIndex: '0',
    };
    const provider = {
      getLogs: sinon.stub().resolves([validLog, malformedRawBoundaryLog]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== destinationRouterAddress.toLowerCase()) {
          throw new Error('unexpected router');
        }

        return {
          filters: {
            InterchainAccountCreated: (_accountAddress: string) => ({}),
          },
          interface: {
            parseLog: (log: any) => {
              if (log === validLog) {
                return {
                  args: {
                    origin: 31347,
                    router: originRouterBytes32,
                    owner: signerBytes32,
                    ism: ethersConstants.AddressZero,
                  },
                };
              }
              return {
                args: {
                  origin: 999999,
                  router: originRouterBytes32,
                  owner: signerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              };
            },
          },
        } as any;
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) {
            return 'anvil3';
          }
          throw new Error(`unknown domain ${domainId}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      expect((batches[0].config.submitter as any).chain).to.equal('anvil3');
      expect(provider.getLogs.callCount).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('ignores raw-length-plus-one plus-prefixed ICA event positions during ordering', async () => {
    const inferredIcaOwner = '0xb4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4';
    const destinationRouterAddress =
      '0xb5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5';
    const originRouterAddress = '0xb6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6';
    const signerBytes32 =
      `0x000000000000000000000000${SIGNER.slice(2)}` as const;
    const originRouterBytes32 =
      `0x000000000000000000000000${originRouterAddress.slice(2)}` as const;

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const validLog = {
      topics: ['0xvalid'],
      data: '0x',
      blockNumber: '1017',
      transactionIndex: '0',
      logIndex: '0',
    };
    const malformedRawPlusOneLog = {
      topics: ['0xmalformed-raw-plus-one-plus'],
      data: '0x',
      blockNumber: `+${'0'.repeat(4096)}`,
      transactionIndex: '0',
      logIndex: '0',
    };
    const provider = {
      getLogs: sinon.stub().resolves([validLog, malformedRawPlusOneLog]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== destinationRouterAddress.toLowerCase()) {
          throw new Error('unexpected router');
        }

        return {
          filters: {
            InterchainAccountCreated: (_accountAddress: string) => ({}),
          },
          interface: {
            parseLog: (log: any) => {
              if (log === validLog) {
                return {
                  args: {
                    origin: 31347,
                    router: originRouterBytes32,
                    owner: signerBytes32,
                    ism: ethersConstants.AddressZero,
                  },
                };
              }
              return {
                args: {
                  origin: 999999,
                  router: originRouterBytes32,
                  owner: signerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              };
            },
          },
        } as any;
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) {
            return 'anvil3';
          }
          throw new Error(`unknown domain ${domainId}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      expect((batches[0].config.submitter as any).chain).to.equal('anvil3');
      expect(provider.getLogs.callCount).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('ignores raw-length-boundary minus-prefixed ICA event positions during ordering', async () => {
    const inferredIcaOwner = '0xbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb';
    const destinationRouterAddress =
      '0xbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbc';
    const originRouterAddress = '0xbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbd';
    const signerBytes32 =
      `0x000000000000000000000000${SIGNER.slice(2)}` as const;
    const originRouterBytes32 =
      `0x000000000000000000000000${originRouterAddress.slice(2)}` as const;

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const validLog = {
      topics: ['0xvalid'],
      data: '0x',
      blockNumber: '1020',
      transactionIndex: '0',
      logIndex: '0',
    };
    const malformedRawBoundaryLog = {
      topics: ['0xmalformed-raw-boundary-minus'],
      data: '0x',
      blockNumber: `-${'0'.repeat(4095)}`,
      transactionIndex: '0',
      logIndex: '0',
    };
    const provider = {
      getLogs: sinon.stub().resolves([validLog, malformedRawBoundaryLog]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== destinationRouterAddress.toLowerCase()) {
          throw new Error('unexpected router');
        }

        return {
          filters: {
            InterchainAccountCreated: (_accountAddress: string) => ({}),
          },
          interface: {
            parseLog: (log: any) => {
              if (log === validLog) {
                return {
                  args: {
                    origin: 31347,
                    router: originRouterBytes32,
                    owner: signerBytes32,
                    ism: ethersConstants.AddressZero,
                  },
                };
              }
              return {
                args: {
                  origin: 999999,
                  router: originRouterBytes32,
                  owner: signerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              };
            },
          },
        } as any;
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) {
            return 'anvil3';
          }
          throw new Error(`unknown domain ${domainId}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      expect((batches[0].config.submitter as any).chain).to.equal('anvil3');
      expect(provider.getLogs.callCount).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('ignores raw-length-plus-one minus-prefixed ICA event positions during ordering', async () => {
    const inferredIcaOwner = '0xbebebebebebebebebebebebebebebebebebebebe';
    const destinationRouterAddress =
      '0xbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbf';
    const originRouterAddress = '0xc0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0';
    const signerBytes32 =
      `0x000000000000000000000000${SIGNER.slice(2)}` as const;
    const originRouterBytes32 =
      `0x000000000000000000000000${originRouterAddress.slice(2)}` as const;

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const validLog = {
      topics: ['0xvalid'],
      data: '0x',
      blockNumber: '1021',
      transactionIndex: '0',
      logIndex: '0',
    };
    const malformedRawPlusOneLog = {
      topics: ['0xmalformed-raw-plus-one-minus'],
      data: '0x',
      blockNumber: `-${'0'.repeat(4096)}`,
      transactionIndex: '0',
      logIndex: '0',
    };
    const provider = {
      getLogs: sinon.stub().resolves([validLog, malformedRawPlusOneLog]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== destinationRouterAddress.toLowerCase()) {
          throw new Error('unexpected router');
        }

        return {
          filters: {
            InterchainAccountCreated: (_accountAddress: string) => ({}),
          },
          interface: {
            parseLog: (log: any) => {
              if (log === validLog) {
                return {
                  args: {
                    origin: 31347,
                    router: originRouterBytes32,
                    owner: signerBytes32,
                    ism: ethersConstants.AddressZero,
                  },
                };
              }
              return {
                args: {
                  origin: 999999,
                  router: originRouterBytes32,
                  owner: signerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              };
            },
          },
        } as any;
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) {
            return 'anvil3';
          }
          throw new Error(`unknown domain ${domainId}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      expect((batches[0].config.submitter as any).chain).to.equal('anvil3');
      expect(provider.getLogs.callCount).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('ignores overlong hex-string ICA event positions during log ordering', async () => {
    const inferredIcaOwner = '0xacacacacacacacacacacacacacacacacacacacac';
    const destinationRouterAddress =
      '0xadadadadadadadadadadadadadadadadadadadad';
    const originRouterAddress = '0xaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeae';
    const signerBytes32 =
      `0x000000000000000000000000${SIGNER.slice(2)}` as const;
    const originRouterBytes32 =
      `0x000000000000000000000000${originRouterAddress.slice(2)}` as const;

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const validLog = {
      topics: ['0xvalid'],
      data: '0x',
      blockNumber: '1004',
      transactionIndex: '0',
      logIndex: '0',
    };
    const malformedOverlongLog = {
      topics: ['0xmalformed-overlong'],
      data: '0x',
      blockNumber: `0x${'f'.repeat(300)}`,
      transactionIndex: '0',
      logIndex: '0',
    };
    const provider = {
      // overlong numeric strings should be rejected to avoid expensive bigint parsing
      getLogs: sinon.stub().resolves([validLog, malformedOverlongLog]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== destinationRouterAddress.toLowerCase()) {
          throw new Error('unexpected router');
        }

        return {
          filters: {
            InterchainAccountCreated: (_accountAddress: string) => ({}),
          },
          interface: {
            parseLog: (log: any) => {
              if (log === validLog) {
                return {
                  args: {
                    origin: 31347,
                    router: originRouterBytes32,
                    owner: signerBytes32,
                    ism: ethersConstants.AddressZero,
                  },
                };
              }
              return {
                args: {
                  origin: 999999,
                  router: originRouterBytes32,
                  owner: signerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              };
            },
          },
        } as any;
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) {
            return 'anvil3';
          }
          throw new Error(`unknown domain ${domainId}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      expect((batches[0].config.submitter as any).chain).to.equal('anvil3');
      expect(provider.getLogs.callCount).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('accepts overlong zero-padded hex ICA event positions deterministically', async () => {
    const inferredIcaOwner = '0xbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb';
    const destinationRouterAddress =
      '0xbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbc';
    const originRouterAddress = '0xbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbd';
    const signerBytes32 =
      `0x000000000000000000000000${SIGNER.slice(2)}` as const;
    const originRouterBytes32 =
      `0x000000000000000000000000${originRouterAddress.slice(2)}` as const;

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const higherLog = {
      topics: ['0xhigher'],
      data: '0x',
      blockNumber: `0x${'0'.repeat(300)}2`,
      transactionIndex: '0',
      logIndex: '0',
    };
    const lowerLog = {
      topics: ['0xlower'],
      data: '0x',
      blockNumber: `0x${'0'.repeat(300)}1`,
      transactionIndex: '0',
      logIndex: '0',
    };
    const provider = {
      getLogs: sinon.stub().resolves([lowerLog, higherLog]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== destinationRouterAddress.toLowerCase()) {
          throw new Error('unexpected router');
        }

        return {
          filters: {
            InterchainAccountCreated: (_accountAddress: string) => ({}),
          },
          interface: {
            parseLog: (log: any) => {
              if (log === higherLog) {
                return {
                  args: {
                    origin: 31347,
                    router: originRouterBytes32,
                    owner: signerBytes32,
                    ism: ethersConstants.AddressZero,
                  },
                };
              }
              return {
                args: {
                  origin: 999999,
                  router: originRouterBytes32,
                  owner: signerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              };
            },
          },
        } as any;
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) {
            return 'anvil3';
          }
          throw new Error(`unknown domain ${domainId}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      expect((batches[0].config.submitter as any).chain).to.equal('anvil3');
      expect(provider.getLogs.callCount).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('accepts overlong uppercase-zero-padded hex ICA event positions deterministically', async () => {
    const inferredIcaOwner = '0xd0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0';
    const destinationRouterAddress =
      '0xd1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1';
    const originRouterAddress = '0xd2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2';
    const signerBytes32 =
      `0x000000000000000000000000${SIGNER.slice(2)}` as const;
    const originRouterBytes32 =
      `0x000000000000000000000000${originRouterAddress.slice(2)}` as const;

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const higherLog = {
      topics: ['0xhigher'],
      data: '0x',
      blockNumber: `0X${'0'.repeat(300)}A`,
      transactionIndex: '0',
      logIndex: '0',
    };
    const lowerLog = {
      topics: ['0xlower'],
      data: '0x',
      blockNumber: `0X${'0'.repeat(300)}9`,
      transactionIndex: '0',
      logIndex: '0',
    };
    const provider = {
      getLogs: sinon.stub().resolves([lowerLog, higherLog]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== destinationRouterAddress.toLowerCase()) {
          throw new Error('unexpected router');
        }

        return {
          filters: {
            InterchainAccountCreated: (_accountAddress: string) => ({}),
          },
          interface: {
            parseLog: (log: any) => {
              if (log === higherLog) {
                return {
                  args: {
                    origin: 31347,
                    router: originRouterBytes32,
                    owner: signerBytes32,
                    ism: ethersConstants.AddressZero,
                  },
                };
              }
              return {
                args: {
                  origin: 999999,
                  router: originRouterBytes32,
                  owner: signerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              };
            },
          },
        } as any;
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) {
            return 'anvil3';
          }
          throw new Error(`unknown domain ${domainId}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      expect((batches[0].config.submitter as any).chain).to.equal('anvil3');
      expect(provider.getLogs.callCount).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('ignores excessively long raw hex ICA event positions during log ordering', async () => {
    const inferredIcaOwner = '0xc1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1';
    const destinationRouterAddress =
      '0xc2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2';
    const originRouterAddress = '0xc3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3';
    const signerBytes32 =
      `0x000000000000000000000000${SIGNER.slice(2)}` as const;
    const originRouterBytes32 =
      `0x000000000000000000000000${originRouterAddress.slice(2)}` as const;

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const validLog = {
      topics: ['0xvalid'],
      data: '0x',
      blockNumber: '1007',
      transactionIndex: '0',
      logIndex: '0',
    };
    const malformedRawLengthLog = {
      topics: ['0xmalformed-raw-length'],
      data: '0x',
      blockNumber: `0x${'0'.repeat(5000)}2`,
      transactionIndex: '0',
      logIndex: '0',
    };
    const provider = {
      getLogs: sinon.stub().resolves([validLog, malformedRawLengthLog]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== destinationRouterAddress.toLowerCase()) {
          throw new Error('unexpected router');
        }

        return {
          filters: {
            InterchainAccountCreated: (_accountAddress: string) => ({}),
          },
          interface: {
            parseLog: (log: any) => {
              if (log === validLog) {
                return {
                  args: {
                    origin: 31347,
                    router: originRouterBytes32,
                    owner: signerBytes32,
                    ism: ethersConstants.AddressZero,
                  },
                };
              }
              return {
                args: {
                  origin: 999999,
                  router: originRouterBytes32,
                  owner: signerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              };
            },
          },
        } as any;
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) {
            return 'anvil3';
          }
          throw new Error(`unknown domain ${domainId}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      expect((batches[0].config.submitter as any).chain).to.equal('anvil3');
      expect(provider.getLogs.callCount).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('accepts raw-length-boundary zero-padded hex ICA event positions deterministically', async () => {
    const inferredIcaOwner = '0xdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdc';
    const destinationRouterAddress =
      '0xdddddddddddddddddddddddddddddddddddddddd';
    const originRouterAddress = '0xdededededededededededededededededededede';
    const signerBytes32 =
      `0x000000000000000000000000${SIGNER.slice(2)}` as const;
    const originRouterBytes32 =
      `0x000000000000000000000000${originRouterAddress.slice(2)}` as const;

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const higherLog = {
      topics: ['0xhigher'],
      data: '0x',
      blockNumber: `0x${'0'.repeat(4093)}2`,
      transactionIndex: '0',
      logIndex: '0',
    };
    const lowerLog = {
      topics: ['0xlower'],
      data: '0x',
      blockNumber: `0x${'0'.repeat(4093)}1`,
      transactionIndex: '0',
      logIndex: '0',
    };
    const provider = {
      getLogs: sinon.stub().resolves([lowerLog, higherLog]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== destinationRouterAddress.toLowerCase()) {
          throw new Error('unexpected router');
        }

        return {
          filters: {
            InterchainAccountCreated: (_accountAddress: string) => ({}),
          },
          interface: {
            parseLog: (log: any) => {
              if (log === higherLog) {
                return {
                  args: {
                    origin: 31347,
                    router: originRouterBytes32,
                    owner: signerBytes32,
                    ism: ethersConstants.AddressZero,
                  },
                };
              }
              return {
                args: {
                  origin: 999999,
                  router: originRouterBytes32,
                  owner: signerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              };
            },
          },
        } as any;
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) {
            return 'anvil3';
          }
          throw new Error(`unknown domain ${domainId}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      expect((batches[0].config.submitter as any).chain).to.equal('anvil3');
      expect(provider.getLogs.callCount).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('accepts raw-length-boundary uppercase-zero-padded hex ICA event positions deterministically', async () => {
    const inferredIcaOwner = '0xe2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2';
    const destinationRouterAddress =
      '0xe3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3';
    const originRouterAddress = '0xe4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4';
    const signerBytes32 =
      `0x000000000000000000000000${SIGNER.slice(2)}` as const;
    const originRouterBytes32 =
      `0x000000000000000000000000${originRouterAddress.slice(2)}` as const;

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const higherLog = {
      topics: ['0xhigher'],
      data: '0x',
      blockNumber: `0X${'0'.repeat(4093)}A`,
      transactionIndex: '0',
      logIndex: '0',
    };
    const lowerLog = {
      topics: ['0xlower'],
      data: '0x',
      blockNumber: `0X${'0'.repeat(4093)}9`,
      transactionIndex: '0',
      logIndex: '0',
    };
    const provider = {
      getLogs: sinon.stub().resolves([lowerLog, higherLog]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== destinationRouterAddress.toLowerCase()) {
          throw new Error('unexpected router');
        }

        return {
          filters: {
            InterchainAccountCreated: (_accountAddress: string) => ({}),
          },
          interface: {
            parseLog: (log: any) => {
              if (log === higherLog) {
                return {
                  args: {
                    origin: 31347,
                    router: originRouterBytes32,
                    owner: signerBytes32,
                    ism: ethersConstants.AddressZero,
                  },
                };
              }
              return {
                args: {
                  origin: 999999,
                  router: originRouterBytes32,
                  owner: signerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              };
            },
          },
        } as any;
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) {
            return 'anvil3';
          }
          throw new Error(`unknown domain ${domainId}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      expect((batches[0].config.submitter as any).chain).to.equal('anvil3');
      expect(provider.getLogs.callCount).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('ignores raw-length-plus-one zero-padded hex ICA event positions during ordering', async () => {
    const inferredIcaOwner = '0xdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdf';
    const destinationRouterAddress =
      '0xe0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0';
    const originRouterAddress = '0xe1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1';
    const signerBytes32 =
      `0x000000000000000000000000${SIGNER.slice(2)}` as const;
    const originRouterBytes32 =
      `0x000000000000000000000000${originRouterAddress.slice(2)}` as const;

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const validLog = {
      topics: ['0xvalid'],
      data: '0x',
      blockNumber: '1012',
      transactionIndex: '0',
      logIndex: '0',
    };
    const malformedBoundaryPlusOneLog = {
      topics: ['0xmalformed-raw-plus-one-hex'],
      data: '0x',
      blockNumber: `0x${'0'.repeat(4094)}1`,
      transactionIndex: '0',
      logIndex: '0',
    };
    const provider = {
      getLogs: sinon.stub().resolves([validLog, malformedBoundaryPlusOneLog]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== destinationRouterAddress.toLowerCase()) {
          throw new Error('unexpected router');
        }

        return {
          filters: {
            InterchainAccountCreated: (_accountAddress: string) => ({}),
          },
          interface: {
            parseLog: (log: any) => {
              if (log === validLog) {
                return {
                  args: {
                    origin: 31347,
                    router: originRouterBytes32,
                    owner: signerBytes32,
                    ism: ethersConstants.AddressZero,
                  },
                };
              }
              return {
                args: {
                  origin: 999999,
                  router: originRouterBytes32,
                  owner: signerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              };
            },
          },
        } as any;
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) {
            return 'anvil3';
          }
          throw new Error(`unknown domain ${domainId}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      expect((batches[0].config.submitter as any).chain).to.equal('anvil3');
      expect(provider.getLogs.callCount).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('ignores raw-length-plus-one uppercase-zero-padded hex ICA event positions during ordering', async () => {
    const inferredIcaOwner = '0xe5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5';
    const destinationRouterAddress =
      '0xe6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6';
    const originRouterAddress = '0xe7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7';
    const signerBytes32 =
      `0x000000000000000000000000${SIGNER.slice(2)}` as const;
    const originRouterBytes32 =
      `0x000000000000000000000000${originRouterAddress.slice(2)}` as const;

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const validLog = {
      topics: ['0xvalid'],
      data: '0x',
      blockNumber: '1013',
      transactionIndex: '0',
      logIndex: '0',
    };
    const malformedBoundaryPlusOneLog = {
      topics: ['0xmalformed-raw-plus-one-uppercase-hex'],
      data: '0x',
      blockNumber: `0X${'0'.repeat(4094)}1`,
      transactionIndex: '0',
      logIndex: '0',
    };
    const provider = {
      getLogs: sinon.stub().resolves([validLog, malformedBoundaryPlusOneLog]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== destinationRouterAddress.toLowerCase()) {
          throw new Error('unexpected router');
        }

        return {
          filters: {
            InterchainAccountCreated: (_accountAddress: string) => ({}),
          },
          interface: {
            parseLog: (log: any) => {
              if (log === validLog) {
                return {
                  args: {
                    origin: 31347,
                    router: originRouterBytes32,
                    owner: signerBytes32,
                    ism: ethersConstants.AddressZero,
                  },
                };
              }
              return {
                args: {
                  origin: 999999,
                  router: originRouterBytes32,
                  owner: signerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              };
            },
          },
        } as any;
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) {
            return 'anvil3';
          }
          throw new Error(`unknown domain ${domainId}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      expect((batches[0].config.submitter as any).chain).to.equal('anvil3');
      expect(provider.getLogs.callCount).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('ignores excessively long raw whitespace-padded ICA event positions during ordering', async () => {
    const inferredIcaOwner = '0xc7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7';
    const destinationRouterAddress =
      '0xc8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8';
    const originRouterAddress = '0xc9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9';
    const signerBytes32 =
      `0x000000000000000000000000${SIGNER.slice(2)}` as const;
    const originRouterBytes32 =
      `0x000000000000000000000000${originRouterAddress.slice(2)}` as const;

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const validLog = {
      topics: ['0xvalid'],
      data: '0x',
      blockNumber: '1009',
      transactionIndex: '0',
      logIndex: '0',
    };
    const malformedRawWhitespaceLog = {
      topics: ['0xmalformed-raw-whitespace'],
      data: '0x',
      blockNumber: `${' '.repeat(5000)}9999`,
      transactionIndex: '0',
      logIndex: '0',
    };
    const provider = {
      getLogs: sinon.stub().resolves([validLog, malformedRawWhitespaceLog]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== destinationRouterAddress.toLowerCase()) {
          throw new Error('unexpected router');
        }

        return {
          filters: {
            InterchainAccountCreated: (_accountAddress: string) => ({}),
          },
          interface: {
            parseLog: (log: any) => {
              if (log === validLog) {
                return {
                  args: {
                    origin: 31347,
                    router: originRouterBytes32,
                    owner: signerBytes32,
                    ism: ethersConstants.AddressZero,
                  },
                };
              }
              return {
                args: {
                  origin: 999999,
                  router: originRouterBytes32,
                  owner: signerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              };
            },
          },
        } as any;
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) {
            return 'anvil3';
          }
          throw new Error(`unknown domain ${domainId}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      expect((batches[0].config.submitter as any).chain).to.equal('anvil3');
      expect(provider.getLogs.callCount).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('accepts raw-length-boundary whitespace-padded ICA event positions deterministically', async () => {
    const inferredIcaOwner = '0xcacacacacacacacacacacacacacacacacacacaca';
    const destinationRouterAddress =
      '0xcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcb';
    const originRouterAddress = '0xcccccccccccccccccccccccccccccccccccccccc';
    const signerBytes32 =
      `0x000000000000000000000000${SIGNER.slice(2)}` as const;
    const originRouterBytes32 =
      `0x000000000000000000000000${originRouterAddress.slice(2)}` as const;

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const higherLog = {
      topics: ['0xhigher'],
      data: '0x',
      blockNumber: `${' '.repeat(4095)}2`,
      transactionIndex: '0',
      logIndex: '0',
    };
    const lowerLog = {
      topics: ['0xlower'],
      data: '0x',
      blockNumber: `${' '.repeat(4095)}1`,
      transactionIndex: '0',
      logIndex: '0',
    };
    const provider = {
      getLogs: sinon.stub().resolves([lowerLog, higherLog]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== destinationRouterAddress.toLowerCase()) {
          throw new Error('unexpected router');
        }

        return {
          filters: {
            InterchainAccountCreated: (_accountAddress: string) => ({}),
          },
          interface: {
            parseLog: (log: any) => {
              if (log === higherLog) {
                return {
                  args: {
                    origin: 31347,
                    router: originRouterBytes32,
                    owner: signerBytes32,
                    ism: ethersConstants.AddressZero,
                  },
                };
              }
              return {
                args: {
                  origin: 999999,
                  router: originRouterBytes32,
                  owner: signerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              };
            },
          },
        } as any;
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) {
            return 'anvil3';
          }
          throw new Error(`unknown domain ${domainId}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      expect((batches[0].config.submitter as any).chain).to.equal('anvil3');
      expect(provider.getLogs.callCount).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('ignores raw-length-plus-one whitespace-padded ICA event positions during ordering', async () => {
    const inferredIcaOwner = '0xd6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6';
    const destinationRouterAddress =
      '0xd7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7';
    const originRouterAddress = '0xd8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8';
    const signerBytes32 =
      `0x000000000000000000000000${SIGNER.slice(2)}` as const;
    const originRouterBytes32 =
      `0x000000000000000000000000${originRouterAddress.slice(2)}` as const;

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const validLog = {
      topics: ['0xvalid'],
      data: '0x',
      blockNumber: '1010',
      transactionIndex: '0',
      logIndex: '0',
    };
    const malformedBoundaryPlusOneLog = {
      topics: ['0xmalformed-raw-boundary-plus-one'],
      data: '0x',
      blockNumber: `${' '.repeat(4096)}1`,
      transactionIndex: '0',
      logIndex: '0',
    };
    const provider = {
      getLogs: sinon.stub().resolves([validLog, malformedBoundaryPlusOneLog]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== destinationRouterAddress.toLowerCase()) {
          throw new Error('unexpected router');
        }

        return {
          filters: {
            InterchainAccountCreated: (_accountAddress: string) => ({}),
          },
          interface: {
            parseLog: (log: any) => {
              if (log === validLog) {
                return {
                  args: {
                    origin: 31347,
                    router: originRouterBytes32,
                    owner: signerBytes32,
                    ism: ethersConstants.AddressZero,
                  },
                };
              }
              return {
                args: {
                  origin: 999999,
                  router: originRouterBytes32,
                  owner: signerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              };
            },
          },
        } as any;
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) {
            return 'anvil3';
          }
          throw new Error(`unknown domain ${domainId}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      expect((batches[0].config.submitter as any).chain).to.equal('anvil3');
      expect(provider.getLogs.callCount).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('accepts max-length hex-string ICA event positions deterministically', async () => {
    const inferredIcaOwner = '0xb5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5';
    const destinationRouterAddress =
      '0xb6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6';
    const originRouterAddress = '0xb7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7';
    const signerBytes32 =
      `0x000000000000000000000000${SIGNER.slice(2)}` as const;
    const originRouterBytes32 =
      `0x000000000000000000000000${originRouterAddress.slice(2)}` as const;

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const higherLog = {
      topics: ['0xhigher'],
      data: '0x',
      blockNumber: `0x${'f'.repeat(254)}`,
      transactionIndex: '0',
      logIndex: '0',
    };
    const lowerLog = {
      topics: ['0xlower'],
      data: '0x',
      blockNumber: `0x${'f'.repeat(253)}`,
      transactionIndex: '0',
      logIndex: '0',
    };
    const provider = {
      getLogs: sinon.stub().resolves([lowerLog, higherLog]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== destinationRouterAddress.toLowerCase()) {
          throw new Error('unexpected router');
        }

        return {
          filters: {
            InterchainAccountCreated: (_accountAddress: string) => ({}),
          },
          interface: {
            parseLog: (log: any) => {
              if (log === higherLog) {
                return {
                  args: {
                    origin: 31347,
                    router: originRouterBytes32,
                    owner: signerBytes32,
                    ism: ethersConstants.AddressZero,
                  },
                };
              }
              return {
                args: {
                  origin: 999999,
                  router: originRouterBytes32,
                  owner: signerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              };
            },
          },
        } as any;
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) {
            return 'anvil3';
          }
          throw new Error(`unknown domain ${domainId}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      expect((batches[0].config.submitter as any).chain).to.equal('anvil3');
      expect(provider.getLogs.callCount).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('ignores overlong decimal-string ICA event positions during log ordering', async () => {
    const inferredIcaOwner = '0xafafafafafafafafafafafafafafafafafafafaf';
    const destinationRouterAddress =
      '0xb0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0';
    const originRouterAddress = '0xb1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1';
    const signerBytes32 =
      `0x000000000000000000000000${SIGNER.slice(2)}` as const;
    const originRouterBytes32 =
      `0x000000000000000000000000${originRouterAddress.slice(2)}` as const;

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const validLog = {
      topics: ['0xvalid'],
      data: '0x',
      blockNumber: '1005',
      transactionIndex: '0',
      logIndex: '0',
    };
    const malformedOverlongLog = {
      topics: ['0xmalformed-overlong-decimal'],
      data: '0x',
      blockNumber: '9'.repeat(300),
      transactionIndex: '0',
      logIndex: '0',
    };
    const provider = {
      getLogs: sinon.stub().resolves([validLog, malformedOverlongLog]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== destinationRouterAddress.toLowerCase()) {
          throw new Error('unexpected router');
        }

        return {
          filters: {
            InterchainAccountCreated: (_accountAddress: string) => ({}),
          },
          interface: {
            parseLog: (log: any) => {
              if (log === validLog) {
                return {
                  args: {
                    origin: 31347,
                    router: originRouterBytes32,
                    owner: signerBytes32,
                    ism: ethersConstants.AddressZero,
                  },
                };
              }
              return {
                args: {
                  origin: 999999,
                  router: originRouterBytes32,
                  owner: signerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              };
            },
          },
        } as any;
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) {
            return 'anvil3';
          }
          throw new Error(`unknown domain ${domainId}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      expect((batches[0].config.submitter as any).chain).to.equal('anvil3');
      expect(provider.getLogs.callCount).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('accepts max-length decimal-string ICA event positions deterministically', async () => {
    const inferredIcaOwner = '0xb8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8';
    const destinationRouterAddress =
      '0xb9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9';
    const originRouterAddress = '0xbabababababababababababababababababababa';
    const signerBytes32 =
      `0x000000000000000000000000${SIGNER.slice(2)}` as const;
    const originRouterBytes32 =
      `0x000000000000000000000000${originRouterAddress.slice(2)}` as const;

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const higherLog = {
      topics: ['0xhigher'],
      data: '0x',
      blockNumber: '1'.repeat(256),
      transactionIndex: '0',
      logIndex: '0',
    };
    const lowerLog = {
      topics: ['0xlower'],
      data: '0x',
      blockNumber: '9'.repeat(255),
      transactionIndex: '0',
      logIndex: '0',
    };
    const provider = {
      getLogs: sinon.stub().resolves([lowerLog, higherLog]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== destinationRouterAddress.toLowerCase()) {
          throw new Error('unexpected router');
        }

        return {
          filters: {
            InterchainAccountCreated: (_accountAddress: string) => ({}),
          },
          interface: {
            parseLog: (log: any) => {
              if (log === higherLog) {
                return {
                  args: {
                    origin: 31347,
                    router: originRouterBytes32,
                    owner: signerBytes32,
                    ism: ethersConstants.AddressZero,
                  },
                };
              }
              return {
                args: {
                  origin: 999999,
                  router: originRouterBytes32,
                  owner: signerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              };
            },
          },
        } as any;
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) {
            return 'anvil3';
          }
          throw new Error(`unknown domain ${domainId}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      expect((batches[0].config.submitter as any).chain).to.equal('anvil3');
      expect(provider.getLogs.callCount).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('accepts overlong zero-padded decimal ICA event positions deterministically', async () => {
    const inferredIcaOwner = '0xbebebebebebebebebebebebebebebebebebebebe';
    const destinationRouterAddress =
      '0xbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbf';
    const originRouterAddress = '0xc0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0';
    const signerBytes32 =
      `0x000000000000000000000000${SIGNER.slice(2)}` as const;
    const originRouterBytes32 =
      `0x000000000000000000000000${originRouterAddress.slice(2)}` as const;

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const higherLog = {
      topics: ['0xhigher'],
      data: '0x',
      blockNumber: `${'0'.repeat(300)}2`,
      transactionIndex: '0',
      logIndex: '0',
    };
    const lowerLog = {
      topics: ['0xlower'],
      data: '0x',
      blockNumber: `${'0'.repeat(300)}1`,
      transactionIndex: '0',
      logIndex: '0',
    };
    const provider = {
      getLogs: sinon.stub().resolves([lowerLog, higherLog]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== destinationRouterAddress.toLowerCase()) {
          throw new Error('unexpected router');
        }

        return {
          filters: {
            InterchainAccountCreated: (_accountAddress: string) => ({}),
          },
          interface: {
            parseLog: (log: any) => {
              if (log === higherLog) {
                return {
                  args: {
                    origin: 31347,
                    router: originRouterBytes32,
                    owner: signerBytes32,
                    ism: ethersConstants.AddressZero,
                  },
                };
              }
              return {
                args: {
                  origin: 999999,
                  router: originRouterBytes32,
                  owner: signerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              };
            },
          },
        } as any;
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) {
            return 'anvil3';
          }
          throw new Error(`unknown domain ${domainId}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      expect((batches[0].config.submitter as any).chain).to.equal('anvil3');
      expect(provider.getLogs.callCount).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('accepts raw-length-boundary zero-padded decimal ICA event positions deterministically', async () => {
    const inferredIcaOwner = '0xecececececececececececececececececececec';
    const destinationRouterAddress =
      '0xedededededededededededededededededededed';
    const originRouterAddress = '0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee';
    const signerBytes32 =
      `0x000000000000000000000000${SIGNER.slice(2)}` as const;
    const originRouterBytes32 =
      `0x000000000000000000000000${originRouterAddress.slice(2)}` as const;

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const higherLog = {
      topics: ['0xhigher'],
      data: '0x',
      blockNumber: `${'0'.repeat(4095)}2`,
      transactionIndex: '0',
      logIndex: '0',
    };
    const lowerLog = {
      topics: ['0xlower'],
      data: '0x',
      blockNumber: `${'0'.repeat(4095)}1`,
      transactionIndex: '0',
      logIndex: '0',
    };
    const provider = {
      getLogs: sinon.stub().resolves([lowerLog, higherLog]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== destinationRouterAddress.toLowerCase()) {
          throw new Error('unexpected router');
        }

        return {
          filters: {
            InterchainAccountCreated: (_accountAddress: string) => ({}),
          },
          interface: {
            parseLog: (log: any) => {
              if (log === higherLog) {
                return {
                  args: {
                    origin: 31347,
                    router: originRouterBytes32,
                    owner: signerBytes32,
                    ism: ethersConstants.AddressZero,
                  },
                };
              }
              return {
                args: {
                  origin: 999999,
                  router: originRouterBytes32,
                  owner: signerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              };
            },
          },
        } as any;
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) {
            return 'anvil3';
          }
          throw new Error(`unknown domain ${domainId}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      expect((batches[0].config.submitter as any).chain).to.equal('anvil3');
      expect(provider.getLogs.callCount).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('ignores raw-length-plus-one zero-padded decimal ICA event positions during ordering', async () => {
    const inferredIcaOwner = '0xefefefefefefefefefefefefefefefefefefefef';
    const destinationRouterAddress =
      '0xf0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0';
    const originRouterAddress = '0xf1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1';
    const signerBytes32 =
      `0x000000000000000000000000${SIGNER.slice(2)}` as const;
    const originRouterBytes32 =
      `0x000000000000000000000000${originRouterAddress.slice(2)}` as const;

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const validLog = {
      topics: ['0xvalid'],
      data: '0x',
      blockNumber: '1015',
      transactionIndex: '0',
      logIndex: '0',
    };
    const malformedBoundaryPlusOneLog = {
      topics: ['0xmalformed-raw-plus-one-decimal'],
      data: '0x',
      blockNumber: `${'0'.repeat(4096)}1`,
      transactionIndex: '0',
      logIndex: '0',
    };
    const provider = {
      getLogs: sinon.stub().resolves([validLog, malformedBoundaryPlusOneLog]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== destinationRouterAddress.toLowerCase()) {
          throw new Error('unexpected router');
        }

        return {
          filters: {
            InterchainAccountCreated: (_accountAddress: string) => ({}),
          },
          interface: {
            parseLog: (log: any) => {
              if (log === validLog) {
                return {
                  args: {
                    origin: 31347,
                    router: originRouterBytes32,
                    owner: signerBytes32,
                    ism: ethersConstants.AddressZero,
                  },
                };
              }
              return {
                args: {
                  origin: 999999,
                  router: originRouterBytes32,
                  owner: signerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              };
            },
          },
        } as any;
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) {
            return 'anvil3';
          }
          throw new Error(`unknown domain ${domainId}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      expect((batches[0].config.submitter as any).chain).to.equal('anvil3');
      expect(provider.getLogs.callCount).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('ignores overlong toString ICA event positions during log ordering', async () => {
    const inferredIcaOwner = '0xb2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2';
    const destinationRouterAddress =
      '0xb3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3';
    const originRouterAddress = '0xb4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4';
    const signerBytes32 =
      `0x000000000000000000000000${SIGNER.slice(2)}` as const;
    const originRouterBytes32 =
      `0x000000000000000000000000${originRouterAddress.slice(2)}` as const;

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const validLog = {
      topics: ['0xvalid'],
      data: '0x',
      blockNumber: '1006',
      transactionIndex: '0',
      logIndex: '0',
    };
    const malformedToStringLog = {
      topics: ['0xmalformed-tostring-overlong'],
      data: '0x',
      blockNumber: {
        toString: () => `0x${'f'.repeat(300)}`,
      },
      transactionIndex: '0',
      logIndex: '0',
    };
    const provider = {
      getLogs: sinon.stub().resolves([validLog, malformedToStringLog]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== destinationRouterAddress.toLowerCase()) {
          throw new Error('unexpected router');
        }

        return {
          filters: {
            InterchainAccountCreated: (_accountAddress: string) => ({}),
          },
          interface: {
            parseLog: (log: any) => {
              if (log === validLog) {
                return {
                  args: {
                    origin: 31347,
                    router: originRouterBytes32,
                    owner: signerBytes32,
                    ism: ethersConstants.AddressZero,
                  },
                };
              }
              return {
                args: {
                  origin: 999999,
                  router: originRouterBytes32,
                  owner: signerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              };
            },
          },
        } as any;
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) {
            return 'anvil3';
          }
          throw new Error(`unknown domain ${domainId}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      expect((batches[0].config.submitter as any).chain).to.equal('anvil3');
      expect(provider.getLogs.callCount).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('ignores excessively long raw toString ICA event positions during log ordering', async () => {
    const inferredIcaOwner = '0xc4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4';
    const destinationRouterAddress =
      '0xc5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5';
    const originRouterAddress = '0xc6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6';
    const signerBytes32 =
      `0x000000000000000000000000${SIGNER.slice(2)}` as const;
    const originRouterBytes32 =
      `0x000000000000000000000000${originRouterAddress.slice(2)}` as const;

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const validLog = {
      topics: ['0xvalid'],
      data: '0x',
      blockNumber: '1008',
      transactionIndex: '0',
      logIndex: '0',
    };
    const malformedRawToStringLog = {
      topics: ['0xmalformed-raw-tostring'],
      data: '0x',
      blockNumber: {
        toString: () => `0x${'0'.repeat(5000)}2`,
      },
      transactionIndex: '0',
      logIndex: '0',
    };
    const provider = {
      getLogs: sinon.stub().resolves([validLog, malformedRawToStringLog]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== destinationRouterAddress.toLowerCase()) {
          throw new Error('unexpected router');
        }

        return {
          filters: {
            InterchainAccountCreated: (_accountAddress: string) => ({}),
          },
          interface: {
            parseLog: (log: any) => {
              if (log === validLog) {
                return {
                  args: {
                    origin: 31347,
                    router: originRouterBytes32,
                    owner: signerBytes32,
                    ism: ethersConstants.AddressZero,
                  },
                };
              }
              return {
                args: {
                  origin: 999999,
                  router: originRouterBytes32,
                  owner: signerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              };
            },
          },
        } as any;
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) {
            return 'anvil3';
          }
          throw new Error(`unknown domain ${domainId}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      expect((batches[0].config.submitter as any).chain).to.equal('anvil3');
      expect(provider.getLogs.callCount).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('accepts raw-length-boundary toString ICA event positions deterministically', async () => {
    const inferredIcaOwner = '0xcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcd';
    const destinationRouterAddress =
      '0xcececececececececececececececececececece';
    const originRouterAddress = '0xcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcf';
    const signerBytes32 =
      `0x000000000000000000000000${SIGNER.slice(2)}` as const;
    const originRouterBytes32 =
      `0x000000000000000000000000${originRouterAddress.slice(2)}` as const;

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const higherLog = {
      topics: ['0xhigher'],
      data: '0x',
      blockNumber: {
        toString: () => `${' '.repeat(4095)}2`,
      },
      transactionIndex: '0',
      logIndex: '0',
    };
    const lowerLog = {
      topics: ['0xlower'],
      data: '0x',
      blockNumber: {
        toString: () => `${' '.repeat(4095)}1`,
      },
      transactionIndex: '0',
      logIndex: '0',
    };
    const provider = {
      getLogs: sinon.stub().resolves([lowerLog, higherLog]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== destinationRouterAddress.toLowerCase()) {
          throw new Error('unexpected router');
        }

        return {
          filters: {
            InterchainAccountCreated: (_accountAddress: string) => ({}),
          },
          interface: {
            parseLog: (log: any) => {
              if (log === higherLog) {
                return {
                  args: {
                    origin: 31347,
                    router: originRouterBytes32,
                    owner: signerBytes32,
                    ism: ethersConstants.AddressZero,
                  },
                };
              }
              return {
                args: {
                  origin: 999999,
                  router: originRouterBytes32,
                  owner: signerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              };
            },
          },
        } as any;
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) {
            return 'anvil3';
          }
          throw new Error(`unknown domain ${domainId}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      expect((batches[0].config.submitter as any).chain).to.equal('anvil3');
      expect(provider.getLogs.callCount).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('accepts raw-length-boundary uppercase-zero-padded toString ICA positions deterministically', async () => {
    const inferredIcaOwner = '0xd3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3';
    const destinationRouterAddress =
      '0xd4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4';
    const originRouterAddress = '0xd5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5';
    const signerBytes32 =
      `0x000000000000000000000000${SIGNER.slice(2)}` as const;
    const originRouterBytes32 =
      `0x000000000000000000000000${originRouterAddress.slice(2)}` as const;

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const higherLog = {
      topics: ['0xhigher'],
      data: '0x',
      blockNumber: {
        toString: () => `0X${'0'.repeat(4093)}A`,
      },
      transactionIndex: '0',
      logIndex: '0',
    };
    const lowerLog = {
      topics: ['0xlower'],
      data: '0x',
      blockNumber: {
        toString: () => `0X${'0'.repeat(4093)}9`,
      },
      transactionIndex: '0',
      logIndex: '0',
    };
    const provider = {
      getLogs: sinon.stub().resolves([lowerLog, higherLog]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== destinationRouterAddress.toLowerCase()) {
          throw new Error('unexpected router');
        }

        return {
          filters: {
            InterchainAccountCreated: (_accountAddress: string) => ({}),
          },
          interface: {
            parseLog: (log: any) => {
              if (log === higherLog) {
                return {
                  args: {
                    origin: 31347,
                    router: originRouterBytes32,
                    owner: signerBytes32,
                    ism: ethersConstants.AddressZero,
                  },
                };
              }
              return {
                args: {
                  origin: 999999,
                  router: originRouterBytes32,
                  owner: signerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              };
            },
          },
        } as any;
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) {
            return 'anvil3';
          }
          throw new Error(`unknown domain ${domainId}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      expect((batches[0].config.submitter as any).chain).to.equal('anvil3');
      expect(provider.getLogs.callCount).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('ignores raw-length-plus-one toString ICA positions during ordering', async () => {
    const inferredIcaOwner = '0xd9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9';
    const destinationRouterAddress =
      '0xdadadadadadadadadadadadadadadadadadadada';
    const originRouterAddress = '0xdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdb';
    const signerBytes32 =
      `0x000000000000000000000000${SIGNER.slice(2)}` as const;
    const originRouterBytes32 =
      `0x000000000000000000000000${originRouterAddress.slice(2)}` as const;

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const validLog = {
      topics: ['0xvalid'],
      data: '0x',
      blockNumber: '1011',
      transactionIndex: '0',
      logIndex: '0',
    };
    const malformedBoundaryPlusOneLog = {
      topics: ['0xmalformed-raw-plus-one-tostring'],
      data: '0x',
      blockNumber: {
        toString: () => `${' '.repeat(4096)}1`,
      },
      transactionIndex: '0',
      logIndex: '0',
    };
    const provider = {
      getLogs: sinon.stub().resolves([validLog, malformedBoundaryPlusOneLog]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== destinationRouterAddress.toLowerCase()) {
          throw new Error('unexpected router');
        }

        return {
          filters: {
            InterchainAccountCreated: (_accountAddress: string) => ({}),
          },
          interface: {
            parseLog: (log: any) => {
              if (log === validLog) {
                return {
                  args: {
                    origin: 31347,
                    router: originRouterBytes32,
                    owner: signerBytes32,
                    ism: ethersConstants.AddressZero,
                  },
                };
              }
              return {
                args: {
                  origin: 999999,
                  router: originRouterBytes32,
                  owner: signerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              };
            },
          },
        } as any;
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) {
            return 'anvil3';
          }
          throw new Error(`unknown domain ${domainId}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      expect((batches[0].config.submitter as any).chain).to.equal('anvil3');
      expect(provider.getLogs.callCount).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('ignores raw-length-plus-one uppercase-zero-padded toString ICA positions during ordering', async () => {
    const inferredIcaOwner = '0xe8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8';
    const destinationRouterAddress =
      '0xe9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9';
    const originRouterAddress = '0xeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaea';
    const signerBytes32 =
      `0x000000000000000000000000${SIGNER.slice(2)}` as const;
    const originRouterBytes32 =
      `0x000000000000000000000000${originRouterAddress.slice(2)}` as const;

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const validLog = {
      topics: ['0xvalid'],
      data: '0x',
      blockNumber: '1014',
      transactionIndex: '0',
      logIndex: '0',
    };
    const malformedBoundaryPlusOneLog = {
      topics: ['0xmalformed-raw-plus-one-uppercase-tostring'],
      data: '0x',
      blockNumber: {
        toString: () => `0X${'0'.repeat(4094)}1`,
      },
      transactionIndex: '0',
      logIndex: '0',
    };
    const provider = {
      getLogs: sinon.stub().resolves([validLog, malformedBoundaryPlusOneLog]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== destinationRouterAddress.toLowerCase()) {
          throw new Error('unexpected router');
        }

        return {
          filters: {
            InterchainAccountCreated: (_accountAddress: string) => ({}),
          },
          interface: {
            parseLog: (log: any) => {
              if (log === validLog) {
                return {
                  args: {
                    origin: 31347,
                    router: originRouterBytes32,
                    owner: signerBytes32,
                    ism: ethersConstants.AddressZero,
                  },
                };
              }
              return {
                args: {
                  origin: 999999,
                  router: originRouterBytes32,
                  owner: signerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              };
            },
          },
        } as any;
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) {
            return 'anvil3';
          }
          throw new Error(`unknown domain ${domainId}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      expect((batches[0].config.submitter as any).chain).to.equal('anvil3');
      expect(provider.getLogs.callCount).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('ignores signed-hex toString ICA event positions during log ordering', async () => {
    const inferredIcaOwner = '0xd4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4';
    const destinationRouterAddress =
      '0xd5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5';
    const originRouterAddress = '0xd6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6';
    const signerBytes32 =
      `0x000000000000000000000000${SIGNER.slice(2)}` as const;
    const originRouterBytes32 =
      `0x000000000000000000000000${originRouterAddress.slice(2)}` as const;

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const validLog = {
      topics: ['0xvalid'],
      data: '0x',
      blockNumber: '1030',
      transactionIndex: '0',
      logIndex: '0',
    };
    const malformedPlusLog = {
      topics: ['0xmalformed-signed-plus-tostring'],
      data: '0x',
      blockNumber: {
        toString: () => '+0X270f',
      },
      transactionIndex: '0',
      logIndex: '0',
    };
    const malformedMinusLog = {
      topics: ['0xmalformed-signed-minus-tostring'],
      data: '0x',
      blockNumber: {
        toString: () => '-0x270f',
      },
      transactionIndex: '0',
      logIndex: '0',
    };
    const malformedPlusEmptyHexLog = {
      topics: ['0xmalformed-signed-plus-empty-hex-tostring'],
      data: '0x',
      blockNumber: {
        toString: () => '+0x',
      },
      transactionIndex: '0',
      logIndex: '0',
    };
    const malformedMinusEmptyHexLog = {
      topics: ['0xmalformed-signed-minus-empty-hex-tostring'],
      data: '0x',
      blockNumber: {
        toString: () => '-0X',
      },
      transactionIndex: '0',
      logIndex: '0',
    };
    const provider = {
      getLogs: sinon
        .stub()
        .resolves([
          validLog,
          malformedPlusLog,
          malformedMinusLog,
          malformedPlusEmptyHexLog,
          malformedMinusEmptyHexLog,
        ]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== destinationRouterAddress.toLowerCase()) {
          throw new Error('unexpected router');
        }

        return {
          filters: {
            InterchainAccountCreated: (_accountAddress: string) => ({}),
          },
          interface: {
            parseLog: (log: any) => {
              if (log === validLog) {
                return {
                  args: {
                    origin: 31347,
                    router: originRouterBytes32,
                    owner: signerBytes32,
                    ism: ethersConstants.AddressZero,
                  },
                };
              }
              return {
                args: {
                  origin: 999999,
                  router: originRouterBytes32,
                  owner: signerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              };
            },
          },
        } as any;
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) {
            return 'anvil3';
          }
          throw new Error(`unknown domain ${domainId}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      expect((batches[0].config.submitter as any).chain).to.equal('anvil3');
      expect(provider.getLogs.callCount).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('ignores non-string toString ICA event positions during log ordering', async () => {
    const inferredIcaOwner = '0x9090909090909090909090909090909090909090';
    const destinationRouterAddress =
      '0x9191919191919191919191919191919191919191';
    const originRouterAddress = '0x9292929292929292929292929292929292929292';
    const signerBytes32 =
      `0x000000000000000000000000${SIGNER.slice(2)}` as const;
    const originRouterBytes32 =
      `0x000000000000000000000000${originRouterAddress.slice(2)}` as const;

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const validLog = {
      topics: ['0xvalid'],
      data: '0x',
      blockNumber: '1100',
      transactionIndex: '0',
      logIndex: '0',
    };
    const malformedLog = {
      topics: ['0xmalformed'],
      data: '0x',
      blockNumber: {
        toString: () => ({}) as any,
      },
      transactionIndex: '0',
      logIndex: '0',
    };
    const provider = {
      getLogs: sinon.stub().resolves([validLog, malformedLog]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== destinationRouterAddress.toLowerCase()) {
          throw new Error('unexpected router');
        }

        return {
          filters: {
            InterchainAccountCreated: (_accountAddress: string) => ({}),
          },
          interface: {
            parseLog: (log: any) => {
              if (log === validLog) {
                return {
                  args: {
                    origin: 31347,
                    router: originRouterBytes32,
                    owner: signerBytes32,
                    ism: ethersConstants.AddressZero,
                  },
                };
              }
              return {
                args: {
                  origin: 999999,
                  router: originRouterBytes32,
                  owner: signerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              };
            },
          },
        } as any;
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) {
            return 'anvil3';
          }
          throw new Error(`unknown domain ${domainId}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      expect((batches[0].config.submitter as any).chain).to.equal('anvil3');
      expect(provider.getLogs.callCount).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('ignores object-default toString ICA event positions during log ordering', async () => {
    const inferredIcaOwner = '0xd9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9';
    const destinationRouterAddress =
      '0xdadadadadadadadadadadadadadadadadadadada';
    const originRouterAddress = '0xdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdb';
    const signerBytes32 =
      `0x000000000000000000000000${SIGNER.slice(2)}` as const;
    const originRouterBytes32 =
      `0x000000000000000000000000${originRouterAddress.slice(2)}` as const;

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const validLog = {
      topics: ['0xvalid'],
      data: '0x',
      blockNumber: '1101',
      transactionIndex: '0',
      logIndex: '0',
    };
    const malformedLog = {
      topics: ['0xmalformed-object-default-tostring'],
      data: '0x',
      blockNumber: {
        toString: () => '[object Object]',
      },
      transactionIndex: '0',
      logIndex: '0',
    };
    const provider = {
      getLogs: sinon.stub().resolves([validLog, malformedLog]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== destinationRouterAddress.toLowerCase()) {
          throw new Error('unexpected router');
        }

        return {
          filters: {
            InterchainAccountCreated: (_accountAddress: string) => ({}),
          },
          interface: {
            parseLog: (log: any) => {
              if (log === validLog) {
                return {
                  args: {
                    origin: 31347,
                    router: originRouterBytes32,
                    owner: signerBytes32,
                    ism: ethersConstants.AddressZero,
                  },
                };
              }
              return {
                args: {
                  origin: 999999,
                  router: originRouterBytes32,
                  owner: signerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              };
            },
          },
        } as any;
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) {
            return 'anvil3';
          }
          throw new Error(`unknown domain ${domainId}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      expect((batches[0].config.submitter as any).chain).to.equal('anvil3');
      expect(provider.getLogs.callCount).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('ignores throwing toString ICA event positions during log ordering', async () => {
    const inferredIcaOwner = '0x9494949494949494949494949494949494949494';
    const destinationRouterAddress =
      '0x9595959595959595959595959595959595959595';
    const originRouterAddress = '0x9696969696969696969696969696969696969696';
    const signerBytes32 =
      `0x000000000000000000000000${SIGNER.slice(2)}` as const;
    const originRouterBytes32 =
      `0x000000000000000000000000${originRouterAddress.slice(2)}` as const;

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const validLog = {
      topics: ['0xvalid'],
      data: '0x',
      blockNumber: '1500',
      transactionIndex: '0',
      logIndex: '0',
    };
    const malformedLog = {
      topics: ['0xmalformed'],
      data: '0x',
      blockNumber: {
        toString: () => {
          throw new Error('toString failed');
        },
      },
      transactionIndex: '0',
      logIndex: '0',
    };
    const provider = {
      getLogs: sinon.stub().resolves([validLog, malformedLog]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== destinationRouterAddress.toLowerCase()) {
          throw new Error('unexpected router');
        }

        return {
          filters: {
            InterchainAccountCreated: (_accountAddress: string) => ({}),
          },
          interface: {
            parseLog: (log: any) => {
              if (log === validLog) {
                return {
                  args: {
                    origin: 31347,
                    router: originRouterBytes32,
                    owner: signerBytes32,
                    ism: ethersConstants.AddressZero,
                  },
                };
              }
              return {
                args: {
                  origin: 999999,
                  router: originRouterBytes32,
                  owner: signerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              };
            },
          },
        } as any;
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) {
            return 'anvil3';
          }
          throw new Error(`unknown domain ${domainId}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      expect((batches[0].config.submitter as any).chain).to.equal('anvil3');
      expect(provider.getLogs.callCount).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('ignores unsafe-number ICA event positions during log ordering', async () => {
    const inferredIcaOwner = '0x9393939393939393939393939393939393939393';
    const destinationRouterAddress =
      '0x9494949494949494949494949494949494949494';
    const originRouterAddress = '0x9595959595959595959595959595959595959595';
    const signerBytes32 =
      `0x000000000000000000000000${SIGNER.slice(2)}` as const;
    const originRouterBytes32 =
      `0x000000000000000000000000${originRouterAddress.slice(2)}` as const;

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const validLog = {
      topics: ['0xvalid'],
      data: '0x',
      blockNumber: 1300,
      transactionIndex: 0,
      logIndex: 0,
    };
    const malformedLog = {
      topics: ['0xmalformed'],
      data: '0x',
      blockNumber: 1e20,
      transactionIndex: 0,
      logIndex: 0,
    };
    const provider = {
      getLogs: sinon.stub().resolves([validLog, malformedLog]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== destinationRouterAddress.toLowerCase()) {
          throw new Error('unexpected router');
        }

        return {
          filters: {
            InterchainAccountCreated: (_accountAddress: string) => ({}),
          },
          interface: {
            parseLog: (log: any) => {
              if (log === validLog) {
                return {
                  args: {
                    origin: 31347,
                    router: originRouterBytes32,
                    owner: signerBytes32,
                    ism: ethersConstants.AddressZero,
                  },
                };
              }
              return {
                args: {
                  origin: 999999,
                  router: originRouterBytes32,
                  owner: signerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              };
            },
          },
        } as any;
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) {
            return 'anvil3';
          }
          throw new Error(`unknown domain ${domainId}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      expect((batches[0].config.submitter as any).chain).to.equal('anvil3');
      expect(provider.getLogs.callCount).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('ignores non-finite-number ICA event positions during log ordering', async () => {
    const inferredIcaOwner = '0xf2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2';
    const destinationRouterAddress =
      '0xf3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3';
    const originRouterAddress = '0xf4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4';
    const signerBytes32 =
      `0x000000000000000000000000${SIGNER.slice(2)}` as const;
    const originRouterBytes32 =
      `0x000000000000000000000000${originRouterAddress.slice(2)}` as const;

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const validLog = {
      topics: ['0xvalid'],
      data: '0x',
      blockNumber: 1304,
      transactionIndex: 0,
      logIndex: 0,
    };
    const malformedInfinityLog = {
      topics: ['0xmalformed-infinity'],
      data: '0x',
      blockNumber: Number.POSITIVE_INFINITY,
      transactionIndex: 999,
      logIndex: 999,
    };
    const malformedNaNLog = {
      topics: ['0xmalformed-nan'],
      data: '0x',
      blockNumber: Number.NaN,
      transactionIndex: 999,
      logIndex: 999,
    };
    const malformedNegativeInfinityLog = {
      topics: ['0xmalformed-negative-infinity'],
      data: '0x',
      blockNumber: Number.NEGATIVE_INFINITY,
      transactionIndex: 999,
      logIndex: 999,
    };
    const provider = {
      getLogs: sinon
        .stub()
        .resolves([
          malformedInfinityLog,
          malformedNaNLog,
          malformedNegativeInfinityLog,
          validLog,
        ]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== destinationRouterAddress.toLowerCase()) {
          throw new Error('unexpected router');
        }

        return {
          filters: {
            InterchainAccountCreated: (_accountAddress: string) => ({}),
          },
          interface: {
            parseLog: (log: any) => {
              if (log === validLog) {
                return {
                  args: {
                    origin: 31347,
                    router: originRouterBytes32,
                    owner: signerBytes32,
                    ism: ethersConstants.AddressZero,
                  },
                };
              }
              return {
                args: {
                  origin: 999999,
                  router: originRouterBytes32,
                  owner: signerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              };
            },
          },
        } as any;
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) {
            return 'anvil3';
          }
          throw new Error(`unknown domain ${domainId}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      expect((batches[0].config.submitter as any).chain).to.equal('anvil3');
      expect(provider.getLogs.callCount).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('accepts max-safe-number ICA event positions deterministically', async () => {
    const inferredIcaOwner = '0xe8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8';
    const destinationRouterAddress =
      '0xe9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9';
    const originRouterAddress = '0xeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaea';
    const signerBytes32 =
      `0x000000000000000000000000${SIGNER.slice(2)}` as const;
    const originRouterBytes32 =
      `0x000000000000000000000000${originRouterAddress.slice(2)}` as const;

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const higherLog = {
      topics: ['0xhigher'],
      data: '0x',
      blockNumber: Number.MAX_SAFE_INTEGER,
      transactionIndex: 0,
      logIndex: 0,
    };
    const lowerLog = {
      topics: ['0xlower'],
      data: '0x',
      blockNumber: 1301,
      transactionIndex: 0,
      logIndex: 0,
    };
    const provider = {
      getLogs: sinon.stub().resolves([lowerLog, higherLog]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== destinationRouterAddress.toLowerCase()) {
          throw new Error('unexpected router');
        }

        return {
          filters: {
            InterchainAccountCreated: (_accountAddress: string) => ({}),
          },
          interface: {
            parseLog: (log: any) => {
              if (log === higherLog) {
                return {
                  args: {
                    origin: 31347,
                    router: originRouterBytes32,
                    owner: signerBytes32,
                    ism: ethersConstants.AddressZero,
                  },
                };
              }
              return {
                args: {
                  origin: 999999,
                  router: originRouterBytes32,
                  owner: signerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              };
            },
          },
        } as any;
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) {
            return 'anvil3';
          }
          throw new Error(`unknown domain ${domainId}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      expect((batches[0].config.submitter as any).chain).to.equal('anvil3');
      expect(provider.getLogs.callCount).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('ignores negative-number ICA event positions during log ordering', async () => {
    const inferredIcaOwner = '0xedededededededededededededededededededed';
    const destinationRouterAddress =
      '0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee';
    const originRouterAddress = '0xefefefefefefefefefefefefefefefefefefefef';
    const signerBytes32 =
      `0x000000000000000000000000${SIGNER.slice(2)}` as const;
    const originRouterBytes32 =
      `0x000000000000000000000000${originRouterAddress.slice(2)}` as const;

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const validLog = {
      topics: ['0xvalid'],
      data: '0x',
      blockNumber: 1302,
      transactionIndex: 0,
      logIndex: 0,
    };
    const malformedLog = {
      topics: ['0xmalformed-negative'],
      data: '0x',
      blockNumber: -1,
      transactionIndex: 0,
      logIndex: 0,
    };
    const provider = {
      getLogs: sinon.stub().resolves([validLog, malformedLog]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== destinationRouterAddress.toLowerCase()) {
          throw new Error('unexpected router');
        }

        return {
          filters: {
            InterchainAccountCreated: (_accountAddress: string) => ({}),
          },
          interface: {
            parseLog: (log: any) => {
              if (log === validLog) {
                return {
                  args: {
                    origin: 31347,
                    router: originRouterBytes32,
                    owner: signerBytes32,
                    ism: ethersConstants.AddressZero,
                  },
                };
              }
              return {
                args: {
                  origin: 999999,
                  router: originRouterBytes32,
                  owner: signerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              };
            },
          },
        } as any;
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) {
            return 'anvil3';
          }
          throw new Error(`unknown domain ${domainId}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      expect((batches[0].config.submitter as any).chain).to.equal('anvil3');
      expect(provider.getLogs.callCount).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('ignores fractional-number ICA event positions during log ordering', async () => {
    const inferredIcaOwner = '0x9797979797979797979797979797979797979797';
    const destinationRouterAddress =
      '0x9898989898989898989898989898989898989898';
    const originRouterAddress = '0x9999999999999999999999999999999999999999';
    const signerBytes32 =
      `0x000000000000000000000000${SIGNER.slice(2)}` as const;
    const originRouterBytes32 =
      `0x000000000000000000000000${originRouterAddress.slice(2)}` as const;

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const validLog = {
      topics: ['0xvalid'],
      data: '0x',
      blockNumber: 1700,
      transactionIndex: 0,
      logIndex: 0,
    };
    const malformedLog = {
      topics: ['0xmalformed'],
      data: '0x',
      blockNumber: 1700.5,
      transactionIndex: 0,
      logIndex: 0,
    };
    const provider = {
      getLogs: sinon.stub().resolves([validLog, malformedLog]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== destinationRouterAddress.toLowerCase()) {
          throw new Error('unexpected router');
        }

        return {
          filters: {
            InterchainAccountCreated: (_accountAddress: string) => ({}),
          },
          interface: {
            parseLog: (log: any) => {
              if (log === validLog) {
                return {
                  args: {
                    origin: 31347,
                    router: originRouterBytes32,
                    owner: signerBytes32,
                    ism: ethersConstants.AddressZero,
                  },
                };
              }
              return {
                args: {
                  origin: 999999,
                  router: originRouterBytes32,
                  owner: signerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              };
            },
          },
        } as any;
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) {
            return 'anvil3';
          }
          throw new Error(`unknown domain ${domainId}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      expect((batches[0].config.submitter as any).chain).to.equal('anvil3');
      expect(provider.getLogs.callCount).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('falls back to jsonRpc when ICA event-derived origin signer lookup fails with tryGetSigner', async () => {
    const inferredIcaOwner = '0x6868686868686868686868686868686868686868';
    const destinationRouterAddress =
      '0x9090909090909090909090909090909090909090';
    const originOwner = '0x8181818181818181818181818181818181818181';
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x0000000000000000000000009191919191919191919191919191919191919191';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([{ topics: [], data: '0x' }]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error('origin signer unavailable');
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) return 'anvil3';
          throw new Error('unknown domain');
        },
        tryGetSigner: (chainName: string) =>
          chainName === 'anvil3' ? {} : null,
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any, TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(provider.getLogs.callCount).to.equal(1);
      expect(safeStub.callCount).to.equal(1);
      expect(timelockStub.callCount).to.equal(1);
      // tx1: destination owner inference + origin signer availability probe
      // tx2: both signer resolutions are cache hits.
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('infers ICA when origin signer lookup fails but tryGetSigner signer exposes getAddress', async () => {
    const inferredIcaOwner = '0x6868686868686868686868686868686868686868';
    const destinationRouterAddress =
      '0x9090909090909090909090909090909090909090';
    const originOwner = '0x8181818181818181818181818181818181818181';
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x0000000000000000000000009191919191919191919191919191919191919191';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([{ topics: [], data: '0x' }]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerObjectAddressCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error('origin signer unavailable');
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) return 'anvil3';
          throw new Error('unknown domain');
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          if (chainName === 'anvil3') {
            return {
              getAddress: async () => {
                originSignerObjectAddressCalls += 1;
                return SIGNER;
              },
            };
          }
          return null;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any, TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      const submitter = batches[0].config.submitter as any;
      expect(submitter.chain).to.equal('anvil3');
      expect(submitter.owner).to.equal(originOwner);
      expect(submitter.internalSubmitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(provider.getLogs.callCount).to.equal(1);
      expect(originSignerObjectAddressCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('infers ICA when signer probe returns sync signer object with getAddress fallback', async () => {
    const inferredIcaOwner = '0x6868686868686868686868686868686868686868';
    const destinationRouterAddress =
      '0x9090909090909090909090909090909090909090';
    const originOwner = '0x8181818181818181818181818181818181818181';
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x0000000000000000000000009191919191919191919191919191919191919191';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([{ topics: [], data: '0x' }]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerObjectAddressCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error('origin signer unavailable');
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) return 'anvil3';
          throw new Error('unknown domain');
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          if (chainName === 'anvil3') {
            return {
              getAddress: () => {
                originSignerObjectAddressCalls += 1;
                return SIGNER;
              },
            };
          }
          return null;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any, TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      expect(provider.getLogs.callCount).to.equal(1);
      expect(originSignerObjectAddressCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('infers ICA when signer probe exposes non-function then and getAddress fallback', async () => {
    const inferredIcaOwner = '0x9191919191919191919191919191919191919191';
    const destinationRouterAddress =
      '0x9090909090909090909090909090909090909090';
    const originOwner = '0x9292929292929292929292929292929292929292';
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x0000000000000000000000009393939393939393939393939393939393939393';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([{ topics: [], data: '0x' }]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerObjectAddressCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error('origin signer unavailable');
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) return 'anvil3';
          throw new Error('unknown domain');
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          if (chainName === 'anvil3') {
            return {
              then: 1,
              getAddress: () => {
                originSignerObjectAddressCalls += 1;
                return SIGNER;
              },
            };
          }
          return null;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any, TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      expect(originSignerObjectAddressCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('infers ICA when signer probe then getter throws but signer object getAddress succeeds', async () => {
    const inferredIcaOwner = '0x6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e';
    const destinationRouterAddress =
      '0x9090909090909090909090909090909090909090';
    const originOwner = '0x8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b';
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000acacacacacacacacacacacacacacacacacacacac';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([{ topics: [], data: '0x' }]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerObjectAddressCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error('origin signer unavailable');
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) return 'anvil3';
          throw new Error('unknown domain');
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          if (chainName === 'anvil3') {
            return {
              getAddress: () => {
                originSignerObjectAddressCalls += 1;
                return SIGNER;
              },
              get then() {
                throw new Error('broken then getter');
              },
            };
          }
          return null;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any, TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      expect(originSignerObjectAddressCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('falls back to jsonRpc when signer probe then getter throws and signer object getAddress is malformed', async () => {
    const inferredIcaOwner = '0x6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e';
    const destinationRouterAddress =
      '0x9090909090909090909090909090909090909090';
    const originOwner = '0x8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b';
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000acacacacacacacacacacacacacacacacacacacac';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([{ topics: [], data: '0x' }]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerObjectAddressCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          return 'not-an-evm-address';
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) return 'anvil3';
          throw new Error('unknown domain');
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          if (chainName === 'anvil3') {
            return {
              getAddress: () => {
                originSignerObjectAddressCalls += 1;
                return 'not-an-evm-address';
              },
              get then() {
                throw new Error('broken then getter');
              },
            };
          }
          return null;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any, TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(originSignerObjectAddressCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('infers ICA when direct origin signer lookup succeeds without calling signer object getAddress', async () => {
    const inferredIcaOwner = '0x7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b';
    const destinationRouterAddress =
      '0x9090909090909090909090909090909090909090';
    const originOwner = '0x7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c';
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x0000000000000000000000007d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([{ topics: [], data: '0x' }]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerObjectAddressCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          return SIGNER;
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) return 'anvil3';
          throw new Error('unknown domain');
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          if (chainName === 'anvil3') {
            return {
              getAddress: () => {
                originSignerObjectAddressCalls += 1;
                throw new Error('unexpected signer getAddress call');
              },
            };
          }
          return null;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any, TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      expect(originSignerObjectAddressCalls).to.equal(0);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('infers ICA when tryGetSigner getter throws by falling back to direct signer lookup', async () => {
    const inferredIcaOwner = '0x7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e';
    const destinationRouterAddress =
      '0x9090909090909090909090909090909090909090';
    const originOwner = '0x7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f';
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x0000000000000000000000007a7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([{ topics: [], data: '0x' }]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          return SIGNER;
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) return 'anvil3';
          throw new Error('unknown domain');
        },
        get tryGetSigner() {
          throw new Error('broken tryGetSigner getter');
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any, TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('falls back to jsonRpc when tryGetSigner getter throws and origin signer lookup is malformed', async () => {
    const inferredIcaOwner = '0x7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e';
    const destinationRouterAddress =
      '0x9090909090909090909090909090909090909090';
    const originOwner = '0x7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f';
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x0000000000000000000000007a7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([{ topics: [], data: '0x' }]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          return 'not-an-evm-address';
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) return 'anvil3';
          throw new Error('unknown domain');
        },
        get tryGetSigner() {
          throw new Error('broken tryGetSigner getter');
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any, TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('falls back to jsonRpc when tryGetSigner getter throws and origin signer lookup throws', async () => {
    const inferredIcaOwner = '0x8080808080808080808080808080808080808080';
    const destinationRouterAddress =
      '0x9090909090909090909090909090909090909090';
    const originOwner = '0x8181818181818181818181818181818181818181';
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x0000000000000000000000008282828282828282828282828282828282828282';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([{ topics: [], data: '0x' }]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error('origin signer lookup failed');
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) return 'anvil3';
          throw new Error('unknown domain');
        },
        get tryGetSigner() {
          throw new Error('broken tryGetSigner getter');
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any, TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('falls back to jsonRpc when tryGetSigner returns bad thenable and origin signer lookup is malformed', async () => {
    const inferredIcaOwner = '0x8383838383838383838383838383838383838383';
    const destinationRouterAddress =
      '0x9090909090909090909090909090909090909090';
    const originOwner = '0x8484848484848484848484848484848484848484';
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x0000000000000000000000008585858585858585858585858585858585858585';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([{ topics: [], data: '0x' }]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          return 'not-an-evm-address';
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) return 'anvil3';
          throw new Error('unknown domain');
        },
        tryGetSigner: (_chainName: string) => ({
          then: () => {
            throw new Error('bad thenable');
          },
        }),
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any, TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches malformed bad-thenable signer probes across event-derived ICA inferences', async () => {
    const inferredIcaOwnerA = '0x8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c';
    const inferredIcaOwnerB = '0x8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d';
    const destinationRouterAddress =
      '0x8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e';
    const originOwner = '0x8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f';
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x0000000000000000000000009090909090909090909090909090909090909090';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': inferredIcaOwnerA,
      '0x2222222222222222222222222222222222222222': inferredIcaOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([{ topics: [], data: '0x' }]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerProbeCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          return 'not-an-evm-address';
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error('unknown domain');
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return {
            then: () => {
              throw new Error(`bad thenable for ${chainName}`);
            },
          };
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].transactions).to.have.length(2);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(provider.getLogs.callCount).to.equal(2);
      expect(chainNameCalls).to.equal(1);
      expect(originSignerProbeCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches zero-address bad-thenable signer probe fallback across event-derived ICA inferences', async () => {
    const inferredIcaOwnerA = '0x90909090909090909090909090909090909090c1';
    const inferredIcaOwnerB = '0x90909090909090909090909090909090909090c2';
    const destinationRouterAddress =
      '0x90909090909090909090909090909090909090c3';
    const originOwner = '0x90909090909090909090909090909090909090c4';
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x00000000000000000000000090909090909090909090909090909090909090c5';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': inferredIcaOwnerA,
      '0x2222222222222222222222222222222222222222': inferredIcaOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([{ topics: [], data: '0x' }]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerProbeCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          return ethersConstants.AddressZero;
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error('unknown domain');
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return {
            then: () => {
              throw new Error(`bad thenable for ${chainName}`);
            },
          };
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].transactions).to.have.length(2);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(provider.getLogs.callCount).to.equal(2);
      expect(chainNameCalls).to.equal(1);
      expect(originSignerProbeCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches throwing bad-thenable signer probe fallback across event-derived ICA inferences', async () => {
    const inferredIcaOwnerA = '0x90909090909090909090909090909090909090d1';
    const inferredIcaOwnerB = '0x90909090909090909090909090909090909090d2';
    const destinationRouterAddress =
      '0x90909090909090909090909090909090909090d3';
    const originOwner = '0x90909090909090909090909090909090909090d4';
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x00000000000000000000000090909090909090909090909090909090909090d5';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': inferredIcaOwnerA,
      '0x2222222222222222222222222222222222222222': inferredIcaOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([{ topics: [], data: '0x' }]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerProbeCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error(`signer lookup failed for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error('unknown domain');
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return {
            then: () => {
              throw new Error(`bad thenable for ${chainName}`);
            },
          };
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].transactions).to.have.length(2);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(provider.getLogs.callCount).to.equal(2);
      expect(chainNameCalls).to.equal(1);
      expect(originSignerProbeCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches successful bad-thenable signer probe fallback across event-derived ICA inferences', async () => {
    const inferredIcaOwnerA = '0x9090909090909090909090909090909090909091';
    const inferredIcaOwnerB = '0x9090909090909090909090909090909090909092';
    const destinationRouterAddress =
      '0x9090909090909090909090909090909090909093';
    const originOwner = SIGNER;
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x0000000000000000000000009090909090909090909090909090909090909094';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': inferredIcaOwnerA,
      '0x2222222222222222222222222222222222222222': inferredIcaOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([{ topics: [], data: '0x' }]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerProbeCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN || chainName === 'anvil3') {
            return SIGNER;
          }
          throw new Error(`unknown chain ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error('unknown domain');
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return {
            then: () => {
              throw new Error(`bad thenable for ${chainName}`);
            },
          };
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].transactions).to.have.length(2);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      const submitter = batches[0].config.submitter as any;
      expect(submitter.chain).to.equal('anvil3');
      expect(submitter.owner).to.equal(SIGNER);
      expect(submitter.internalSubmitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(provider.getLogs.callCount).to.equal(2);
      expect(chainNameCalls).to.equal(1);
      expect(originSignerProbeCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('falls back to jsonRpc when tryGetSigner returns bad thenable and origin signer lookup throws', async () => {
    const inferredIcaOwner = '0x8989898989898989898989898989898989898989';
    const destinationRouterAddress =
      '0x9090909090909090909090909090909090909090';
    const originOwner = '0x8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a';
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x0000000000000000000000008b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([{ topics: [], data: '0x' }]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error('origin signer lookup failed');
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) return 'anvil3';
          throw new Error('unknown domain');
        },
        tryGetSigner: (_chainName: string) => ({
          then: () => {
            throw new Error('bad thenable');
          },
        }),
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any, TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('infers ICA when tryGetSigner is non-function by falling back to direct signer lookup', async () => {
    const inferredIcaOwner = '0x7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b';
    const destinationRouterAddress =
      '0x9090909090909090909090909090909090909090';
    const originOwner = '0x7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c';
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x0000000000000000000000007d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([{ topics: [], data: '0x' }]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          return SIGNER;
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) return 'anvil3';
          throw new Error('unknown domain');
        },
        tryGetSigner: {},
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any, TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('infers ICA when tryGetSigner returns bad thenable by falling back to direct signer lookup', async () => {
    const inferredIcaOwner = '0x8686868686868686868686868686868686868686';
    const destinationRouterAddress =
      '0x9090909090909090909090909090909090909090';
    const originOwner = '0x8787878787878787878787878787878787878787';
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x0000000000000000000000008888888888888888888888888888888888888888';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([{ topics: [], data: '0x' }]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          return SIGNER;
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) return 'anvil3';
          throw new Error('unknown domain');
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === 'anvil3') {
            return {
              then: () => {
                throw new Error('bad thenable');
              },
            };
          }
          return {};
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any, TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('falls back to jsonRpc when tryGetSigner is non-function and origin signer lookup is malformed', async () => {
    const inferredIcaOwner = '0x7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b';
    const destinationRouterAddress =
      '0x9090909090909090909090909090909090909090';
    const originOwner = '0x7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c';
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x0000000000000000000000007d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([{ topics: [], data: '0x' }]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          return 'not-an-evm-address';
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) return 'anvil3';
          throw new Error('unknown domain');
        },
        tryGetSigner: {},
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any, TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches malformed signer-address fallback when tryGetSigner is non-function across ICA inferences', async () => {
    const inferredIcaOwnerA = '0xc7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7';
    const inferredIcaOwnerB = '0xc8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8';
    const destinationRouterAddress =
      '0xc9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9';
    const originOwner = '0xd0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0';
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': inferredIcaOwnerA,
      '0x2222222222222222222222222222222222222222': inferredIcaOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([{ topics: [], data: '0x' }]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          return 'not-an-evm-address';
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) return 'anvil3';
          throw new Error('unknown domain');
        },
        tryGetSigner: {},
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].transactions).to.have.length(2);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(2);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches zero signer-address fallback when tryGetSigner is non-function across ICA inferences', async () => {
    const inferredIcaOwnerA = '0xd8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8';
    const inferredIcaOwnerB = '0xd9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9';
    const destinationRouterAddress =
      '0xdadadadadadadadadadadadadadadadadadadada';
    const originOwner = '0xdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdb';
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000dcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdc';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': inferredIcaOwnerA,
      '0x2222222222222222222222222222222222222222': inferredIcaOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([{ topics: [], data: '0x' }]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          return ethersConstants.AddressZero;
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) return 'anvil3';
          throw new Error('unknown domain');
        },
        tryGetSigner: {},
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].transactions).to.have.length(2);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(2);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches throwing signer-address fallback when tryGetSigner is non-function across ICA inferences', async () => {
    const inferredIcaOwnerA = '0xdededededededededededededededededededede';
    const inferredIcaOwnerB = '0xdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdf';
    const destinationRouterAddress =
      '0xe0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0';
    const originOwner = '0xe1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1';
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': inferredIcaOwnerA,
      '0x2222222222222222222222222222222222222222': inferredIcaOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([{ topics: [], data: '0x' }]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error('origin signer lookup failed');
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) return 'anvil3';
          throw new Error('unknown domain');
        },
        tryGetSigner: {},
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].transactions).to.have.length(2);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(2);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches successful signer-address fallback when tryGetSigner is non-function across event-derived ICA inferences', async () => {
    const inferredIcaOwnerA = '0xf0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0';
    const inferredIcaOwnerB = '0xf1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1';
    const destinationRouterAddress =
      '0xf2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2';
    const originOwner = SIGNER;
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': inferredIcaOwnerA,
      '0x2222222222222222222222222222222222222222': inferredIcaOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([{ topics: [], data: '0x' }]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN || chainName === 'anvil3') {
            return SIGNER;
          }
          throw new Error(`unknown chain ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) return 'anvil3';
          throw new Error('unknown domain');
        },
        tryGetSigner: {},
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].transactions).to.have.length(2);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      const submitter = batches[0].config.submitter as any;
      expect(submitter.chain).to.equal('anvil3');
      expect(submitter.owner).to.equal(SIGNER);
      expect(submitter.internalSubmitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(2);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches malformed signer-address fallback when tryGetSigner is non-function across event-derived ICA inferences', async () => {
    const inferredIcaOwnerA = '0xf4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4';
    const inferredIcaOwnerB = '0xf5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5';
    const destinationRouterAddress =
      '0xf6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6';
    const originOwner = '0xf7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7';
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': inferredIcaOwnerA,
      '0x2222222222222222222222222222222222222222': inferredIcaOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([{ topics: [], data: '0x' }]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          return 'not-an-evm-address';
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) return 'anvil3';
          throw new Error('unknown domain');
        },
        tryGetSigner: {},
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].transactions).to.have.length(2);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(2);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches zero signer-address fallback when tryGetSigner is non-function across event-derived ICA inferences', async () => {
    const inferredIcaOwnerA = '0xf9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9';
    const inferredIcaOwnerB = '0xfafafafafafafafafafafafafafafafafafafafa';
    const destinationRouterAddress =
      '0xfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfb';
    const originOwner = '0xfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfc';
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000fdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfd';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': inferredIcaOwnerA,
      '0x2222222222222222222222222222222222222222': inferredIcaOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([{ topics: [], data: '0x' }]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          return ethersConstants.AddressZero;
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) return 'anvil3';
          throw new Error('unknown domain');
        },
        tryGetSigner: {},
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].transactions).to.have.length(2);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(2);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches throwing signer-address fallback when tryGetSigner is non-function across event-derived ICA inferences', async () => {
    const inferredIcaOwnerA = '0xabababababababababababababababababababab';
    const inferredIcaOwnerB = '0xacacacacacacacacacacacacacacacacacacacac';
    const destinationRouterAddress =
      '0xadadadadadadadadadadadadadadadadadadadad';
    const originOwner = '0xaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeae';
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000afafafafafafafafafafafafafafafafafafafaf';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': inferredIcaOwnerA,
      '0x2222222222222222222222222222222222222222': inferredIcaOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([{ topics: [], data: '0x' }]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error(`signer lookup failed for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) return 'anvil3';
          throw new Error('unknown domain');
        },
        tryGetSigner: {},
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].transactions).to.have.length(2);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(2);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('infers ICA when signer lookup is zero but signer object getAddress succeeds', async () => {
    const inferredIcaOwnerA = '0x7777777777777777777777777777777777777777';
    const inferredIcaOwnerB = '0x7878787878787878787878787878787878787878';
    const destinationRouterAddress =
      '0x9090909090909090909090909090909090909090';
    const originOwner = '0x8989898989898989898989898989898989898989';
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': inferredIcaOwnerA,
      '0x2222222222222222222222222222222222222222': inferredIcaOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([{ topics: [], data: '0x' }]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerObjectAddressCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          return ethersConstants.AddressZero;
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) return 'anvil3';
          throw new Error('unknown domain');
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          if (chainName === 'anvil3') {
            return {
              getAddress: () => {
                originSignerObjectAddressCalls += 1;
                return SIGNER;
              },
            };
          }
          return null;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].transactions).to.have.length(2);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      expect(provider.getLogs.callCount).to.equal(2);
      expect(originSignerObjectAddressCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('infers ICA when signer lookup is malformed but async signer object getAddress succeeds', async () => {
    const inferredIcaOwnerA = '0x7979797979797979797979797979797979797979';
    const inferredIcaOwnerB = '0x8080808080808080808080808080808080808080';
    const destinationRouterAddress =
      '0x9090909090909090909090909090909090909090';
    const originOwner = '0x8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a';
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000abababababababababababababababababababab';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': inferredIcaOwnerA,
      '0x2222222222222222222222222222222222222222': inferredIcaOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([{ topics: [], data: '0x' }]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerObjectAddressCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          return 'not-an-evm-address';
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) return 'anvil3';
          throw new Error('unknown domain');
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          if (chainName === 'anvil3') {
            return {
              getAddress: async () => {
                originSignerObjectAddressCalls += 1;
                return SIGNER;
              },
            };
          }
          return null;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].transactions).to.have.length(2);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      expect(provider.getLogs.callCount).to.equal(2);
      expect(originSignerObjectAddressCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches signer-object getAddress fallback across event-derived ICA inferences', async () => {
    const inferredIcaOwnerA = '0x6969696969696969696969696969696969696969';
    const inferredIcaOwnerB = '0x7070707070707070707070707070707070707070';
    const destinationRouterAddress =
      '0x9090909090909090909090909090909090909090';
    const originOwner = '0x8181818181818181818181818181818181818181';
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x0000000000000000000000009191919191919191919191919191919191919191';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': inferredIcaOwnerA,
      '0x2222222222222222222222222222222222222222': inferredIcaOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([{ topics: [], data: '0x' }]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerObjectAddressCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error('origin signer unavailable');
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) return 'anvil3';
          throw new Error('unknown domain');
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          if (chainName === 'anvil3') {
            return {
              getAddress: async () => {
                originSignerObjectAddressCalls += 1;
                return SIGNER;
              },
            };
          }
          return null;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].transactions).to.have.length(2);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      expect(provider.getLogs.callCount).to.equal(2);
      expect(originSignerObjectAddressCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches non-function-then signer-object getAddress fallback across event-derived ICA inferences', async () => {
    const inferredIcaOwnerA = '0x6868686868686868686868686868686868686868';
    const inferredIcaOwnerB = '0x6969696969696969696969696969696969696969';
    const destinationRouterAddress =
      '0x9090909090909090909090909090909090909090';
    const originOwner = '0x7070707070707070707070707070707070707070';
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x0000000000000000000000007171717171717171717171717171717171717171';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': inferredIcaOwnerA,
      '0x2222222222222222222222222222222222222222': inferredIcaOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([{ topics: [], data: '0x' }]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerObjectAddressCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error('origin signer unavailable');
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) return 'anvil3';
          throw new Error('unknown domain');
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          if (chainName === 'anvil3') {
            return {
              then: 1,
              getAddress: () => {
                originSignerObjectAddressCalls += 1;
                return SIGNER;
              },
            };
          }
          return null;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].transactions).to.have.length(2);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      expect(provider.getLogs.callCount).to.equal(2);
      expect(originSignerObjectAddressCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async non-function-then signer-object getAddress fallback across event-derived ICA inferences', async () => {
    const inferredIcaOwnerA = '0x8383838383838383838383838383838383838383';
    const inferredIcaOwnerB = '0x8484848484848484848484848484848484848484';
    const destinationRouterAddress =
      '0x9090909090909090909090909090909090909090';
    const originOwner = '0x8585858585858585858585858585858585858585';
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x0000000000000000000000008686868686868686868686868686868686868686';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': inferredIcaOwnerA,
      '0x2222222222222222222222222222222222222222': inferredIcaOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([{ topics: [], data: '0x' }]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerObjectAddressCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error('origin signer unavailable');
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) return 'anvil3';
          throw new Error('unknown domain');
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          if (chainName === 'anvil3') {
            return {
              then: 1,
              getAddress: async () => {
                originSignerObjectAddressCalls += 1;
                return SIGNER;
              },
            };
          }
          return null;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].transactions).to.have.length(2);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      expect(provider.getLogs.callCount).to.equal(2);
      expect(originSignerObjectAddressCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('infers ICA when async signer probe resolves signer object with getAddress fallback', async () => {
    const inferredIcaOwnerA = '0x6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d';
    const inferredIcaOwnerB = '0x6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e';
    const destinationRouterAddress =
      '0x9090909090909090909090909090909090909090';
    const originOwner = '0x8585858585858585858585858585858585858585';
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x0000000000000000000000009696969696969696969696969696969696969696';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': inferredIcaOwnerA,
      '0x2222222222222222222222222222222222222222': inferredIcaOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([{ topics: [], data: '0x' }]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerObjectAddressCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error('origin signer unavailable');
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) return 'anvil3';
          throw new Error('unknown domain');
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          if (chainName === 'anvil3') {
            return {
              getAddress: async () => {
                originSignerObjectAddressCalls += 1;
                return SIGNER;
              },
            };
          }
          return null;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].transactions).to.have.length(2);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      expect(provider.getLogs.callCount).to.equal(2);
      expect(originSignerObjectAddressCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('infers ICA when async signer probe resolves non-function-then signer object with getAddress fallback', async () => {
    const inferredIcaOwnerA = '0x7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a';
    const inferredIcaOwnerB = '0x7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b';
    const destinationRouterAddress =
      '0x9090909090909090909090909090909090909090';
    const originOwner = '0x8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c';
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x0000000000000000000000009a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': inferredIcaOwnerA,
      '0x2222222222222222222222222222222222222222': inferredIcaOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([{ topics: [], data: '0x' }]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerObjectAddressCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error('origin signer unavailable');
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) return 'anvil3';
          throw new Error('unknown domain');
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          if (chainName === 'anvil3') {
            return {
              then: 1,
              getAddress: async () => {
                originSignerObjectAddressCalls += 1;
                return SIGNER;
              },
            };
          }
          return null;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].transactions).to.have.length(2);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      expect(provider.getLogs.callCount).to.equal(2);
      expect(originSignerObjectAddressCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('normalizes whitespace-padded uppercase signer-object getAddress fallback for ICA inference', async () => {
    const inferredIcaOwnerA = '0x7171717171717171717171717171717171717171';
    const inferredIcaOwnerB = '0x7272727272727272727272727272727272727272';
    const destinationRouterAddress =
      '0x9090909090909090909090909090909090909090';
    const originOwner = '0x8686868686868686868686868686868686868686';
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x0000000000000000000000009797979797979797979797979797979797979797';
    const signerObjectAddress = `  0X${SIGNER.slice(2).toUpperCase()}  `;

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': inferredIcaOwnerA,
      '0x2222222222222222222222222222222222222222': inferredIcaOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([{ topics: [], data: '0x' }]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerObjectAddressCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error('origin signer unavailable');
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) return 'anvil3';
          throw new Error('unknown domain');
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          if (chainName === 'anvil3') {
            return {
              getAddress: async () => {
                originSignerObjectAddressCalls += 1;
                return signerObjectAddress;
              },
            };
          }
          return null;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].transactions).to.have.length(2);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      const submitter = batches[0].config.submitter as any;
      expect(submitter.chain).to.equal('anvil3');
      expect(submitter.owner).to.equal(originOwner);
      expect(submitter.internalSubmitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(provider.getLogs.callCount).to.equal(2);
      expect(originSignerObjectAddressCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('normalizes whitespace-padded uppercase non-function-then signer-object getAddress fallback for ICA inference', async () => {
    const inferredIcaOwnerA = '0x7474747474747474747474747474747474747474';
    const inferredIcaOwnerB = '0x7575757575757575757575757575757575757575';
    const destinationRouterAddress =
      '0x9090909090909090909090909090909090909090';
    const originOwner = '0x9696969696969696969696969696969696969696';
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000a7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a7';
    const signerObjectAddress = `  0X${SIGNER.slice(2).toUpperCase()}  `;

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': inferredIcaOwnerA,
      '0x2222222222222222222222222222222222222222': inferredIcaOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([{ topics: [], data: '0x' }]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerObjectAddressCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error('origin signer unavailable');
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) return 'anvil3';
          throw new Error('unknown domain');
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          if (chainName === 'anvil3') {
            return {
              then: 1,
              getAddress: async () => {
                originSignerObjectAddressCalls += 1;
                return signerObjectAddress;
              },
            };
          }
          return null;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].transactions).to.have.length(2);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      const submitter = batches[0].config.submitter as any;
      expect(submitter.chain).to.equal('anvil3');
      expect(submitter.owner).to.equal(originOwner);
      expect(submitter.internalSubmitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(provider.getLogs.callCount).to.equal(2);
      expect(originSignerObjectAddressCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('falls back to jsonRpc when signer object getAddress is malformed for ICA origin signer inference', async () => {
    const inferredIcaOwner = '0x6a6a6a6a6a6a6a6a6a6a6a6a6a6a6a6a6a6a6a6a';
    const destinationRouterAddress =
      '0x9090909090909090909090909090909090909090';
    const originOwner = '0x8282828282828282828282828282828282828282';
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x0000000000000000000000009393939393939393939393939393939393939393';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([{ topics: [], data: '0x' }]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerObjectAddressCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error('origin signer unavailable');
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) return 'anvil3';
          throw new Error('unknown domain');
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          if (chainName === 'anvil3') {
            return {
              getAddress: async () => {
                originSignerObjectAddressCalls += 1;
                return 'not-an-evm-address';
              },
            };
          }
          return null;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any, TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(provider.getLogs.callCount).to.equal(1);
      expect(originSignerObjectAddressCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('falls back to jsonRpc when async non-function-then signer object getAddress is malformed for ICA origin signer inference', async () => {
    const inferredIcaOwner = '0x6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c';
    const destinationRouterAddress =
      '0x9090909090909090909090909090909090909090';
    const originOwner = '0x8484848484848484848484848484848484848484';
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x0000000000000000000000009595959595959595959595959595959595959595';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([{ topics: [], data: '0x' }]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerObjectAddressCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error('origin signer unavailable');
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) return 'anvil3';
          throw new Error('unknown domain');
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          if (chainName === 'anvil3') {
            return {
              then: 1,
              getAddress: async () => {
                originSignerObjectAddressCalls += 1;
                return 'not-an-evm-address';
              },
            };
          }
          return null;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any, TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(provider.getLogs.callCount).to.equal(1);
      expect(originSignerObjectAddressCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('falls back to jsonRpc when async non-function-then signer object getAddress throws for ICA origin signer inference', async () => {
    const inferredIcaOwner = '0x6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f';
    const destinationRouterAddress =
      '0x9090909090909090909090909090909090909090';
    const originOwner = '0x8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e';
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x0000000000000000000000009e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([{ topics: [], data: '0x' }]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerObjectAddressCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error('origin signer unavailable');
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) return 'anvil3';
          throw new Error('unknown domain');
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          if (chainName === 'anvil3') {
            return {
              then: 1,
              getAddress: async () => {
                originSignerObjectAddressCalls += 1;
                throw new Error('signer object address failed');
              },
            };
          }
          return null;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any, TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(provider.getLogs.callCount).to.equal(1);
      expect(originSignerObjectAddressCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('falls back to jsonRpc when non-function-then signer object getAddress throws for ICA origin signer inference', async () => {
    const inferredIcaOwner = '0x7171717171717171717171717171717171717171';
    const destinationRouterAddress =
      '0x9090909090909090909090909090909090909090';
    const originOwner = '0x8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f';
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000afafafafafafafafafafafafafafafafafafafaf';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([{ topics: [], data: '0x' }]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerObjectAddressCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error('origin signer unavailable');
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) return 'anvil3';
          throw new Error('unknown domain');
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          if (chainName === 'anvil3') {
            return {
              then: 1,
              getAddress: () => {
                originSignerObjectAddressCalls += 1;
                throw new Error('signer object address failed');
              },
            };
          }
          return null;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any, TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(provider.getLogs.callCount).to.equal(1);
      expect(originSignerObjectAddressCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('falls back to jsonRpc when async non-function-then signer object getAddress getter throws for ICA origin signer inference', async () => {
    const inferredIcaOwner = '0x6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e';
    const destinationRouterAddress =
      '0x9090909090909090909090909090909090909090';
    const originOwner = '0x8787878787878787878787878787878787878787';
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x0000000000000000000000009898989898989898989898989898989898989898';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([{ topics: [], data: '0x' }]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerGetAddressGetterCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error('origin signer unavailable');
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) return 'anvil3';
          throw new Error('unknown domain');
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          if (chainName === 'anvil3') {
            return {
              then: 1,
              get getAddress() {
                originSignerGetAddressGetterCalls += 1;
                throw new Error('signer object getAddress getter failed');
              },
            };
          }
          return null;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any, TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(provider.getLogs.callCount).to.equal(1);
      expect(originSignerGetAddressGetterCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('falls back to jsonRpc when non-function-then signer object getAddress getter throws for ICA origin signer inference', async () => {
    const inferredIcaOwner = '0x7070707070707070707070707070707070707070';
    const destinationRouterAddress =
      '0x9090909090909090909090909090909090909090';
    const originOwner = '0x9191919191919191919191919191919191919191';
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([{ topics: [], data: '0x' }]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerGetAddressGetterCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error('origin signer unavailable');
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) return 'anvil3';
          throw new Error('unknown domain');
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          if (chainName === 'anvil3') {
            return {
              then: 1,
              get getAddress() {
                originSignerGetAddressGetterCalls += 1;
                throw new Error('signer object getAddress getter failed');
              },
            };
          }
          return null;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any, TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(provider.getLogs.callCount).to.equal(1);
      expect(originSignerGetAddressGetterCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('falls back to jsonRpc when signer object has no getAddress for ICA origin signer inference', async () => {
    const inferredIcaOwner = '0x6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b';
    const destinationRouterAddress =
      '0x9090909090909090909090909090909090909090';
    const originOwner = '0x8383838383838383838383838383838383838383';
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x0000000000000000000000009494949494949494949494949494949494949494';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([{ topics: [], data: '0x' }]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerProbeCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error('origin signer unavailable');
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) return 'anvil3';
          throw new Error('unknown domain');
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          if (chainName === 'anvil3') {
            originSignerProbeCalls += 1;
            return {};
          }
          return null;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any, TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(provider.getLogs.callCount).to.equal(1);
      expect(originSignerProbeCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('falls back to jsonRpc when async signer object has no getAddress for ICA origin signer inference', async () => {
    const inferredIcaOwner = '0x6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d';
    const destinationRouterAddress =
      '0x9090909090909090909090909090909090909090';
    const originOwner = '0x8585858585858585858585858585858585858585';
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x0000000000000000000000009696969696969696969696969696969696969696';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([{ topics: [], data: '0x' }]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerProbeCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error('origin signer unavailable');
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) return 'anvil3';
          throw new Error('unknown domain');
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          if (chainName === 'anvil3') {
            originSignerProbeCalls += 1;
            return {};
          }
          return null;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].transactions).to.have.length(2);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(provider.getLogs.callCount).to.equal(1);
      expect(originSignerProbeCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches malformed signer-object getAddress fallback across event-derived ICA inferences', async () => {
    const inferredIcaOwnerA = '0x7373737373737373737373737373737373737373';
    const inferredIcaOwnerB = '0x7474747474747474747474747474747474747474';
    const destinationRouterAddress =
      '0x9090909090909090909090909090909090909090';
    const originOwner = '0x8787878787878787878787878787878787878787';
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x0000000000000000000000009898989898989898989898989898989898989898';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': inferredIcaOwnerA,
      '0x2222222222222222222222222222222222222222': inferredIcaOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([{ topics: [], data: '0x' }]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerObjectAddressCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error('origin signer unavailable');
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) return 'anvil3';
          throw new Error('unknown domain');
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          if (chainName === 'anvil3') {
            return {
              getAddress: async () => {
                originSignerObjectAddressCalls += 1;
                return 'not-an-evm-address';
              },
            };
          }
          return null;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].transactions).to.have.length(2);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(provider.getLogs.callCount).to.equal(2);
      expect(originSignerObjectAddressCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async malformed signer-object getAddress fallback across event-derived ICA inferences', async () => {
    const inferredIcaOwnerA = '0x7575757575757575757575757575757575757575';
    const inferredIcaOwnerB = '0x7676767676767676767676767676767676767676';
    const destinationRouterAddress =
      '0x9090909090909090909090909090909090909090';
    const originOwner = '0x8888888888888888888888888888888888888888';
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x0000000000000000000000009999999999999999999999999999999999999999';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': inferredIcaOwnerA,
      '0x2222222222222222222222222222222222222222': inferredIcaOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([{ topics: [], data: '0x' }]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerObjectAddressCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error('origin signer unavailable');
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) return 'anvil3';
          throw new Error('unknown domain');
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          if (chainName === 'anvil3') {
            return {
              getAddress: async () => {
                originSignerObjectAddressCalls += 1;
                return 'not-an-evm-address';
              },
            };
          }
          return null;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].transactions).to.have.length(2);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(provider.getLogs.callCount).to.equal(2);
      expect(originSignerObjectAddressCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches non-function-then signer-object getAddress throw fallback across event-derived ICA inferences', async () => {
    const inferredIcaOwnerA = '0x7676767676767676767676767676767676767676';
    const inferredIcaOwnerB = '0x7777777777777777777777777777777777777777';
    const destinationRouterAddress =
      '0x9090909090909090909090909090909090909090';
    const originOwner = '0x9898989898989898989898989898989898989898';
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': inferredIcaOwnerA,
      '0x2222222222222222222222222222222222222222': inferredIcaOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([{ topics: [], data: '0x' }]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerObjectAddressCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error('origin signer unavailable');
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) return 'anvil3';
          throw new Error('unknown domain');
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          if (chainName === 'anvil3') {
            return {
              then: 1,
              getAddress: () => {
                originSignerObjectAddressCalls += 1;
                throw new Error('signer object address failed');
              },
            };
          }
          return null;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].transactions).to.have.length(2);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(provider.getLogs.callCount).to.equal(2);
      expect(originSignerObjectAddressCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches non-function-then signer-object getAddress getter throw fallback across event-derived ICA inferences', async () => {
    const inferredIcaOwnerA = '0x7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a';
    const inferredIcaOwnerB = '0x7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b';
    const destinationRouterAddress =
      '0x9090909090909090909090909090909090909090';
    const originOwner = '0x9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a';
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': inferredIcaOwnerA,
      '0x2222222222222222222222222222222222222222': inferredIcaOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([{ topics: [], data: '0x' }]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerGetAddressGetterCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error('origin signer unavailable');
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) return 'anvil3';
          throw new Error('unknown domain');
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          if (chainName === 'anvil3') {
            return {
              then: 1,
              get getAddress() {
                originSignerGetAddressGetterCalls += 1;
                throw new Error('signer object getAddress getter failed');
              },
            };
          }
          return null;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].transactions).to.have.length(2);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(provider.getLogs.callCount).to.equal(2);
      expect(originSignerGetAddressGetterCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async non-function-then signer-object getAddress getter throw fallback across event-derived ICA inferences', async () => {
    const inferredIcaOwnerA = '0x7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c';
    const inferredIcaOwnerB = '0x7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d';
    const destinationRouterAddress =
      '0x9090909090909090909090909090909090909090';
    const originOwner = '0x9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b';
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': inferredIcaOwnerA,
      '0x2222222222222222222222222222222222222222': inferredIcaOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([{ topics: [], data: '0x' }]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerGetAddressGetterCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error('origin signer unavailable');
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) return 'anvil3';
          throw new Error('unknown domain');
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          if (chainName === 'anvil3') {
            return {
              then: 1,
              get getAddress() {
                originSignerGetAddressGetterCalls += 1;
                throw new Error('signer object getAddress getter failed');
              },
            };
          }
          return null;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].transactions).to.have.length(2);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(provider.getLogs.callCount).to.equal(2);
      expect(originSignerGetAddressGetterCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('falls back to jsonRpc when signer object getAddress is zero for ICA origin signer inference', async () => {
    const inferredIcaOwner = '0x6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c';
    const destinationRouterAddress =
      '0x9090909090909090909090909090909090909090';
    const originOwner = '0x8484848484848484848484848484848484848484';
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x0000000000000000000000009595959595959595959595959595959595959595';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([{ topics: [], data: '0x' }]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerObjectAddressCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error('origin signer unavailable');
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) return 'anvil3';
          throw new Error('unknown domain');
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          if (chainName === 'anvil3') {
            return {
              getAddress: async () => {
                originSignerObjectAddressCalls += 1;
                return ethersConstants.AddressZero;
              },
            };
          }
          return null;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any, TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(provider.getLogs.callCount).to.equal(1);
      expect(originSignerObjectAddressCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('falls back to jsonRpc when non-function-then signer object getAddress is zero for ICA origin signer inference', async () => {
    const inferredIcaOwner = '0x7272727272727272727272727272727272727272';
    const destinationRouterAddress =
      '0x9090909090909090909090909090909090909090';
    const originOwner = '0x9292929292929292929292929292929292929292';
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([{ topics: [], data: '0x' }]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerObjectAddressCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error('origin signer unavailable');
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) return 'anvil3';
          throw new Error('unknown domain');
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          if (chainName === 'anvil3') {
            return {
              then: 1,
              getAddress: () => {
                originSignerObjectAddressCalls += 1;
                return ethersConstants.AddressZero;
              },
            };
          }
          return null;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any, TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(provider.getLogs.callCount).to.equal(1);
      expect(originSignerObjectAddressCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('falls back to jsonRpc when async non-function-then signer object getAddress is zero for ICA origin signer inference', async () => {
    const inferredIcaOwner = '0x7373737373737373737373737373737373737373';
    const destinationRouterAddress =
      '0x9090909090909090909090909090909090909090';
    const originOwner = '0x9393939393939393939393939393939393939393';
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([{ topics: [], data: '0x' }]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerObjectAddressCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error('origin signer unavailable');
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) return 'anvil3';
          throw new Error('unknown domain');
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          if (chainName === 'anvil3') {
            return {
              then: 1,
              getAddress: async () => {
                originSignerObjectAddressCalls += 1;
                return ethersConstants.AddressZero;
              },
            };
          }
          return null;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any, TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(provider.getLogs.callCount).to.equal(1);
      expect(originSignerObjectAddressCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('falls back to jsonRpc when signer object getAddress throws for ICA origin signer inference', async () => {
    const inferredIcaOwner = '0x6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b';
    const destinationRouterAddress =
      '0x9090909090909090909090909090909090909090';
    const originOwner = '0x8383838383838383838383838383838383838383';
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x0000000000000000000000009494949494949494949494949494949494949494';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([{ topics: [], data: '0x' }]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerObjectAddressCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error('origin signer unavailable');
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) return 'anvil3';
          throw new Error('unknown domain');
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          if (chainName === 'anvil3') {
            return {
              getAddress: async () => {
                originSignerObjectAddressCalls += 1;
                throw new Error('signer object address failed');
              },
            };
          }
          return null;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any, TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(provider.getLogs.callCount).to.equal(1);
      expect(originSignerObjectAddressCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('falls back to jsonRpc when signer object getAddress getter throws for ICA origin signer inference', async () => {
    const inferredIcaOwner = '0x6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f';
    const destinationRouterAddress =
      '0x9090909090909090909090909090909090909090';
    const originOwner = '0x8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c';
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000adadadadadadadadadadadadadadadadadadadad';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([{ topics: [], data: '0x' }]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerGetAddressGetterCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error('origin signer unavailable');
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) return 'anvil3';
          throw new Error('unknown domain');
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          if (chainName === 'anvil3') {
            return {
              get getAddress() {
                originSignerGetAddressGetterCalls += 1;
                throw new Error('signer object getAddress getter failed');
              },
            };
          }
          return null;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any, TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(provider.getLogs.callCount).to.equal(1);
      expect(originSignerGetAddressGetterCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('falls back to jsonRpc when ICA event-derived origin signer lookup fails without tryGetSigner', async () => {
    const inferredIcaOwner = '0x9898989898989898989898989898989898989898';
    const destinationRouterAddress =
      '0x9191919191919191919191919191919191919191';
    const originOwner = '0xa2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2';
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x0000000000000000000000009292929292929292929292929292929292929292';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([{ topics: [], data: '0x' }]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error('origin signer unavailable');
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) return 'anvil3';
          throw new Error('unknown domain');
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any, TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(provider.getLogs.callCount).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches successful origin signer lookup without tryGetSigner across event-derived ICA inferences', async () => {
    const inferredIcaOwnerA = '0x9898989898989898989898989898989898989898';
    const inferredIcaOwnerB = '0x9999999999999999999999999999999999999999';
    const destinationRouterAddress =
      '0x9191919191919191919191919191919191919191';
    const originOwner = SIGNER;
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x0000000000000000000000009292929292929292929292929292929292929292';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': inferredIcaOwnerA,
      '0x2222222222222222222222222222222222222222': inferredIcaOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([{ topics: [], data: '0x' }]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN || chainName === 'anvil3') {
            return SIGNER;
          }
          throw new Error(`unknown chain ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error('unknown domain');
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].transactions).to.have.length(2);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      const submitter = batches[0].config.submitter as any;
      expect(submitter.chain).to.equal('anvil3');
      expect(submitter.owner).to.equal(SIGNER);
      expect(submitter.internalSubmitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(provider.getLogs.callCount).to.equal(2);
      expect(chainNameCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('falls back to jsonRpc when ICA event-derived origin signer is zero address with tryGetSigner', async () => {
    const inferredIcaOwner = '0x7777777777777777777777777777777777777777';
    const destinationRouterAddress =
      '0x9191919191919191919191919191919191919191';
    const originOwner = '0xa2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2';
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x0000000000000000000000009292929292929292929292929292929292929292';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([{ topics: [], data: '0x' }]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerProbeCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          return ethersConstants.AddressZero;
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) return 'anvil3';
          throw new Error('unknown domain');
        },
        tryGetSigner: (chainName: string) => {
          if (chainName !== CHAIN) {
            originSignerProbeCalls += 1;
          }
          return {};
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any, TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(provider.getLogs.callCount).to.equal(1);
      expect(originSignerProbeCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(safeStub.callCount).to.equal(1);
      expect(timelockStub.callCount).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('falls back to jsonRpc when ICA event-derived origin signer is malformed with tryGetSigner', async () => {
    const inferredIcaOwner = '0x7878787878787878787878787878787878787878';
    const destinationRouterAddress =
      '0x9191919191919191919191919191919191919191';
    const originOwner = '0xa2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2';
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x0000000000000000000000009292929292929292929292929292929292929292';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([{ topics: [], data: '0x' }]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerProbeCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          return 'not-an-evm-address';
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) return 'anvil3';
          throw new Error('unknown domain');
        },
        tryGetSigner: (chainName: string) => {
          if (chainName !== CHAIN) {
            originSignerProbeCalls += 1;
          }
          return {};
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any, TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(provider.getLogs.callCount).to.equal(1);
      expect(originSignerProbeCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(safeStub.callCount).to.equal(1);
      expect(timelockStub.callCount).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('falls back to jsonRpc when ICA event-derived origin signer is zero address without tryGetSigner', async () => {
    const inferredIcaOwner = '0x9898989898989898989898989898989898989898';
    const destinationRouterAddress =
      '0x9191919191919191919191919191919191919191';
    const originOwner = '0xa2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2';
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x0000000000000000000000009292929292929292929292929292929292929292';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([{ topics: [], data: '0x' }]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          return ethersConstants.AddressZero;
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) return 'anvil3';
          throw new Error('unknown domain');
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any, TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(provider.getLogs.callCount).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(safeStub.callCount).to.equal(1);
      expect(timelockStub.callCount).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('falls back to jsonRpc when ICA event-derived origin signer is malformed without tryGetSigner', async () => {
    const inferredIcaOwner = '0x9898989898989898989898989898989898989898';
    const destinationRouterAddress =
      '0x9191919191919191919191919191919191919191';
    const originOwner = '0xa2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2';
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x0000000000000000000000009292929292929292929292929292929292929292';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([{ topics: [], data: '0x' }]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          return 'not-an-evm-address';
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) return 'anvil3';
          throw new Error('unknown domain');
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any, TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(provider.getLogs.callCount).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(safeStub.callCount).to.equal(1);
      expect(timelockStub.callCount).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches malformed tryGetSigner origin signer lookups across event-derived ICA inferences', async () => {
    const inferredIcaOwnerA = '0xb1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1';
    const inferredIcaOwnerB = '0xc2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2';
    const destinationRouterAddress =
      '0xd3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3';
    const originOwner = '0xe4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4';
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': inferredIcaOwnerA,
      '0x2222222222222222222222222222222222222222': inferredIcaOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([{ topics: [], data: '0x' }]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerProbeCalls = 0;
    let chainNameCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          return 'not-an-evm-address';
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error('unknown domain');
        },
        tryGetSigner: (chainName: string) => {
          if (chainName !== CHAIN) {
            originSignerProbeCalls += 1;
          }
          return {};
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].transactions).to.have.length(2);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(provider.getLogs.callCount).to.equal(2);
      expect(originSignerProbeCalls).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('infers ICA when event-derived origin signer is whitespace-padded uppercase with tryGetSigner', async () => {
    const inferredIcaOwnerA = '0x4646464646464646464646464646464646464646';
    const inferredIcaOwnerB = '0x5757575757575757575757575757575757575757';
    const destinationRouterAddress =
      '0x6868686868686868686868686868686868686868';
    const originOwner = '0x7979797979797979797979797979797979797979';
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x0000000000000000000000008a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': inferredIcaOwnerA,
      '0x2222222222222222222222222222222222222222': inferredIcaOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([{ topics: [], data: '0x' }]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerProbeCalls = 0;
    let chainNameCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          if (chainName === 'anvil3') {
            return `  0X${originOwner.slice(2).toUpperCase()}  `;
          }
          throw new Error(`unknown signer chain ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error('unknown domain');
        },
        tryGetSigner: (chainName: string) => {
          if (chainName !== CHAIN) {
            originSignerProbeCalls += 1;
          }
          return {};
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].transactions).to.have.length(2);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      const submitter = batches[0].config.submitter as any;
      expect(submitter.chain).to.equal('anvil3');
      expect(submitter.owner).to.equal(originOwner);
      expect(submitter.internalSubmitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(submitter.internalSubmitter.chain).to.equal('anvil3');
      expect(provider.getLogs.callCount).to.equal(2);
      expect(chainNameCalls).to.equal(1);
      expect(originSignerProbeCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches throwing tryGetSigner origin signer probes across event-derived ICA inferences', async () => {
    const inferredIcaOwnerA = '0xa6a6a6a6a6a6a6a6a6a6a6a6a6a6a6a6a6a6a6a6';
    const inferredIcaOwnerB = '0xb7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7';
    const destinationRouterAddress =
      '0xc8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8';
    const originOwner = '0xd9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9';
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000eaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaea';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': inferredIcaOwnerA,
      '0x2222222222222222222222222222222222222222': inferredIcaOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([{ topics: [], data: '0x' }]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerProbeCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error('origin signer should not be fetched');
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error('unknown domain');
        },
        tryGetSigner: (chainName: string) => {
          if (chainName !== CHAIN) {
            originSignerProbeCalls += 1;
            throw new Error('No chain signer set for anvil3');
          }
          return {};
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].transactions).to.have.length(2);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(provider.getLogs.callCount).to.equal(2);
      expect(chainNameCalls).to.equal(1);
      expect(originSignerProbeCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3 ?? 0).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches successful signer-address fallback when origin signer probe throws across event-derived ICA inferences', async () => {
    const inferredIcaOwnerA = '0xabababababababababababababababababababab';
    const inferredIcaOwnerB = '0xbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbc';
    const destinationRouterAddress =
      '0xcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcd';
    const originOwner = SIGNER;
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000dededededededededededededededededededede';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': inferredIcaOwnerA,
      '0x2222222222222222222222222222222222222222': inferredIcaOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([{ topics: [], data: '0x' }]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerProbeCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN || chainName === 'anvil3') {
            return SIGNER;
          }
          throw new Error(`unknown chain ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error('unknown domain');
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) {
            return {};
          }
          originSignerProbeCalls += 1;
          throw new Error(`origin signer probe failed for ${chainName}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].transactions).to.have.length(2);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      const submitter = batches[0].config.submitter as any;
      expect(submitter.chain).to.equal('anvil3');
      expect(submitter.owner).to.equal(SIGNER);
      expect(submitter.internalSubmitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(provider.getLogs.callCount).to.equal(2);
      expect(chainNameCalls).to.equal(1);
      expect(originSignerProbeCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches malformed signer-address fallback when origin signer probe throws across event-derived ICA inferences', async () => {
    const inferredIcaOwnerA = '0xc2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2';
    const inferredIcaOwnerB = '0xc3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3';
    const destinationRouterAddress =
      '0xc4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4';
    const originOwner = '0xc5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5';
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': inferredIcaOwnerA,
      '0x2222222222222222222222222222222222222222': inferredIcaOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([{ topics: [], data: '0x' }]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerProbeCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          return 'not-an-evm-address';
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error('unknown domain');
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) {
            return {};
          }
          originSignerProbeCalls += 1;
          throw new Error(`origin signer probe failed for ${chainName}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].transactions).to.have.length(2);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(provider.getLogs.callCount).to.equal(2);
      expect(chainNameCalls).to.equal(1);
      expect(originSignerProbeCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches zero signer-address fallback when origin signer probe throws across event-derived ICA inferences', async () => {
    const inferredIcaOwnerA = '0xc7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7';
    const inferredIcaOwnerB = '0xc8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8';
    const destinationRouterAddress =
      '0xc9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9';
    const originOwner = '0xcacacacacacacacacacacacacacacacacacacaca';
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000cbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcb';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': inferredIcaOwnerA,
      '0x2222222222222222222222222222222222222222': inferredIcaOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([{ topics: [], data: '0x' }]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerProbeCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          return ethersConstants.AddressZero;
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error('unknown domain');
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) {
            return {};
          }
          originSignerProbeCalls += 1;
          throw new Error(`origin signer probe failed for ${chainName}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].transactions).to.have.length(2);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(provider.getLogs.callCount).to.equal(2);
      expect(chainNameCalls).to.equal(1);
      expect(originSignerProbeCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches throwing signer-address fallback when origin signer probe throws across event-derived ICA inferences', async () => {
    const inferredIcaOwnerA = '0xcccccccccccccccccccccccccccccccccccccccc';
    const inferredIcaOwnerB = '0xcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcd';
    const destinationRouterAddress =
      '0xcececececececececececececececececececece';
    const originOwner = '0xcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcf';
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': inferredIcaOwnerA,
      '0x2222222222222222222222222222222222222222': inferredIcaOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([{ topics: [], data: '0x' }]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerProbeCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error(`signer lookup failed for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error('unknown domain');
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) {
            return {};
          }
          originSignerProbeCalls += 1;
          throw new Error(`origin signer probe failed for ${chainName}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].transactions).to.have.length(2);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(provider.getLogs.callCount).to.equal(2);
      expect(chainNameCalls).to.equal(1);
      expect(originSignerProbeCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches successful signer-address fallback when tryGetSigner getter throws across event-derived ICA inferences', async () => {
    const inferredIcaOwnerA = '0xbebebebebebebebebebebebebebebebebebebebe';
    const inferredIcaOwnerB = '0xbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbf';
    const destinationRouterAddress =
      '0xc0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0';
    const originOwner = SIGNER;
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': inferredIcaOwnerA,
      '0x2222222222222222222222222222222222222222': inferredIcaOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([{ topics: [], data: '0x' }]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    let originTryGetSignerGetterCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN || chainName === 'anvil3') {
            return SIGNER;
          }
          throw new Error(`unknown chain ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error('unknown domain');
        },
        get tryGetSigner() {
          originTryGetSignerGetterCalls += 1;
          throw new Error('tryGetSigner getter failed');
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].transactions).to.have.length(2);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      const submitter = batches[0].config.submitter as any;
      expect(submitter.chain).to.equal('anvil3');
      expect(submitter.owner).to.equal(SIGNER);
      expect(submitter.internalSubmitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(provider.getLogs.callCount).to.equal(2);
      expect(chainNameCalls).to.equal(1);
      expect(originTryGetSignerGetterCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches malformed signer-address fallback when tryGetSigner getter throws across event-derived ICA inferences', async () => {
    const inferredIcaOwnerA = '0xd1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1';
    const inferredIcaOwnerB = '0xd2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2';
    const destinationRouterAddress =
      '0xd3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3';
    const originOwner = '0xd4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4';
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': inferredIcaOwnerA,
      '0x2222222222222222222222222222222222222222': inferredIcaOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([{ topics: [], data: '0x' }]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    let originTryGetSignerGetterCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          return 'not-an-evm-address';
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error('unknown domain');
        },
        get tryGetSigner() {
          originTryGetSignerGetterCalls += 1;
          throw new Error('tryGetSigner getter failed');
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].transactions).to.have.length(2);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(provider.getLogs.callCount).to.equal(2);
      expect(chainNameCalls).to.equal(1);
      expect(originTryGetSignerGetterCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches zero signer-address fallback when tryGetSigner getter throws across event-derived ICA inferences', async () => {
    const inferredIcaOwnerA = '0xd6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6';
    const inferredIcaOwnerB = '0xd7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7';
    const destinationRouterAddress =
      '0xd8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8';
    const originOwner = '0xd9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9';
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000dadadadadadadadadadadadadadadadadadadada';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': inferredIcaOwnerA,
      '0x2222222222222222222222222222222222222222': inferredIcaOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([{ topics: [], data: '0x' }]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    let originTryGetSignerGetterCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          return ethersConstants.AddressZero;
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error('unknown domain');
        },
        get tryGetSigner() {
          originTryGetSignerGetterCalls += 1;
          throw new Error('tryGetSigner getter failed');
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].transactions).to.have.length(2);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(provider.getLogs.callCount).to.equal(2);
      expect(chainNameCalls).to.equal(1);
      expect(originTryGetSignerGetterCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches throwing signer-address fallback when tryGetSigner getter throws across event-derived ICA inferences', async () => {
    const inferredIcaOwnerA = '0xdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdb';
    const inferredIcaOwnerB = '0xdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdc';
    const destinationRouterAddress =
      '0xdddddddddddddddddddddddddddddddddddddddd';
    const originOwner = '0xdededededededededededededededededededede';
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000dfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdf';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': inferredIcaOwnerA,
      '0x2222222222222222222222222222222222222222': inferredIcaOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([{ topics: [], data: '0x' }]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    let originTryGetSignerGetterCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error(`signer lookup failed for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error('unknown domain');
        },
        get tryGetSigner() {
          originTryGetSignerGetterCalls += 1;
          throw new Error('tryGetSigner getter failed');
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].transactions).to.have.length(2);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(provider.getLogs.callCount).to.equal(2);
      expect(chainNameCalls).to.equal(1);
      expect(originTryGetSignerGetterCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches successful async-reject signer probe fallback across event-derived ICA inferences', async () => {
    const inferredIcaOwnerA = '0xe0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0';
    const inferredIcaOwnerB = '0xf1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1';
    const destinationRouterAddress =
      '0xf2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2';
    const originOwner = SIGNER;
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': inferredIcaOwnerA,
      '0x2222222222222222222222222222222222222222': inferredIcaOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([{ topics: [], data: '0x' }]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerProbeCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN || chainName === 'anvil3') {
            return SIGNER;
          }
          throw new Error(`unknown chain ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error('unknown domain');
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) {
            return {};
          }
          originSignerProbeCalls += 1;
          throw new Error(`origin signer probe failed for ${chainName}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].transactions).to.have.length(2);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      const submitter = batches[0].config.submitter as any;
      expect(submitter.chain).to.equal('anvil3');
      expect(submitter.owner).to.equal(SIGNER);
      expect(submitter.internalSubmitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(provider.getLogs.callCount).to.equal(2);
      expect(chainNameCalls).to.equal(1);
      expect(originSignerProbeCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async null signer probes across event-derived ICA inferences', async () => {
    const inferredIcaOwnerA = '0xa9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9';
    const inferredIcaOwnerB = '0xbabababababababababababababababababababa';
    const destinationRouterAddress =
      '0xcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcb';
    const originOwner = '0xdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdc';
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000edededededededededededededededededededed';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': inferredIcaOwnerA,
      '0x2222222222222222222222222222222222222222': inferredIcaOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([{ topics: [], data: '0x' }]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerProbeCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error('unknown domain');
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) {
            return {};
          }
          originSignerProbeCalls += 1;
          return null;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].transactions).to.have.length(2);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(provider.getLogs.callCount).to.equal(2);
      expect(chainNameCalls).to.equal(1);
      expect(originSignerProbeCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3 ?? 0).to.equal(0);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async undefined signer probes across event-derived ICA inferences', async () => {
    const inferredIcaOwnerA = '0xe1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1';
    const inferredIcaOwnerB = '0xe2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2';
    const destinationRouterAddress =
      '0xe3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3';
    const originOwner = '0xe4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4';
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': inferredIcaOwnerA,
      '0x2222222222222222222222222222222222222222': inferredIcaOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([{ topics: [], data: '0x' }]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerProbeCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error('unknown domain');
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) {
            return {};
          }
          originSignerProbeCalls += 1;
          return undefined;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].transactions).to.have.length(2);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(provider.getLogs.callCount).to.equal(2);
      expect(chainNameCalls).to.equal(1);
      expect(originSignerProbeCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3 ?? 0).to.equal(0);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async false signer probes across event-derived ICA inferences', async () => {
    const inferredIcaOwnerA = '0xe6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6';
    const inferredIcaOwnerB = '0xe7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7';
    const destinationRouterAddress =
      '0xe8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8';
    const originOwner = '0xe9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9';
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000eaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaea';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': inferredIcaOwnerA,
      '0x2222222222222222222222222222222222222222': inferredIcaOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([{ topics: [], data: '0x' }]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerProbeCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error('unknown domain');
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) {
            return {};
          }
          originSignerProbeCalls += 1;
          return false;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].transactions).to.have.length(2);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(provider.getLogs.callCount).to.equal(2);
      expect(chainNameCalls).to.equal(1);
      expect(originSignerProbeCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3 ?? 0).to.equal(0);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches unavailable origin signer probes across event-derived ICA inferences', async () => {
    const inferredIcaOwnerA = '0xebebebebebebebebebebebebebebebebebebebeb';
    const inferredIcaOwnerB = '0xecececececececececececececececececececec';
    const destinationRouterAddress =
      '0xedededededededededededededededededededed';
    const originOwner = '0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee';
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000efefefefefefefefefefefefefefefefefefefef';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': inferredIcaOwnerA,
      '0x2222222222222222222222222222222222222222': inferredIcaOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([{ topics: [], data: '0x' }]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerProbeCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error('unknown domain');
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) {
            return {};
          }
          originSignerProbeCalls += 1;
          return null;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].transactions).to.have.length(2);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(provider.getLogs.callCount).to.equal(2);
      expect(chainNameCalls).to.equal(1);
      expect(originSignerProbeCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3 ?? 0).to.equal(0);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches undefined origin signer probes across event-derived ICA inferences', async () => {
    const inferredIcaOwnerA = '0xf0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0';
    const inferredIcaOwnerB = '0xf1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1';
    const destinationRouterAddress =
      '0xf2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2';
    const originOwner = '0xf3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3';
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': inferredIcaOwnerA,
      '0x2222222222222222222222222222222222222222': inferredIcaOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([{ topics: [], data: '0x' }]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerProbeCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error('unknown domain');
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) {
            return {};
          }
          originSignerProbeCalls += 1;
          return undefined;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].transactions).to.have.length(2);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(provider.getLogs.callCount).to.equal(2);
      expect(chainNameCalls).to.equal(1);
      expect(originSignerProbeCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3 ?? 0).to.equal(0);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches false origin signer probes across event-derived ICA inferences', async () => {
    const inferredIcaOwnerA = '0xf5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5';
    const inferredIcaOwnerB = '0xf6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6';
    const destinationRouterAddress =
      '0xf7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7';
    const originOwner = '0xf8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8';
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': inferredIcaOwnerA,
      '0x2222222222222222222222222222222222222222': inferredIcaOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([{ topics: [], data: '0x' }]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerProbeCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error('unknown domain');
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) {
            return {};
          }
          originSignerProbeCalls += 1;
          return false;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].transactions).to.have.length(2);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(provider.getLogs.callCount).to.equal(2);
      expect(chainNameCalls).to.equal(1);
      expect(originSignerProbeCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3 ?? 0).to.equal(0);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches invalid origin signer-address probes across event-derived ICA inferences', async () => {
    const inferredIcaOwnerA = '0xfafafafafafafafafafafafafafafafafafafafa';
    const inferredIcaOwnerB = '0xfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfb';
    const destinationRouterAddress =
      '0xfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfc';
    const originOwner = '0xfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfd';
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000fefefefefefefefefefefefefefefefefefefefe';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': inferredIcaOwnerA,
      '0x2222222222222222222222222222222222222222': inferredIcaOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([{ topics: [], data: '0x' }]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerProbeCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          return 'not-an-evm-address';
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error('unknown domain');
        },
        tryGetSigner: (chainName: string) => {
          if (chainName !== CHAIN) {
            originSignerProbeCalls += 1;
          }
          return {};
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].transactions).to.have.length(2);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(provider.getLogs.callCount).to.equal(2);
      expect(chainNameCalls).to.equal(1);
      expect(originSignerProbeCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches throwing origin signer-address probes across event-derived ICA inferences', async () => {
    const inferredIcaOwnerA = '0x0101010101010101010101010101010101010101';
    const inferredIcaOwnerB = '0x0202020202020202020202020202020202020202';
    const destinationRouterAddress =
      '0x0303030303030303030303030303030303030303';
    const originOwner = '0x0404040404040404040404040404040404040404';
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x0000000000000000000000000505050505050505050505050505050505050505';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': inferredIcaOwnerA,
      '0x2222222222222222222222222222222222222222': inferredIcaOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([{ topics: [], data: '0x' }]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerProbeCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error('unknown domain');
        },
        tryGetSigner: (chainName: string) => {
          if (chainName !== CHAIN) {
            originSignerProbeCalls += 1;
          }
          return {};
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].transactions).to.have.length(2);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(provider.getLogs.callCount).to.equal(2);
      expect(chainNameCalls).to.equal(1);
      expect(originSignerProbeCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches malformed async-reject signer probe fallback across event-derived ICA inferences', async () => {
    const inferredIcaOwnerA = '0xa4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4';
    const inferredIcaOwnerB = '0xb5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5';
    const destinationRouterAddress =
      '0xc6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6';
    const originOwner = '0xd7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7';
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': inferredIcaOwnerA,
      '0x2222222222222222222222222222222222222222': inferredIcaOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([{ topics: [], data: '0x' }]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerProbeCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          return 'not-an-evm-address';
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error('unknown domain');
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) {
            return {};
          }
          originSignerProbeCalls += 1;
          throw new Error(`origin signer probe failed for ${chainName}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].transactions).to.have.length(2);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(provider.getLogs.callCount).to.equal(2);
      expect(chainNameCalls).to.equal(1);
      expect(originSignerProbeCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches zero-address async-reject signer probe fallback across event-derived ICA inferences', async () => {
    const inferredIcaOwnerA = '0xa7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a7';
    const inferredIcaOwnerB = '0xb8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8';
    const destinationRouterAddress =
      '0xc9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9';
    const originOwner = '0xdadadadadadadadadadadadadadadadadadadada';
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000ebebebebebebebebebebebebebebebebebebebeb';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': inferredIcaOwnerA,
      '0x2222222222222222222222222222222222222222': inferredIcaOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([{ topics: [], data: '0x' }]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerProbeCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          return ethersConstants.AddressZero;
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error('unknown domain');
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) {
            return {};
          }
          originSignerProbeCalls += 1;
          throw new Error(`origin signer probe failed for ${chainName}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].transactions).to.have.length(2);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(provider.getLogs.callCount).to.equal(2);
      expect(chainNameCalls).to.equal(1);
      expect(originSignerProbeCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches throwing async-reject signer probe fallback across event-derived ICA inferences', async () => {
    const inferredIcaOwnerA = '0xb9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9';
    const inferredIcaOwnerB = '0xcacacacacacacacacacacacacacacacacacacaca';
    const destinationRouterAddress =
      '0xdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdb';
    const originOwner = '0xecececececececececececececececececececec';
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000fdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfd';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': inferredIcaOwnerA,
      '0x2222222222222222222222222222222222222222': inferredIcaOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([{ topics: [], data: '0x' }]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerProbeCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error('unknown domain');
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) {
            return {};
          }
          originSignerProbeCalls += 1;
          throw new Error(`origin signer probe failed for ${chainName}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].transactions).to.have.length(2);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(provider.getLogs.callCount).to.equal(2);
      expect(chainNameCalls).to.equal(1);
      expect(originSignerProbeCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches no-tryGetSigner origin signer lookup failures across event-derived ICA inferences', async () => {
    const inferredIcaOwnerA = '0xb1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1';
    const inferredIcaOwnerB = '0xc2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2';
    const destinationRouterAddress =
      '0xd3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3';
    const originOwner = '0xe4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4';
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': inferredIcaOwnerA,
      '0x2222222222222222222222222222222222222222': inferredIcaOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([{ topics: [], data: '0x' }]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let chainNameCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error('origin signer unavailable');
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error('unknown domain');
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].transactions).to.have.length(2);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(provider.getLogs.callCount).to.equal(2);
      expect(chainNameCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('ignores unknown registry chains while deriving direct ICA owner fallback', async () => {
    const inferredIcaOwner = '0x1212121212121212121212121212121212121212';
    const destinationRouterAddress =
      '0x3434343434343434343434343434343434343434';
    const originRouterAddress = '0x5656565656565656565656565656565656565656';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              inferredIcaOwner,
          } as any;
        }

        throw new Error('unexpected router');
      });

    const context = {
      multiProvider: {
        getProtocol: (chainName: string) => {
          if (chainName === 'unknownChain') {
            throw new Error('unknown chain metadata');
          }
          return ProtocolType.Ethereum;
        },
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === 'anvil3') return {};
          return null;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          unknownChain: {
            interchainAccountRouter:
              '0x7777777777777777777777777777777777777777',
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      expect((batches[0].config.submitter as any).chain).to.equal('anvil3');
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('ignores zero-address origin routers while deriving direct ICA owner fallback', async () => {
    const inferredIcaOwner = '0x1313131313131313131313131313131313131313';
    const destinationRouterAddress =
      '0x3434343434343434343434343434343434343434';
    const originRouterAddress = '0x5656565656565656565656565656565656565656';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              inferredIcaOwner,
          } as any;
        }

        throw new Error('unexpected router');
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === 'anvil3') return {};
          return null;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          zeroRouterChain: {
            interchainAccountRouter: ethersConstants.AddressZero,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      expect((batches[0].config.submitter as any).chain).to.equal('anvil3');
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('ignores invalid origin routers while deriving direct ICA owner fallback', async () => {
    const inferredIcaOwner = '0x1414141414141414141414141414141414141414';
    const destinationRouterAddress =
      '0x3434343434343434343434343434343434343434';
    const originRouterAddress = '0x5656565656565656565656565656565656565656';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              inferredIcaOwner,
          } as any;
        }

        throw new Error('unexpected router');
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === 'anvil3') return {};
          return null;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          invalidRouterChain: {
            interchainAccountRouter: 'not-an-address',
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      expect((batches[0].config.submitter as any).chain).to.equal('anvil3');
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('falls back to jsonRpc when direct ICA owner fallback derived account is malformed', async () => {
    const inferredIcaOwner = '0x1515151515151515151515151515151515151515';
    const destinationRouterAddress =
      '0x3535353535353535353535353535353535353535';
    const originRouterAddress = '0x5757575757575757575757575757575757575757';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([]),
    };

    let derivationCalls = 0;
    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']:
              async () => {
                derivationCalls += 1;
                return 'not-an-evm-address';
              },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
        tryGetSigner: (chainName: string) =>
          chainName === 'anvil3' ? {} : null,
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any, { ...TX, data: '0xdeadbeef' } as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].transactions).to.have.length(2);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(provider.getLogs.callCount).to.equal(1);
      expect(derivationCalls).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('falls back to jsonRpc when direct ICA owner fallback derived account is zero', async () => {
    const inferredIcaOwner = '0x1616161616161616161616161616161616161616';
    const destinationRouterAddress =
      '0x3636363636363636363636363636363636363636';
    const originRouterAddress = '0x5858585858585858585858585858585858585858';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([]),
    };

    let derivationCalls = 0;
    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']:
              async () => {
                derivationCalls += 1;
                return ethersConstants.AddressZero;
              },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
        tryGetSigner: (chainName: string) =>
          chainName === 'anvil3' ? {} : null,
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any, { ...TX, data: '0xdeadbeef' } as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].transactions).to.have.length(2);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(provider.getLogs.callCount).to.equal(1);
      expect(derivationCalls).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches protocol checks while deriving direct ICA owner fallback', async () => {
    const inferredIcaOwnerA = '0x1111111111111111111111111111111111111111';
    const destinationRouterAddress =
      '0x3434343434343434343434343434343434343434';
    const originRouterAddress = '0x5656565656565656565656565656565656565656';

    const ownerByTarget: Record<string, string> = {
      '0xabababababababababababababababababababab': inferredIcaOwnerA,
      '0xcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcd': inferredIcaOwnerA,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              inferredIcaOwnerA,
          } as any;
        }

        throw new Error('unexpected router');
      });

    const protocolCalls: Record<string, number> = {};
    let registryReads = 0;
    const context = {
      multiProvider: {
        getProtocol: (chainName: string) => {
          protocolCalls[chainName] = (protocolCalls[chainName] ?? 0) + 1;
          if (chainName === 'unknownChain') {
            throw new Error('unknown chain metadata');
          }
          return ProtocolType.Ethereum;
        },
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === 'anvil3') return {};
          return null;
        },
      },
      registry: {
        getAddresses: async () => {
          registryReads += 1;
          return {
            [CHAIN]: {
              interchainAccountRouter: destinationRouterAddress,
            },
            unknownChain: {
              interchainAccountRouter:
                '0x7777777777777777777777777777777777777777',
            },
            anvil3: {
              interchainAccountRouter: originRouterAddress,
            },
          };
        },
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0xABABABABABABABABABABABABABABABABABABABAB' } as any,
          { ...TX, to: '0xCDCDCDCDCDCDCDCDCDCDCDCDCDCDCDCDCDCDCDCD' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      expect(protocolCalls.unknownChain).to.equal(1);
      expect(protocolCalls.anvil3).to.equal(1);
      expect(registryReads).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('falls back to jsonRpc when direct ICA registry lookup fails', async () => {
    const inferredIcaOwner = '0x9090909090909090909090909090909090909090';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([]),
    };

    let registryReads = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
      },
      registry: {
        getAddresses: async () => {
          registryReads += 1;
          throw new Error('registry unavailable');
        },
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any, TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(provider.getLogs.callCount).to.equal(0);
      expect(registryReads).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
    }
  });

  it('falls back to jsonRpc when direct ICA registry lookup returns empty value', async () => {
    const inferredIcaOwner = '0x9191919191919191919191919191919191919191';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([]),
    };

    let registryReads = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
      },
      registry: {
        getAddresses: async () => {
          registryReads += 1;
          return undefined as any;
        },
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any, TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(provider.getLogs.callCount).to.equal(0);
      expect(registryReads).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
    }
  });

  it('falls back to jsonRpc when direct ICA destination router address is invalid', async () => {
    const inferredIcaOwner = '0x9292929292929292929292929292929292929292';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([]),
    };

    let registryReads = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
      },
      registry: {
        getAddresses: async () => {
          registryReads += 1;
          return {
            [CHAIN]: {
              interchainAccountRouter: 'not-an-address',
            },
          };
        },
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any, TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(provider.getLogs.callCount).to.equal(0);
      expect(registryReads).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
    }
  });

  it('falls back to jsonRpc when direct ICA destination router address is zero', async () => {
    const inferredIcaOwner = '0x9292929292929292929292929292929292929292';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([]),
    };

    let registryReads = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
      },
      registry: {
        getAddresses: async () => {
          registryReads += 1;
          return {
            [CHAIN]: {
              interchainAccountRouter: ethersConstants.AddressZero,
            },
          };
        },
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any, TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(provider.getLogs.callCount).to.equal(0);
      expect(registryReads).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
    }
  });

  it('reuses cached destination signer in ICA fallback path', async () => {
    const inferredIcaOwner = '0x9494949494949494949494949494949494949494';
    const destinationRouterAddress =
      '0x9595959595959595959595959595959595959595';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let signerAddressCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => {
          signerAddressCalls += 1;
          if (signerAddressCalls === 1) {
            return SIGNER;
          }
          if (signerAddressCalls === 2) {
            throw new Error('destination signer unavailable');
          }
          return SIGNER;
        },
        getProvider: () => provider,
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any, TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      // first tx resolves signer once, ICA fallback reuses cached signer
      // second tx also reuses cache, so no additional signer lookups
      expect(signerAddressCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches origin provider failure in ICA fallback path', async () => {
    const inferredIcaOwner = '0x9696969696969696969696969696969696969696';
    const destinationRouterAddress =
      '0x9797979797979797979797979797979797979797';
    const originRouterAddress = '0x9898989898989898989898989898989898989898';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const destinationProvider = {
      getLogs: sinon.stub().resolves([]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const providerCalls: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: (chainName: string) => {
          providerCalls[chainName] = (providerCalls[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return destinationProvider;
          }
          if (chainName === 'anvil3') {
            throw new Error('origin provider unavailable');
          }
          throw new Error('unexpected provider chain');
        },
        tryGetSigner: () => ({}),
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any, TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(destinationProvider.getLogs.callCount).to.equal(1);
      expect(providerCalls[CHAIN]).to.equal(1);
      expect(providerCalls.anvil3).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches origin router derivation failures across direct ICA inferences', async () => {
    const inferredIcaOwner = '0xa8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8';
    const destinationRouterAddress =
      '0xb9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9';
    const originRouterAddress = '0xcacacacacacacacacacacacacacacacacacacaca';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      () =>
        ({
          owner: async () => inferredIcaOwner,
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const destinationProvider = {
      getLogs: sinon.stub().resolves([]),
    };
    const originProvider = {};

    let originDerivationCalls = 0;
    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']:
              async () => {
                originDerivationCalls += 1;
                throw new Error('origin router derivation failed');
              },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const providerCalls: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: (chainName: string) => {
          providerCalls[chainName] = (providerCalls[chainName] ?? 0) + 1;
          if (chainName === CHAIN) return destinationProvider;
          if (chainName === 'anvil3') return originProvider;
          throw new Error(`unexpected provider lookup for ${chainName}`);
        },
        tryGetSigner: () => ({}),
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].transactions).to.have.length(2);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(destinationProvider.getLogs.callCount).to.equal(1);
      expect(originDerivationCalls).to.equal(1);
      expect(providerCalls[CHAIN]).to.equal(1);
      expect(providerCalls.anvil3).to.equal(1);
      expect(ownableStub.callCount).to.equal(2);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('falls back to jsonRpc when ICA event log query fails', async () => {
    const inferredIcaOwner = '0x9292929292929292929292929292929292929292';
    const destinationRouterAddress =
      '0x9393939393939393939393939393939393939393';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().rejects(new Error('log query failed')),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any, TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(provider.getLogs.callCount).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('falls back to jsonRpc when origin signer probe throws during ICA inference', async () => {
    const inferredIcaOwner = '0x7878787878787878787878787878787878787878';
    const destinationRouterAddress =
      '0x9090909090909090909090909090909090909090';
    const originRouterAddress = '0x9191919191919191919191919191919191919191';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              inferredIcaOwner,
          } as any;
        }

        throw new Error('unexpected router');
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          throw new Error(`No chain signer set for ${chainName}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('infers ICA when origin signer probe throws but signer address lookup succeeds', async () => {
    const inferredIcaOwner = '0x7878787878787878787878787878787878787878';
    const destinationRouterAddress =
      '0x9090909090909090909090909090909090909090';
    const originRouterAddress = '0x9191919191919191919191919191919191919191';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([]),
    };

    let originDerivationCalls = 0;
    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async (
              owner: string,
            ) => {
              originDerivationCalls += 1;
              if (owner.toLowerCase() === SIGNER.toLowerCase()) {
                return inferredIcaOwner;
              }
              return ethersConstants.AddressZero;
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          return SIGNER;
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          throw new Error(`No chain signer set for ${chainName}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      expect((batches[0].config.submitter as any).chain).to.equal('anvil3');
      expect((batches[0].config.submitter as any).owner).to.equal(SIGNER);
      expect(
        (batches[0].config.submitter as any).internalSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(provider.getLogs.callCount).to.equal(1);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(originDerivationCalls).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches throwing origin signer probes across ICA inferences', async () => {
    const inferredIcaOwner = '0x7979797979797979797979797979797979797979';
    const destinationRouterAddress =
      '0x8080808080808080808080808080808080808080';
    const originRouterAddress = '0x8181818181818181818181818181818181818181';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              inferredIcaOwner,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          throw new Error(`No chain signer set for ${chainName}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any, TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(provider.getLogs.callCount).to.equal(1);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches malformed signer-address fallback when origin signer probe throws across ICA inferences', async () => {
    const inferredIcaOwnerA = '0x8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a';
    const inferredIcaOwnerB = '0x8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b';
    const destinationRouterAddress =
      '0x8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c';
    const originRouterAddress = '0x8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': inferredIcaOwnerA,
      '0x2222222222222222222222222222222222222222': inferredIcaOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([]),
    };

    let originDerivationCalls = 0;
    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']:
              async () => {
                originDerivationCalls += 1;
                return inferredIcaOwnerA;
              },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          return 'not-an-evm-address';
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          throw new Error(`origin signer probe failed for ${chainName}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].transactions).to.have.length(2);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(provider.getLogs.callCount).to.equal(2);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(originDerivationCalls).to.equal(0);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches malformed signer-address fallback when tryGetSigner getter throws across ICA inferences', async () => {
    const inferredIcaOwnerA = '0x9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c';
    const inferredIcaOwnerB = '0x9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d';
    const destinationRouterAddress =
      '0x9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e';
    const originRouterAddress = '0x9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': inferredIcaOwnerA,
      '0x2222222222222222222222222222222222222222': inferredIcaOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([]),
    };

    let originDerivationCalls = 0;
    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']:
              async () => {
                originDerivationCalls += 1;
                return inferredIcaOwnerA;
              },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originTryGetSignerGetterCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          return 'not-an-evm-address';
        },
        getProvider: () => provider,
        get tryGetSigner() {
          originTryGetSignerGetterCalls += 1;
          throw new Error('tryGetSigner getter failed');
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].transactions).to.have.length(2);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(provider.getLogs.callCount).to.equal(2);
      expect(originTryGetSignerGetterCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(originDerivationCalls).to.equal(0);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches zero signer-address fallback when tryGetSigner getter throws across ICA inferences', async () => {
    const inferredIcaOwnerA = '0xa0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0';
    const inferredIcaOwnerB = '0xa1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1';
    const destinationRouterAddress =
      '0xa2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2';
    const originRouterAddress = '0xa3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': inferredIcaOwnerA,
      '0x2222222222222222222222222222222222222222': inferredIcaOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([]),
    };

    let originDerivationCalls = 0;
    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']:
              async () => {
                originDerivationCalls += 1;
                return inferredIcaOwnerA;
              },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originTryGetSignerGetterCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          return ethersConstants.AddressZero;
        },
        getProvider: () => provider,
        get tryGetSigner() {
          originTryGetSignerGetterCalls += 1;
          throw new Error('tryGetSigner getter failed');
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].transactions).to.have.length(2);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(provider.getLogs.callCount).to.equal(2);
      expect(originTryGetSignerGetterCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(originDerivationCalls).to.equal(0);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches throwing signer-address fallback when tryGetSigner getter throws across ICA inferences', async () => {
    const inferredIcaOwnerA = '0xb2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2';
    const inferredIcaOwnerB = '0xb3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3';
    const destinationRouterAddress =
      '0xb4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4';
    const originRouterAddress = '0xb5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': inferredIcaOwnerA,
      '0x2222222222222222222222222222222222222222': inferredIcaOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([]),
    };

    let originDerivationCalls = 0;
    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']:
              async () => {
                originDerivationCalls += 1;
                return inferredIcaOwnerA;
              },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originTryGetSignerGetterCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        get tryGetSigner() {
          originTryGetSignerGetterCalls += 1;
          throw new Error('tryGetSigner getter failed');
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].transactions).to.have.length(2);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(provider.getLogs.callCount).to.equal(2);
      expect(originTryGetSignerGetterCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(originDerivationCalls).to.equal(0);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches successful signer-address fallback when origin signer probe throws across ICA inferences', async () => {
    const inferredIcaOwner = '0xfe00000000000000000000000000000000000000';
    const destinationRouterAddress =
      '0xfe11111111111111111111111111111111111111';
    const originRouterAddress = '0xfe22222222222222222222222222222222222222';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': inferredIcaOwner,
      '0x2222222222222222222222222222222222222222': inferredIcaOwner,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([]),
    };

    let originDerivationCalls = 0;
    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']:
              async () => {
                originDerivationCalls += 1;
                return inferredIcaOwner;
              },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerProbeCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN || chainName === 'anvil3') {
            return SIGNER;
          }
          throw new Error(`unknown signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          throw new Error(`origin signer probe failed for ${chainName}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].transactions).to.have.length(2);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      const submitter = batches[0].config.submitter as any;
      expect(submitter.chain).to.equal('anvil3');
      expect(submitter.owner).to.equal(SIGNER);
      expect(submitter.internalSubmitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(provider.getLogs.callCount).to.equal(1);
      expect(originDerivationCalls).to.equal(1);
      expect(originSignerProbeCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches successful signer-address fallback when tryGetSigner getter throws across ICA inferences', async () => {
    const inferredIcaOwner = '0xfe33333333333333333333333333333333333333';
    const destinationRouterAddress =
      '0xfe44444444444444444444444444444444444444';
    const originRouterAddress = '0xfe55555555555555555555555555555555555555';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': inferredIcaOwner,
      '0x2222222222222222222222222222222222222222': inferredIcaOwner,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([]),
    };

    let originDerivationCalls = 0;
    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']:
              async () => {
                originDerivationCalls += 1;
                return inferredIcaOwner;
              },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originTryGetSignerGetterCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN || chainName === 'anvil3') {
            return SIGNER;
          }
          throw new Error(`unknown signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        get tryGetSigner() {
          originTryGetSignerGetterCalls += 1;
          throw new Error('tryGetSigner getter failed');
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].transactions).to.have.length(2);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      const submitter = batches[0].config.submitter as any;
      expect(submitter.chain).to.equal('anvil3');
      expect(submitter.owner).to.equal(SIGNER);
      expect(submitter.internalSubmitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(provider.getLogs.callCount).to.equal(1);
      expect(originDerivationCalls).to.equal(1);
      expect(originTryGetSignerGetterCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches successful signer-address fallback when tryGetSigner is non-function across ICA inferences', async () => {
    const inferredIcaOwner = '0xfe66666666666666666666666666666666666666';
    const destinationRouterAddress =
      '0xfe77777777777777777777777777777777777777';
    const originRouterAddress = '0xfe88888888888888888888888888888888888888';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': inferredIcaOwner,
      '0x2222222222222222222222222222222222222222': inferredIcaOwner,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([]),
    };

    let originDerivationCalls = 0;
    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']:
              async () => {
                originDerivationCalls += 1;
                return inferredIcaOwner;
              },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN || chainName === 'anvil3') {
            return SIGNER;
          }
          throw new Error(`unknown signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: {},
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].transactions).to.have.length(2);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      const submitter = batches[0].config.submitter as any;
      expect(submitter.chain).to.equal('anvil3');
      expect(submitter.owner).to.equal(SIGNER);
      expect(submitter.internalSubmitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(provider.getLogs.callCount).to.equal(1);
      expect(originDerivationCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches successful bad-thenable signer probe fallback across ICA inferences', async () => {
    const inferredIcaOwner = '0xfe99999999999999999999999999999999999999';
    const destinationRouterAddress =
      '0xfeaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa';
    const originRouterAddress = '0xfebbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': inferredIcaOwner,
      '0x2222222222222222222222222222222222222222': inferredIcaOwner,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([]),
    };

    let originDerivationCalls = 0;
    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']:
              async () => {
                originDerivationCalls += 1;
                return inferredIcaOwner;
              },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerProbeCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN || chainName === 'anvil3') {
            return SIGNER;
          }
          throw new Error(`unknown signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return {
            then: () => {
              throw new Error(`bad thenable for ${chainName}`);
            },
          };
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].transactions).to.have.length(2);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      const submitter = batches[0].config.submitter as any;
      expect(submitter.chain).to.equal('anvil3');
      expect(submitter.owner).to.equal(SIGNER);
      expect(submitter.internalSubmitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(provider.getLogs.callCount).to.equal(1);
      expect(originDerivationCalls).to.equal(1);
      expect(originSignerProbeCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches malformed bad-thenable signer probes across ICA inferences', async () => {
    const inferredIcaOwner = '0xfb99999999999999999999999999999999999999';
    const destinationRouterAddress =
      '0xfbaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa';
    const originRouterAddress = '0xfbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': inferredIcaOwner,
      '0x2222222222222222222222222222222222222222': inferredIcaOwner,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([]),
    };

    let originDerivationCalls = 0;
    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']:
              async () => {
                originDerivationCalls += 1;
                return inferredIcaOwner;
              },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerProbeCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          return 'not-an-evm-address';
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return {
            then: () => {
              throw new Error(`bad thenable for ${chainName}`);
            },
          };
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].transactions).to.have.length(2);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(provider.getLogs.callCount).to.equal(1);
      expect(originDerivationCalls).to.equal(0);
      expect(originSignerProbeCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches zero-address bad-thenable signer probe fallback across ICA inferences', async () => {
    const inferredIcaOwner = '0xfd99999999999999999999999999999999999999';
    const destinationRouterAddress =
      '0xfdaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa';
    const originRouterAddress = '0xfdbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': inferredIcaOwner,
      '0x2222222222222222222222222222222222222222': inferredIcaOwner,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([]),
    };

    let originDerivationCalls = 0;
    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']:
              async () => {
                originDerivationCalls += 1;
                return inferredIcaOwner;
              },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerProbeCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          return ethersConstants.AddressZero;
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return {
            then: () => {
              throw new Error(`bad thenable for ${chainName}`);
            },
          };
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].transactions).to.have.length(2);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(provider.getLogs.callCount).to.equal(1);
      expect(originDerivationCalls).to.equal(0);
      expect(originSignerProbeCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches throwing bad-thenable signer probe fallback across ICA inferences', async () => {
    const inferredIcaOwner = '0xfc99999999999999999999999999999999999999';
    const destinationRouterAddress =
      '0xfcaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa';
    const originRouterAddress = '0xfcbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': inferredIcaOwner,
      '0x2222222222222222222222222222222222222222': inferredIcaOwner,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([]),
    };

    let originDerivationCalls = 0;
    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']:
              async () => {
                originDerivationCalls += 1;
                return inferredIcaOwner;
              },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerProbeCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error(`signer lookup failed for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return {
            then: () => {
              throw new Error(`bad thenable for ${chainName}`);
            },
          };
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].transactions).to.have.length(2);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(provider.getLogs.callCount).to.equal(1);
      expect(originDerivationCalls).to.equal(0);
      expect(originSignerProbeCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches zero signer-address fallback when origin signer probe throws across ICA inferences', async () => {
    const inferredIcaOwnerA = '0x8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e';
    const inferredIcaOwnerB = '0x8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f';
    const destinationRouterAddress =
      '0x9090909090909090909090909090909090909090';
    const originRouterAddress = '0x9191919191919191919191919191919191919191';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': inferredIcaOwnerA,
      '0x2222222222222222222222222222222222222222': inferredIcaOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([]),
    };

    let originDerivationCalls = 0;
    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']:
              async () => {
                originDerivationCalls += 1;
                return inferredIcaOwnerA;
              },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          return ethersConstants.AddressZero;
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          throw new Error(`origin signer probe failed for ${chainName}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].transactions).to.have.length(2);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(provider.getLogs.callCount).to.equal(2);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(originDerivationCalls).to.equal(0);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches unavailable origin signer probes across direct ICA inferences', async () => {
    const inferredIcaOwnerA = '0x9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a';
    const inferredIcaOwnerB = '0x9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b';
    const destinationRouterAddress =
      '0x9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c';
    const originRouterAddress = '0x9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': inferredIcaOwnerA,
      '0x2222222222222222222222222222222222222222': inferredIcaOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              inferredIcaOwnerA,
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerProbeCalls = 0;
    let providerCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: (chainName: string) => {
          providerCalls += 1;
          if (chainName === CHAIN) {
            return provider;
          }
          throw new Error(`unexpected provider lookup for ${chainName}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return null;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].transactions).to.have.length(2);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(provider.getLogs.callCount).to.equal(2);
      expect(originSignerProbeCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3 ?? 0).to.equal(0);
      expect(providerCalls).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches undefined origin signer probes across direct ICA inferences', async () => {
    const inferredIcaOwnerA = '0x8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f';
    const inferredIcaOwnerB = '0x9090909090909090909090909090909090909090';
    const destinationRouterAddress =
      '0x9191919191919191919191919191919191919191';
    const originRouterAddress = '0x9292929292929292929292929292929292929292';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': inferredIcaOwnerA,
      '0x2222222222222222222222222222222222222222': inferredIcaOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              inferredIcaOwnerA,
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerProbeCalls = 0;
    let providerCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: (chainName: string) => {
          providerCalls += 1;
          if (chainName === CHAIN) {
            return provider;
          }
          throw new Error(`unexpected provider lookup for ${chainName}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return undefined;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].transactions).to.have.length(2);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(provider.getLogs.callCount).to.equal(2);
      expect(originSignerProbeCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3 ?? 0).to.equal(0);
      expect(providerCalls).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches false origin signer probes across direct ICA inferences', async () => {
    const inferredIcaOwnerA = '0x9393939393939393939393939393939393939393';
    const inferredIcaOwnerB = '0x9494949494949494949494949494949494949494';
    const destinationRouterAddress =
      '0x9595959595959595959595959595959595959595';
    const originRouterAddress = '0x9696969696969696969696969696969696969696';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': inferredIcaOwnerA,
      '0x2222222222222222222222222222222222222222': inferredIcaOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              inferredIcaOwnerA,
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerProbeCalls = 0;
    let providerCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: (chainName: string) => {
          providerCalls += 1;
          if (chainName === CHAIN) {
            return provider;
          }
          throw new Error(`unexpected provider lookup for ${chainName}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return false;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].transactions).to.have.length(2);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(provider.getLogs.callCount).to.equal(2);
      expect(originSignerProbeCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3 ?? 0).to.equal(0);
      expect(providerCalls).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('treats async null tryGetSigner origin probes as unavailable across direct ICA inferences', async () => {
    const inferredIcaOwnerA = '0x9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e';
    const inferredIcaOwnerB = '0x9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f';
    const destinationRouterAddress =
      '0xa0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0';
    const originRouterAddress = '0xa1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': inferredIcaOwnerA,
      '0x2222222222222222222222222222222222222222': inferredIcaOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              inferredIcaOwnerA,
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerProbeCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) {
            return {};
          }
          originSignerProbeCalls += 1;
          return null;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].transactions).to.have.length(2);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(provider.getLogs.callCount).to.equal(2);
      expect(originSignerProbeCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3 ?? 0).to.equal(0);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('treats async undefined tryGetSigner origin probes as unavailable across direct ICA inferences', async () => {
    const inferredIcaOwnerA = '0x9191919191919191919191919191919191919191';
    const inferredIcaOwnerB = '0x9292929292929292929292929292929292929292';
    const destinationRouterAddress =
      '0x9393939393939393939393939393939393939393';
    const originRouterAddress = '0x9494949494949494949494949494949494949494';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': inferredIcaOwnerA,
      '0x2222222222222222222222222222222222222222': inferredIcaOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              inferredIcaOwnerA,
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerProbeCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) {
            return {};
          }
          originSignerProbeCalls += 1;
          return undefined;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].transactions).to.have.length(2);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(provider.getLogs.callCount).to.equal(2);
      expect(originSignerProbeCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3 ?? 0).to.equal(0);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('treats async false tryGetSigner origin probes as unavailable across direct ICA inferences', async () => {
    const inferredIcaOwnerA = '0x9797979797979797979797979797979797979797';
    const inferredIcaOwnerB = '0x9898989898989898989898989898989898989898';
    const destinationRouterAddress =
      '0x9999999999999999999999999999999999999999';
    const originRouterAddress = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': inferredIcaOwnerA,
      '0x2222222222222222222222222222222222222222': inferredIcaOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              inferredIcaOwnerA,
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerProbeCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) {
            return {};
          }
          originSignerProbeCalls += 1;
          return false;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].transactions).to.have.length(2);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(provider.getLogs.callCount).to.equal(2);
      expect(originSignerProbeCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3 ?? 0).to.equal(0);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches malformed async-reject signer probe fallback across ICA inferences', async () => {
    const inferredIcaOwnerA = '0xaa01010101010101010101010101010101010101';
    const inferredIcaOwnerB = '0xaa02020202020202020202020202020202020202';
    const destinationRouterAddress =
      '0xaa03030303030303030303030303030303030303';
    const originRouterAddress = '0xaa04040404040404040404040404040404040404';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': inferredIcaOwnerA,
      '0x2222222222222222222222222222222222222222': inferredIcaOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([]),
    };

    let originDerivationCalls = 0;
    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']:
              async () => {
                originDerivationCalls += 1;
                return inferredIcaOwnerA;
              },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          return 'not-an-evm-address';
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          throw new Error(`origin signer probe failed for ${chainName}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].transactions).to.have.length(2);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(provider.getLogs.callCount).to.equal(2);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(originDerivationCalls).to.equal(0);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches zero-address async-reject signer probe fallback across ICA inferences', async () => {
    const inferredIcaOwnerA = '0xab01010101010101010101010101010101010101';
    const inferredIcaOwnerB = '0xab02020202020202020202020202020202020202';
    const destinationRouterAddress =
      '0xab03030303030303030303030303030303030303';
    const originRouterAddress = '0xab04040404040404040404040404040404040404';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': inferredIcaOwnerA,
      '0x2222222222222222222222222222222222222222': inferredIcaOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([]),
    };

    let originDerivationCalls = 0;
    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']:
              async () => {
                originDerivationCalls += 1;
                return inferredIcaOwnerA;
              },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          return ethersConstants.AddressZero;
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          throw new Error(`origin signer probe failed for ${chainName}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].transactions).to.have.length(2);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(provider.getLogs.callCount).to.equal(2);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(originDerivationCalls).to.equal(0);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches throwing async-reject signer probe fallback across ICA inferences', async () => {
    const inferredIcaOwnerA = '0xac01010101010101010101010101010101010101';
    const inferredIcaOwnerB = '0xac02020202020202020202020202020202020202';
    const destinationRouterAddress =
      '0xac03030303030303030303030303030303030303';
    const originRouterAddress = '0xac04040404040404040404040404040404040404';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': inferredIcaOwnerA,
      '0x2222222222222222222222222222222222222222': inferredIcaOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([]),
    };

    let originDerivationCalls = 0;
    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']:
              async () => {
                originDerivationCalls += 1;
                return inferredIcaOwnerA;
              },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          throw new Error(`origin signer probe failed for ${chainName}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].transactions).to.have.length(2);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(provider.getLogs.callCount).to.equal(2);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(originDerivationCalls).to.equal(0);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches successful async-reject signer probe fallback across ICA inferences', async () => {
    const inferredIcaOwner = '0xad01010101010101010101010101010101010101';
    const destinationRouterAddress =
      '0xad02020202020202020202020202020202020202';
    const originRouterAddress = '0xad03030303030303030303030303030303030303';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': inferredIcaOwner,
      '0x2222222222222222222222222222222222222222': inferredIcaOwner,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([]),
    };

    let originDerivationCalls = 0;
    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']:
              async () => {
                originDerivationCalls += 1;
                return inferredIcaOwner;
              },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerProbeCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN || chainName === 'anvil3') {
            return SIGNER;
          }
          throw new Error(`unknown signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          throw new Error(`origin signer probe failed for ${chainName}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].transactions).to.have.length(2);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      const submitter = batches[0].config.submitter as any;
      expect(submitter.chain).to.equal('anvil3');
      expect(submitter.owner).to.equal(SIGNER);
      expect(submitter.internalSubmitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(provider.getLogs.callCount).to.equal(1);
      expect(originDerivationCalls).to.equal(1);
      expect(originSignerProbeCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches invalid origin signer-address probes across direct ICA inferences', async () => {
    const inferredIcaOwnerA = '0x3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a';
    const inferredIcaOwnerB = '0x3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b';
    const destinationRouterAddress =
      '0x3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c';
    const originRouterAddress = '0x3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': inferredIcaOwnerA,
      '0x2222222222222222222222222222222222222222': inferredIcaOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([]),
    };

    let originDerivationCalls = 0;
    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']:
              async () => {
                originDerivationCalls += 1;
                return inferredIcaOwnerA;
              },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerProbeCalls = 0;
    let providerCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          return 'not-an-evm-address';
        },
        getProvider: (chainName: string) => {
          providerCalls += 1;
          if (chainName === CHAIN) {
            return provider;
          }
          throw new Error(`unexpected provider lookup for ${chainName}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName !== CHAIN) {
            originSignerProbeCalls += 1;
          }
          return {};
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].transactions).to.have.length(2);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(provider.getLogs.callCount).to.equal(2);
      expect(originSignerProbeCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(originDerivationCalls).to.equal(0);
      expect(providerCalls).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches throwing origin signer-address probes across direct ICA inferences', async () => {
    const inferredIcaOwnerA = '0x4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a';
    const inferredIcaOwnerB = '0x4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b';
    const destinationRouterAddress =
      '0x4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c';
    const originRouterAddress = '0x4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': inferredIcaOwnerA,
      '0x2222222222222222222222222222222222222222': inferredIcaOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([]),
    };

    let originDerivationCalls = 0;
    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']:
              async () => {
                originDerivationCalls += 1;
                return inferredIcaOwnerA;
              },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerProbeCalls = 0;
    let providerCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: (chainName: string) => {
          providerCalls += 1;
          if (chainName === CHAIN) {
            return provider;
          }
          throw new Error(`unexpected provider lookup for ${chainName}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName !== CHAIN) {
            originSignerProbeCalls += 1;
          }
          return {};
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].transactions).to.have.length(2);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(originSignerProbeCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(originDerivationCalls).to.equal(0);
      expect(providerCalls).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('avoids origin signer address lookup when ICA origin signer is unavailable', async () => {
    const inferredIcaOwner = '0x4545454545454545454545454545454545454545';
    const destinationRouterAddress =
      '0x6767676767676767676767676767676767676767';
    const originRouterAddress = '0x8989898989898989898989898989898989898989';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              inferredIcaOwner,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => (chainName === CHAIN ? {} : null),
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(originSignerAddressLookups).to.equal(0);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches origin signer availability across event-derived ICA inferences', async () => {
    const inferredIcaOwnerA = '0xa1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1';
    const inferredIcaOwnerB = '0xb2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2';
    const destinationRouterAddress =
      '0xc3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3';
    const originRouterBytes32 =
      '0x000000000000000000000000d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': inferredIcaOwnerA,
      '0x2222222222222222222222222222222222222222': inferredIcaOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([{ topics: [], data: '0x' }]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
            interface: {
              parseLog: (_log: unknown) => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: SIGNER,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let tryGetSignerCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          if (domainId === 31347) return 'anvil3';
          throw new Error('unknown domain');
        },
        tryGetSigner: (chainName: string) => {
          tryGetSignerCalls += 1;
          if (chainName === 'anvil3') return null;
          return {};
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(tryGetSignerCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(2);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3 ?? 0).to.equal(0);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches negative ICA inference results per destination chain and account', async () => {
    const inferredIcaOwner = '0x4545454545454545454545454545454545454545';
    const destinationRouterAddress =
      '0x6767676767676767676767676767676767676767';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => inferredIcaOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .throws(new Error('not timelock'));

    const provider = {
      getLogs: sinon.stub().resolves([]),
    };

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any, TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(provider.getLogs.callCount).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches timelock proposer inference per chain and timelock', async () => {
    const timelockOwner = '0x5555555555555555555555555555555555555555';
    const tx1 = { ...TX, to: '0xabababababababababababababababababababab' };
    const tx2 = { ...TX, to: '0xcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcd' };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      () =>
        ({
          owner: async () => timelockOwner,
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().resolves([]),
    };
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: SIGNER } }),
        },
      } as any);

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
      },
      registry: {
        getAddresses: async () => ({}),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [tx1 as any, tx2 as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      // first inference call scans granted+revoked logs, second tx reuses cache
      expect(provider.getLogs.callCount).to.equal(2);
      expect(timelockStub.callCount).to.be.greaterThan(0);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
    }
  });

  it('falls back to default timelock proposer when hasRole checks fail', async () => {
    const timelockOwner = '0x5555555555555555555555555555555555555555';
    const tx1 = { ...TX, to: '0xabababababababababababababababababababab' };
    const tx2 = { ...TX, to: '0xcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcd' };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      () =>
        ({
          owner: async () => timelockOwner,
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().resolves([]),
    };
    const hasRoleStub = sinon.stub().callsFake(async () => {
      throw new Error('role lookup failed');
    });
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: hasRoleStub,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: SIGNER } }),
        },
      } as any);

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
      },
      registry: {
        getAddresses: async () => ({}),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [tx1 as any, tx2 as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(provider.getLogs.callCount).to.equal(0);
      // first inference performs open-role and signer-role checks; second tx reuses cache
      expect(hasRoleStub.callCount).to.equal(2);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
    }
  });

  it('uses default timelock proposer when proposer role is open', async () => {
    const timelockOwner = '0x5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a';
    const tx1 = { ...TX, to: '0xabababababababababababababababababababab' };
    const tx2 = { ...TX, to: '0xcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcd' };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      () =>
        ({
          owner: async () => timelockOwner,
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().resolves([]),
    };
    const hasRoleStub = sinon
      .stub()
      .callsFake(async (_role: string, account: string) =>
        eqAddress(account, ethersConstants.AddressZero),
      );
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: hasRoleStub,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: SIGNER } }),
        },
      } as any);

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
      },
      registry: {
        getAddresses: async () => ({}),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [tx1 as any, tx2 as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].transactions).to.have.length(2);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(provider.getLogs.callCount).to.equal(0);
      // first inference checks open role and signer role once; second tx reuses cache
      expect(hasRoleStub.callCount).to.equal(2);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
    }
  });

  it('uses default timelock proposer when signer has proposer role', async () => {
    const timelockOwner = '0x6a6a6a6a6a6a6a6a6a6a6a6a6a6a6a6a6a6a6a6a';
    const tx1 = { ...TX, to: '0xabababababababababababababababababababab' };
    const tx2 = { ...TX, to: '0xcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcd' };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      () =>
        ({
          owner: async () => timelockOwner,
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().resolves([]),
    };
    const hasRoleStub = sinon
      .stub()
      .callsFake(async (_role: string, account: string) =>
        eqAddress(account, SIGNER),
      );
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: hasRoleStub,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: SIGNER } }),
        },
      } as any);

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
      },
      registry: {
        getAddresses: async () => ({}),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [tx1 as any, tx2 as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].transactions).to.have.length(2);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(provider.getLogs.callCount).to.equal(0);
      // first inference checks open role and signer role once; second tx reuses cache
      expect(hasRoleStub.callCount).to.equal(2);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
    }
  });

  it('uses default timelock proposer when padded uppercase signer has proposer role', async () => {
    const timelockOwner = '0x7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b';
    const tx1 = { ...TX, to: '0xabababababababababababababababababababab' };
    const tx2 = { ...TX, to: '0xcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcd' };
    const normalizedSigner = `0x${SIGNER.slice(2).toLowerCase()}`;

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      () =>
        ({
          owner: async () => timelockOwner,
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().resolves([]),
    };
    const hasRoleAccounts: string[] = [];
    const hasRoleStub = sinon
      .stub()
      .callsFake(async (_role: string, account: string) => {
        hasRoleAccounts.push(account);
        return eqAddress(account, normalizedSigner);
      });
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: hasRoleStub,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: SIGNER } }),
        },
      } as any);

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => `  0X${SIGNER.slice(2).toUpperCase()}  `,
        getProvider: () => provider,
      },
      registry: {
        getAddresses: async () => ({}),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [tx1 as any, tx2 as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].transactions).to.have.length(2);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(provider.getLogs.callCount).to.equal(0);
      expect(hasRoleStub.callCount).to.equal(2);
      expect(hasRoleAccounts).to.have.length(2);
      expect(
        eqAddress(hasRoleAccounts[0], ethersConstants.AddressZero),
      ).to.equal(true);
      expect(eqAddress(hasRoleAccounts[1], normalizedSigner)).to.equal(true);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
    }
  });

  it('reuses cached signer during timelock proposer inference', async () => {
    const timelockOwner = '0x5555555555555555555555555555555555555555';
    const tx1 = { ...TX, to: '0xabababababababababababababababababababab' };
    const tx2 = { ...TX, to: '0xcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcd' };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      () =>
        ({
          owner: async () => timelockOwner,
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().resolves([]),
    };
    const hasRoleStub = sinon.stub().resolves(false);
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: hasRoleStub,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: SIGNER } }),
        },
      } as any);

    let signerAddressCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => {
          signerAddressCalls += 1;
          if (signerAddressCalls === 2) {
            throw new Error('signer lookup failed');
          }
          return SIGNER;
        },
        getProvider: () => provider,
      },
      registry: {
        getAddresses: async () => ({}),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [tx1 as any, tx2 as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      // first inference queries granted+revoked logs, second tx reuses cache
      expect(provider.getLogs.callCount).to.equal(2);
      expect(hasRoleStub.callCount).to.equal(2);
      // signer address is resolved once and reused from cache
      expect(signerAddressCalls).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
    }
  });

  it('falls back to default timelock proposer when role log queries fail', async () => {
    const timelockOwner = '0x5555555555555555555555555555555555555555';
    const tx1 = { ...TX, to: '0xabababababababababababababababababababab' };
    const tx2 = { ...TX, to: '0xcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcd' };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      () =>
        ({
          owner: async () => timelockOwner,
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().rejects(new Error('log query failed')),
    };
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: SIGNER } }),
        },
      } as any);

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
      },
      registry: {
        getAddresses: async () => ({}),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [tx1 as any, tx2 as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      // granted + revoked queries attempted once; second tx reuses cache
      expect(provider.getLogs.callCount).to.equal(2);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
    }
  });

  it('falls back to default timelock proposer when role topics cannot be derived', async () => {
    const timelockOwner = '0x5555555555555555555555555555555555555555';
    const tx1 = { ...TX, to: '0xabababababababababababababababababababab' };
    const tx2 = { ...TX, to: '0xcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcd' };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      () =>
        ({
          owner: async () => timelockOwner,
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().resolves([]),
    };
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: () => {
            throw new Error('topic lookup failed');
          },
          parseLog: (_log: unknown) => ({ args: { account: SIGNER } }),
        },
      } as any);

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
      },
      registry: {
        getAddresses: async () => ({}),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [tx1 as any, tx2 as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(provider.getLogs.callCount).to.equal(0);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
    }
  });

  it('ignores malformed timelock proposer role logs and still caches result', async () => {
    const timelockOwner = '0x5555555555555555555555555555555555555555';
    const tx1 = { ...TX, to: '0xabababababababababababababababababababab' };
    const tx2 = { ...TX, to: '0xcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcd' };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      () =>
        ({
          owner: async () => timelockOwner,
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().resolves([{ topics: [], data: '0x' }]),
    };
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: () => {
            throw new Error('malformed role event');
          },
        },
      } as any);

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
      },
      registry: {
        getAddresses: async () => ({}),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [tx1 as any, tx2 as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(provider.getLogs.callCount).to.equal(2);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
    }
  });

  it('uses valid timelock proposer role logs even when some logs are malformed', async () => {
    const timelockOwner = '0x5555555555555555555555555555555555555555';
    const safeProposer = '0x6666666666666666666666666666666666666666';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      () =>
        ({
          owner: async () => timelockOwner,
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== safeProposer.toLowerCase()) {
          throw new Error('not safe');
        }
        return {
          getThreshold: async () => 1,
        } as any;
      });

    const malformedLog = { topics: ['0xmalformed'], data: '0x' };
    const validGrantedLog = { topics: ['0xvalid-granted'], data: '0x' };
    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (filter.topics?.[0] === 'RoleGranted') {
          return [malformedLog, validGrantedLog];
        }
        return [];
      }),
    };
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (log: any) => {
            if (log === malformedLog) {
              throw new Error('malformed role event');
            }
            return { args: { account: safeProposer } };
          },
        },
      } as any);

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
      },
      registry: {
        getAddresses: async () => ({}),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.GNOSIS_TX_BUILDER);
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.safeAddress,
      ).to.equal(safeProposer);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
    }
  });

  it('respects chronological role grant/revoke order for timelock proposers', async () => {
    const timelockOwner = '0x5656565656565656565656565656565656565656';
    const safeProposer = '0x6767676767676767676767676767676767676767';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      () =>
        ({
          owner: async () => timelockOwner,
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== safeProposer.toLowerCase()) {
          throw new Error('not safe');
        }
        return {
          getThreshold: async () => 1,
        } as any;
      });

    const grantedEarly = {
      topics: ['0xgranted-early'],
      data: '0x',
      blockNumber: 100,
      transactionIndex: 0,
      logIndex: 1,
    };
    const revokedMid = {
      topics: ['0xrevoked-mid'],
      data: '0x',
      blockNumber: 101,
      transactionIndex: 0,
      logIndex: 1,
    };
    const grantedLate = {
      topics: ['0xgranted-late'],
      data: '0x',
      blockNumber: 102,
      transactionIndex: 0,
      logIndex: 1,
    };

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (filter.topics?.[0] === 'RoleGranted') {
          return [grantedEarly, grantedLate];
        }
        return [revokedMid];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: () => ({ args: { account: safeProposer } }),
        },
      } as any);

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
      },
      registry: {
        getAddresses: async () => ({}),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.GNOSIS_TX_BUILDER);
      expect(
        (
          batches[0].config.submitter as any
        ).proposerSubmitter.safeAddress.toLowerCase(),
      ).to.equal(safeProposer.toLowerCase());
      expect(provider.getLogs.callCount).to.equal(2);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
    }
  });

  it('reconstructs timelock proposer roles correctly from unsorted role logs', async () => {
    const timelockOwner = '0x5858585858585858585858585858585858585858';
    const safeProposer = '0x6969696969696969696969696969696969696969';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      () =>
        ({
          owner: async () => timelockOwner,
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== safeProposer.toLowerCase()) {
          throw new Error('not safe');
        }
        return {
          getThreshold: async () => 1,
        } as any;
      });

    const earlyGrant = {
      topics: ['0xgrant-early'],
      data: '0x',
      blockNumber: 100,
      transactionIndex: 0,
      logIndex: 1,
    };
    const midRevoke = {
      topics: ['0xrevoke-mid'],
      data: '0x',
      blockNumber: 101,
      transactionIndex: 0,
      logIndex: 1,
    };
    const lateGrant = {
      topics: ['0xgrant-late'],
      data: '0x',
      blockNumber: 102,
      transactionIndex: 0,
      logIndex: 1,
    };

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (filter.topics?.[0] === 'RoleGranted') {
          // intentionally unsorted newest-first
          return [lateGrant, earlyGrant];
        }
        return [midRevoke];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: () => ({ args: { account: safeProposer } }),
        },
      } as any);

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
      },
      registry: {
        getAddresses: async () => ({}),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.GNOSIS_TX_BUILDER);
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.safeAddress,
      ).to.equal(safeProposer.toLowerCase());
      expect(provider.getLogs.callCount).to.equal(2);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
    }
  });

  it('uses transaction/log index ordering for timelock role logs in same block', async () => {
    const timelockOwner = '0x5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a';
    const safeProposer = '0x6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      () =>
        ({
          owner: async () => timelockOwner,
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== safeProposer.toLowerCase()) {
          throw new Error('not safe');
        }
        return {
          getThreshold: async () => 1,
        } as any;
      });

    const earlyGrant = {
      topics: ['0xgrant-early'],
      data: '0x',
      blockNumber: 300,
      transactionIndex: 1,
      logIndex: 2,
    };
    const middleRevoke = {
      topics: ['0xrevoke-middle'],
      data: '0x',
      blockNumber: 300,
      transactionIndex: 2,
      logIndex: 10,
    };
    const lateGrant = {
      topics: ['0xgrant-late'],
      data: '0x',
      blockNumber: 300,
      transactionIndex: 3,
      logIndex: 1,
    };

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (filter.topics?.[0] === 'RoleGranted') {
          // intentionally unsorted newest-first
          return [lateGrant, earlyGrant];
        }
        return [middleRevoke];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: () => ({ args: { account: safeProposer } }),
        },
      } as any);

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
      },
      registry: {
        getAddresses: async () => ({}),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.GNOSIS_TX_BUILDER);
      expect(
        (
          batches[0].config.submitter as any
        ).proposerSubmitter.safeAddress.toLowerCase(),
      ).to.equal(safeProposer.toLowerCase());
      expect(provider.getLogs.callCount).to.equal(2);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
    }
  });

  it('treats malformed blockNumber as lower for timelock role ordering even with higher tx/log indexes', async () => {
    const timelockOwner = '0x5959595959595959595959595959595959595959';
    const safeProposer = '0x6a6a6a6a6a6a6a6a6a6a6a6a6a6a6a6a6a6a6a6a';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      () =>
        ({
          owner: async () => timelockOwner,
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== safeProposer.toLowerCase()) {
          throw new Error('not safe');
        }
        return {
          getThreshold: async () => 1,
        } as any;
      });

    const validGrant = {
      topics: ['0xgrant-valid'],
      data: '0x',
      blockNumber: 299,
      transactionIndex: 1,
      logIndex: 1,
    };
    const malformedBlockGrant = {
      topics: ['0xgrant-malformed-block'],
      data: '0x',
      blockNumber: 'not-a-number',
      transactionIndex: 999,
      logIndex: 999,
    };
    const revoke = {
      topics: ['0xrevoke'],
      data: '0x',
      blockNumber: 298,
      transactionIndex: 0,
      logIndex: 0,
    };

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (filter.topics?.[0] === 'RoleGranted') {
          return [malformedBlockGrant, validGrant];
        }
        return [revoke];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: () => ({ args: { account: safeProposer } }),
        },
      } as any);

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
      },
      registry: {
        getAddresses: async () => ({}),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.GNOSIS_TX_BUILDER);
      expect(
        (
          batches[0].config.submitter as any
        ).proposerSubmitter.safeAddress.toLowerCase(),
      ).to.equal(safeProposer.toLowerCase());
      expect(provider.getLogs.callCount).to.equal(2);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
    }
  });

  it('treats malformed transactionIndex as lower for timelock role logs in same block', async () => {
    const timelockOwner = '0x5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e';
    const safeProposer = '0x6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      () =>
        ({
          owner: async () => timelockOwner,
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== safeProposer.toLowerCase()) {
          throw new Error('not safe');
        }
        return {
          getThreshold: async () => 1,
        } as any;
      });

    const validGrant = {
      topics: ['0xgrant-valid'],
      data: '0x',
      blockNumber: 301,
      transactionIndex: 2,
      logIndex: 1,
    };
    const malformedTxIndexGrant = {
      topics: ['0xgrant-malformed-tx-index'],
      data: '0x',
      blockNumber: 301,
      transactionIndex: -1,
      logIndex: 999,
    };
    const revoke = {
      topics: ['0xrevoke'],
      data: '0x',
      blockNumber: 301,
      transactionIndex: 1,
      logIndex: 1,
    };

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (filter.topics?.[0] === 'RoleGranted') {
          return [malformedTxIndexGrant, validGrant];
        }
        return [revoke];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: () => ({ args: { account: safeProposer } }),
        },
      } as any);

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
      },
      registry: {
        getAddresses: async () => ({}),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.GNOSIS_TX_BUILDER);
      expect(
        (
          batches[0].config.submitter as any
        ).proposerSubmitter.safeAddress.toLowerCase(),
      ).to.equal(safeProposer.toLowerCase());
      expect(provider.getLogs.callCount).to.equal(2);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
    }
  });

  it('treats non-integer string transactionIndex as lower for timelock role logs in same block', async () => {
    const timelockOwner = '0x5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f';
    const safeProposer = '0x7070707070707070707070707070707070707070';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      () =>
        ({
          owner: async () => timelockOwner,
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== safeProposer.toLowerCase()) {
          throw new Error('not safe');
        }
        return {
          getThreshold: async () => 1,
        } as any;
      });

    const validGrant = {
      topics: ['0xgrant-valid'],
      data: '0x',
      blockNumber: 301,
      transactionIndex: 2,
      logIndex: 1,
    };
    const malformedTxIndexGrant = {
      topics: ['0xgrant-malformed-string-tx-index'],
      data: '0x',
      blockNumber: 301,
      transactionIndex: '9999.9',
      logIndex: 999,
    };
    const revoke = {
      topics: ['0xrevoke'],
      data: '0x',
      blockNumber: 301,
      transactionIndex: 1,
      logIndex: 1,
    };

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (filter.topics?.[0] === 'RoleGranted') {
          return [malformedTxIndexGrant, validGrant];
        }
        return [revoke];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: () => ({ args: { account: safeProposer } }),
        },
      } as any);

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
      },
      registry: {
        getAddresses: async () => ({}),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.GNOSIS_TX_BUILDER);
      expect(
        (
          batches[0].config.submitter as any
        ).proposerSubmitter.safeAddress.toLowerCase(),
      ).to.equal(safeProposer.toLowerCase());
      expect(provider.getLogs.callCount).to.equal(2);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
    }
  });

  it('treats non-finite transactionIndex as lower for timelock role logs in same block', async () => {
    const timelockOwner = '0x5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d';
    const safeProposer = '0x6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      () =>
        ({
          owner: async () => timelockOwner,
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== safeProposer.toLowerCase()) {
          throw new Error('not safe');
        }
        return {
          getThreshold: async () => 1,
        } as any;
      });

    const validGrant = {
      topics: ['0xgrant-valid'],
      data: '0x',
      blockNumber: 302,
      transactionIndex: 2,
      logIndex: 1,
    };
    const malformedInfinityTxIndexGrant = {
      topics: ['0xgrant-malformed-infinity-tx-index'],
      data: '0x',
      blockNumber: 302,
      transactionIndex: Number.POSITIVE_INFINITY,
      logIndex: 999,
    };
    const malformedNaNTxIndexGrant = {
      topics: ['0xgrant-malformed-nan-tx-index'],
      data: '0x',
      blockNumber: 302,
      transactionIndex: Number.NaN,
      logIndex: 999,
    };
    const malformedNegativeInfinityTxIndexGrant = {
      topics: ['0xgrant-malformed-negative-infinity-tx-index'],
      data: '0x',
      blockNumber: 302,
      transactionIndex: Number.NEGATIVE_INFINITY,
      logIndex: 999,
    };
    const revoke = {
      topics: ['0xrevoke'],
      data: '0x',
      blockNumber: 302,
      transactionIndex: 1,
      logIndex: 1,
    };

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (filter.topics?.[0] === 'RoleGranted') {
          return [
            malformedInfinityTxIndexGrant,
            malformedNaNTxIndexGrant,
            malformedNegativeInfinityTxIndexGrant,
            validGrant,
          ];
        }
        return [revoke];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: () => ({ args: { account: safeProposer } }),
        },
      } as any);

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
      },
      registry: {
        getAddresses: async () => ({}),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.GNOSIS_TX_BUILDER);
      expect(
        (
          batches[0].config.submitter as any
        ).proposerSubmitter.safeAddress.toLowerCase(),
      ).to.equal(safeProposer.toLowerCase());
      expect(provider.getLogs.callCount).to.equal(2);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
    }
  });

  it('treats unsafe-number transactionIndex as lower for timelock role logs in same block', async () => {
    const timelockOwner = '0x5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a';
    const safeProposer = '0x6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      () =>
        ({
          owner: async () => timelockOwner,
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== safeProposer.toLowerCase()) {
          throw new Error('not safe');
        }
        return {
          getThreshold: async () => 1,
        } as any;
      });

    const validGrant = {
      topics: ['0xgrant-valid'],
      data: '0x',
      blockNumber: 303,
      transactionIndex: 2,
      logIndex: 1,
    };
    const malformedUnsafeTxIndexGrant = {
      topics: ['0xgrant-malformed-unsafe-tx-index'],
      data: '0x',
      blockNumber: 303,
      transactionIndex: Number.MAX_SAFE_INTEGER + 1,
      logIndex: 999,
    };
    const revoke = {
      topics: ['0xrevoke'],
      data: '0x',
      blockNumber: 303,
      transactionIndex: 1,
      logIndex: 1,
    };

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (filter.topics?.[0] === 'RoleGranted') {
          return [malformedUnsafeTxIndexGrant, validGrant];
        }
        return [revoke];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: () => ({ args: { account: safeProposer } }),
        },
      } as any);

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
      },
      registry: {
        getAddresses: async () => ({}),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.GNOSIS_TX_BUILDER);
      expect(
        (
          batches[0].config.submitter as any
        ).proposerSubmitter.safeAddress.toLowerCase(),
      ).to.equal(safeProposer.toLowerCase());
      expect(provider.getLogs.callCount).to.equal(2);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
    }
  });

  it('uses log index ordering for timelock role logs in same transaction', async () => {
    const timelockOwner = '0x5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b';
    const safeProposer = '0x6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      () =>
        ({
          owner: async () => timelockOwner,
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== safeProposer.toLowerCase()) {
          throw new Error('not safe');
        }
        return {
          getThreshold: async () => 1,
        } as any;
      });

    const earlyGrant = {
      topics: ['0xgrant-early'],
      data: '0x',
      blockNumber: 400,
      transactionIndex: 7,
      logIndex: 10,
    };
    const middleRevoke = {
      topics: ['0xrevoke-middle'],
      data: '0x',
      blockNumber: 400,
      transactionIndex: 7,
      logIndex: 11,
    };
    const lateGrant = {
      topics: ['0xgrant-late'],
      data: '0x',
      blockNumber: 400,
      transactionIndex: 7,
      logIndex: 12,
    };

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (filter.topics?.[0] === 'RoleGranted') {
          // intentionally unsorted newest-first
          return [lateGrant, earlyGrant];
        }
        return [middleRevoke];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: () => ({ args: { account: safeProposer } }),
        },
      } as any);

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
      },
      registry: {
        getAddresses: async () => ({}),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.GNOSIS_TX_BUILDER);
      expect(
        (
          batches[0].config.submitter as any
        ).proposerSubmitter.safeAddress.toLowerCase(),
      ).to.equal(safeProposer.toLowerCase());
      expect(provider.getLogs.callCount).to.equal(2);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
    }
  });

  it('treats malformed logIndex as lower for timelock role logs in same transaction', async () => {
    const timelockOwner = '0x5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f';
    const safeProposer = '0x7070707070707070707070707070707070707070';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      () =>
        ({
          owner: async () => timelockOwner,
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== safeProposer.toLowerCase()) {
          throw new Error('not safe');
        }
        return {
          getThreshold: async () => 1,
        } as any;
      });

    const validGrant = {
      topics: ['0xgrant-valid'],
      data: '0x',
      blockNumber: 401,
      transactionIndex: 7,
      logIndex: 12,
    };
    const malformedLogIndexGrant = {
      topics: ['0xgrant-malformed-log-index'],
      data: '0x',
      blockNumber: 401,
      transactionIndex: 7,
      logIndex: -1,
    };
    const revoke = {
      topics: ['0xrevoke'],
      data: '0x',
      blockNumber: 401,
      transactionIndex: 7,
      logIndex: 11,
    };

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (filter.topics?.[0] === 'RoleGranted') {
          return [malformedLogIndexGrant, validGrant];
        }
        return [revoke];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: () => ({ args: { account: safeProposer } }),
        },
      } as any);

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
      },
      registry: {
        getAddresses: async () => ({}),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.GNOSIS_TX_BUILDER);
      expect(
        (
          batches[0].config.submitter as any
        ).proposerSubmitter.safeAddress.toLowerCase(),
      ).to.equal(safeProposer.toLowerCase());
      expect(provider.getLogs.callCount).to.equal(2);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
    }
  });

  it('treats non-integer string logIndex as lower for timelock role logs in same transaction', async () => {
    const timelockOwner = '0x6060606060606060606060606060606060606060';
    const safeProposer = '0x7171717171717171717171717171717171717171';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      () =>
        ({
          owner: async () => timelockOwner,
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== safeProposer.toLowerCase()) {
          throw new Error('not safe');
        }
        return {
          getThreshold: async () => 1,
        } as any;
      });

    const validGrant = {
      topics: ['0xgrant-valid'],
      data: '0x',
      blockNumber: 402,
      transactionIndex: 8,
      logIndex: 12,
    };
    const malformedLogIndexGrant = {
      topics: ['0xgrant-malformed-string-log-index'],
      data: '0x',
      blockNumber: 402,
      transactionIndex: 8,
      logIndex: '9999.9',
    };
    const revoke = {
      topics: ['0xrevoke'],
      data: '0x',
      blockNumber: 402,
      transactionIndex: 8,
      logIndex: 11,
    };

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (filter.topics?.[0] === 'RoleGranted') {
          return [malformedLogIndexGrant, validGrant];
        }
        return [revoke];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: () => ({ args: { account: safeProposer } }),
        },
      } as any);

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
      },
      registry: {
        getAddresses: async () => ({}),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.GNOSIS_TX_BUILDER);
      expect(
        (
          batches[0].config.submitter as any
        ).proposerSubmitter.safeAddress.toLowerCase(),
      ).to.equal(safeProposer.toLowerCase());
      expect(provider.getLogs.callCount).to.equal(2);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
    }
  });

  it('treats non-finite logIndex as lower for timelock role logs in same transaction', async () => {
    const timelockOwner = '0x6161616161616161616161616161616161616161';
    const safeProposer = '0x7272727272727272727272727272727272727272';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      () =>
        ({
          owner: async () => timelockOwner,
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== safeProposer.toLowerCase()) {
          throw new Error('not safe');
        }
        return {
          getThreshold: async () => 1,
        } as any;
      });

    const validGrant = {
      topics: ['0xgrant-valid'],
      data: '0x',
      blockNumber: 403,
      transactionIndex: 9,
      logIndex: 12,
    };
    const malformedInfinityLogIndexGrant = {
      topics: ['0xgrant-malformed-infinity-log-index'],
      data: '0x',
      blockNumber: 403,
      transactionIndex: 9,
      logIndex: Number.POSITIVE_INFINITY,
    };
    const malformedNaNLogIndexGrant = {
      topics: ['0xgrant-malformed-nan-log-index'],
      data: '0x',
      blockNumber: 403,
      transactionIndex: 9,
      logIndex: Number.NaN,
    };
    const malformedNegativeInfinityLogIndexGrant = {
      topics: ['0xgrant-malformed-negative-infinity-log-index'],
      data: '0x',
      blockNumber: 403,
      transactionIndex: 9,
      logIndex: Number.NEGATIVE_INFINITY,
    };
    const revoke = {
      topics: ['0xrevoke'],
      data: '0x',
      blockNumber: 403,
      transactionIndex: 9,
      logIndex: 11,
    };

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (filter.topics?.[0] === 'RoleGranted') {
          return [
            malformedInfinityLogIndexGrant,
            malformedNaNLogIndexGrant,
            malformedNegativeInfinityLogIndexGrant,
            validGrant,
          ];
        }
        return [revoke];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: () => ({ args: { account: safeProposer } }),
        },
      } as any);

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
      },
      registry: {
        getAddresses: async () => ({}),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.GNOSIS_TX_BUILDER);
      expect(
        (
          batches[0].config.submitter as any
        ).proposerSubmitter.safeAddress.toLowerCase(),
      ).to.equal(safeProposer.toLowerCase());
      expect(provider.getLogs.callCount).to.equal(2);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
    }
  });

  it('treats unsafe-number logIndex as lower for timelock role logs in same transaction', async () => {
    const timelockOwner = '0x6262626262626262626262626262626262626262';
    const safeProposer = '0x7373737373737373737373737373737373737373';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      () =>
        ({
          owner: async () => timelockOwner,
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== safeProposer.toLowerCase()) {
          throw new Error('not safe');
        }
        return {
          getThreshold: async () => 1,
        } as any;
      });

    const validGrant = {
      topics: ['0xgrant-valid'],
      data: '0x',
      blockNumber: 404,
      transactionIndex: 10,
      logIndex: 12,
    };
    const malformedUnsafeLogIndexGrant = {
      topics: ['0xgrant-malformed-unsafe-log-index'],
      data: '0x',
      blockNumber: 404,
      transactionIndex: 10,
      logIndex: Number.MAX_SAFE_INTEGER + 1,
    };
    const revoke = {
      topics: ['0xrevoke'],
      data: '0x',
      blockNumber: 404,
      transactionIndex: 10,
      logIndex: 11,
    };

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (filter.topics?.[0] === 'RoleGranted') {
          return [malformedUnsafeLogIndexGrant, validGrant];
        }
        return [revoke];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: () => ({ args: { account: safeProposer } }),
        },
      } as any);

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
      },
      registry: {
        getAddresses: async () => ({}),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.GNOSIS_TX_BUILDER);
      expect(
        (
          batches[0].config.submitter as any
        ).proposerSubmitter.safeAddress.toLowerCase(),
      ).to.equal(safeProposer.toLowerCase());
      expect(provider.getLogs.callCount).to.equal(2);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
    }
  });

  it('handles bigint timelock role positional fields deterministically', async () => {
    const timelockOwner = '0x5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c';
    const safeProposer = '0x6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      () =>
        ({
          owner: async () => timelockOwner,
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== safeProposer.toLowerCase()) {
          throw new Error('not safe');
        }
        return {
          getThreshold: async () => 1,
        } as any;
      });

    const olderGrant = {
      topics: ['0xgrant-older'],
      data: '0x',
      blockNumber: 600n,
      transactionIndex: 1n,
      logIndex: 1n,
    };
    const newerGrant = {
      topics: ['0xgrant-newer'],
      data: '0x',
      blockNumber: 601n,
      transactionIndex: 0n,
      logIndex: 0n,
    };
    const revoke = {
      topics: ['0xrevoke'],
      data: '0x',
      blockNumber: 600n,
      transactionIndex: 2n,
      logIndex: 0n,
    };

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (filter.topics?.[0] === 'RoleGranted') {
          return [olderGrant, newerGrant];
        }
        return [revoke];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: () => ({ args: { account: safeProposer } }),
        },
      } as any);

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
      },
      registry: {
        getAddresses: async () => ({}),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.GNOSIS_TX_BUILDER);
      expect(
        (
          batches[0].config.submitter as any
        ).proposerSubmitter.safeAddress.toLowerCase(),
      ).to.equal(safeProposer.toLowerCase());
      expect(provider.getLogs.callCount).to.equal(2);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
    }
  });

  it('ignores negative-bigint timelock role positions during ordering', async () => {
    const timelockOwner = '0x5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d';
    const safeProposer = '0x6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      () =>
        ({
          owner: async () => timelockOwner,
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== safeProposer.toLowerCase()) {
          throw new Error('not safe');
        }
        return {
          getThreshold: async () => 1,
        } as any;
      });

    const validGrant = {
      topics: ['0xgrant-valid'],
      data: '0x',
      blockNumber: 602n,
      transactionIndex: 1n,
      logIndex: 1n,
    };
    const malformedNegativeGrant = {
      topics: ['0xgrant-malformed-negative-bigint'],
      data: '0x',
      blockNumber: -1n,
      transactionIndex: 0n,
      logIndex: 0n,
    };
    const revoke = {
      topics: ['0xrevoke'],
      data: '0x',
      blockNumber: 601n,
      transactionIndex: 0n,
      logIndex: 0n,
    };

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (filter.topics?.[0] === 'RoleGranted') {
          return [validGrant, malformedNegativeGrant];
        }
        return [revoke];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: () => ({ args: { account: safeProposer } }),
        },
      } as any);

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
      },
      registry: {
        getAddresses: async () => ({}),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.GNOSIS_TX_BUILDER);
      expect(
        (
          batches[0].config.submitter as any
        ).proposerSubmitter.safeAddress.toLowerCase(),
      ).to.equal(safeProposer.toLowerCase());
      expect(provider.getLogs.callCount).to.equal(2);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
    }
  });

  it('handles very large bigint timelock role positions without precision loss', async () => {
    const timelockOwner = '0x6262626262626262626262626262626262626262';
    const safeProposer = '0x7373737373737373737373737373737373737373';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      () =>
        ({
          owner: async () => timelockOwner,
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== safeProposer.toLowerCase()) {
          throw new Error('not safe');
        }
        return {
          getThreshold: async () => 1,
        } as any;
      });

    const newerGrant = {
      topics: ['0xgrant-newer'],
      data: '0x',
      blockNumber: 9007199254740994n,
      transactionIndex: 0n,
      logIndex: 0n,
    };
    const olderRevoke = {
      topics: ['0xrevoke-older'],
      data: '0x',
      blockNumber: 9007199254740993n,
      transactionIndex: 0n,
      logIndex: 0n,
    };

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (filter.topics?.[0] === 'RoleGranted') {
          return [newerGrant];
        }
        return [olderRevoke];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: () => ({ args: { account: safeProposer } }),
        },
      } as any);

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
      },
      registry: {
        getAddresses: async () => ({}),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.GNOSIS_TX_BUILDER);
      expect(
        (
          batches[0].config.submitter as any
        ).proposerSubmitter.safeAddress.toLowerCase(),
      ).to.equal(safeProposer.toLowerCase());
      expect(provider.getLogs.callCount).to.equal(2);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
    }
  });

  it('handles BigNumber-like timelock role positional fields deterministically', async () => {
    const timelockOwner = '0x5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d';
    const safeProposer = '0x6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e';
    const asBigNumberLike = (value: string) =>
      ({
        toString: () => value,
      }) as any;

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      () =>
        ({
          owner: async () => timelockOwner,
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== safeProposer.toLowerCase()) {
          throw new Error('not safe');
        }
        return {
          getThreshold: async () => 1,
        } as any;
      });

    const olderGrant = {
      topics: ['0xgrant-older'],
      data: '0x',
      blockNumber: asBigNumberLike('800'),
      transactionIndex: asBigNumberLike('1'),
      logIndex: asBigNumberLike('1'),
    };
    const newerGrant = {
      topics: ['0xgrant-newer'],
      data: '0x',
      blockNumber: asBigNumberLike('801'),
      transactionIndex: asBigNumberLike('0'),
      logIndex: asBigNumberLike('0'),
    };
    const revoke = {
      topics: ['0xrevoke'],
      data: '0x',
      blockNumber: asBigNumberLike('800'),
      transactionIndex: asBigNumberLike('2'),
      logIndex: asBigNumberLike('0'),
    };

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (filter.topics?.[0] === 'RoleGranted') {
          return [olderGrant, newerGrant];
        }
        return [revoke];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: () => ({ args: { account: safeProposer } }),
        },
      } as any);

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
      },
      registry: {
        getAddresses: async () => ({}),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.GNOSIS_TX_BUILDER);
      expect(
        (
          batches[0].config.submitter as any
        ).proposerSubmitter.safeAddress.toLowerCase(),
      ).to.equal(safeProposer.toLowerCase());
      expect(provider.getLogs.callCount).to.equal(2);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
    }
  });

  it('handles string-encoded timelock role positional fields deterministically', async () => {
    const timelockOwner = '0x5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e';
    const safeProposer = '0x6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      () =>
        ({
          owner: async () => timelockOwner,
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== safeProposer.toLowerCase()) {
          throw new Error('not safe');
        }
        return {
          getThreshold: async () => 1,
        } as any;
      });

    const olderGrant = {
      topics: ['0xgrant-older'],
      data: '0x',
      blockNumber: '1000',
      transactionIndex: '1',
      logIndex: '1',
    };
    const newerGrant = {
      topics: ['0xgrant-newer'],
      data: '0x',
      blockNumber: ' 1001 ',
      transactionIndex: '0',
      logIndex: '0',
    };
    const revoke = {
      topics: ['0xrevoke'],
      data: '0x',
      blockNumber: '1000',
      transactionIndex: '2',
      logIndex: '0',
    };

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (filter.topics?.[0] === 'RoleGranted') {
          return [olderGrant, newerGrant];
        }
        return [revoke];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: () => ({ args: { account: safeProposer } }),
        },
      } as any);

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
      },
      registry: {
        getAddresses: async () => ({}),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.GNOSIS_TX_BUILDER);
      expect(
        (
          batches[0].config.submitter as any
        ).proposerSubmitter.safeAddress.toLowerCase(),
      ).to.equal(safeProposer.toLowerCase());
      expect(provider.getLogs.callCount).to.equal(2);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
    }
  });

  it('handles hex-string timelock role positional fields deterministically', async () => {
    const timelockOwner = '0x5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f';
    const safeProposer = '0x7070707070707070707070707070707070707070';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      () =>
        ({
          owner: async () => timelockOwner,
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== safeProposer.toLowerCase()) {
          throw new Error('not safe');
        }
        return {
          getThreshold: async () => 1,
        } as any;
      });

    const olderGrant = {
      topics: ['0xgrant-older'],
      data: '0x',
      blockNumber: '0x500',
      transactionIndex: '0x1',
      logIndex: '0x1',
    };
    const newerGrant = {
      topics: ['0xgrant-newer'],
      data: '0x',
      blockNumber: '0x501',
      transactionIndex: '0x0',
      logIndex: '0x0',
    };
    const revoke = {
      topics: ['0xrevoke'],
      data: '0x',
      blockNumber: '0x500',
      transactionIndex: '0x2',
      logIndex: '0x0',
    };

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (filter.topics?.[0] === 'RoleGranted') {
          return [olderGrant, newerGrant];
        }
        return [revoke];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: () => ({ args: { account: safeProposer } }),
        },
      } as any);

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
      },
      registry: {
        getAddresses: async () => ({}),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.GNOSIS_TX_BUILDER);
      expect(
        (
          batches[0].config.submitter as any
        ).proposerSubmitter.safeAddress.toLowerCase(),
      ).to.equal(safeProposer.toLowerCase());
      expect(provider.getLogs.callCount).to.equal(2);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
    }
  });

  it('handles uppercase hex-string timelock role positional fields deterministically', async () => {
    const timelockOwner = '0x6464646464646464646464646464646464646464';
    const safeProposer = '0x7575757575757575757575757575757575757575';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      () =>
        ({
          owner: async () => timelockOwner,
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== safeProposer.toLowerCase()) {
          throw new Error('not safe');
        }
        return {
          getThreshold: async () => 1,
        } as any;
      });

    const olderGrant = {
      topics: ['0xgrant-older'],
      data: '0x',
      blockNumber: '0X600',
      transactionIndex: '0X1',
      logIndex: '0X1',
    };
    const newerGrant = {
      topics: ['0xgrant-newer'],
      data: '0x',
      blockNumber: '0X601',
      transactionIndex: '0X0',
      logIndex: '0X0',
    };
    const revoke = {
      topics: ['0xrevoke'],
      data: '0x',
      blockNumber: '0X600',
      transactionIndex: '0X2',
      logIndex: '0X0',
    };

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (filter.topics?.[0] === 'RoleGranted') {
          return [olderGrant, newerGrant];
        }
        return [revoke];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: () => ({ args: { account: safeProposer } }),
        },
      } as any);

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
      },
      registry: {
        getAddresses: async () => ({}),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.GNOSIS_TX_BUILDER);
      expect(
        (
          batches[0].config.submitter as any
        ).proposerSubmitter.safeAddress.toLowerCase(),
      ).to.equal(safeProposer.toLowerCase());
      expect(provider.getLogs.callCount).to.equal(2);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
    }
  });

  it('handles whitespace-padded hex timelock role positional fields deterministically', async () => {
    const timelockOwner = '0x6565656565656565656565656565656565656565';
    const safeProposer = '0x7676767676767676767676767676767676767676';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      () =>
        ({
          owner: async () => timelockOwner,
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== safeProposer.toLowerCase()) {
          throw new Error('not safe');
        }
        return {
          getThreshold: async () => 1,
        } as any;
      });

    const olderGrant = {
      topics: ['0xgrant-older'],
      data: '0x',
      blockNumber: ' 0x800 ',
      transactionIndex: ' 0x1 ',
      logIndex: ' 0x1 ',
    };
    const newerGrant = {
      topics: ['0xgrant-newer'],
      data: '0x',
      blockNumber: ' 0X801 ',
      transactionIndex: ' 0X0 ',
      logIndex: ' 0X0 ',
    };
    const revoke = {
      topics: ['0xrevoke'],
      data: '0x',
      blockNumber: ' 0x800 ',
      transactionIndex: ' 0x2 ',
      logIndex: ' 0x0 ',
    };

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (filter.topics?.[0] === 'RoleGranted') {
          return [olderGrant, newerGrant];
        }
        return [revoke];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: () => ({ args: { account: safeProposer } }),
        },
      } as any);

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
      },
      registry: {
        getAddresses: async () => ({}),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.GNOSIS_TX_BUILDER);
      expect(
        (
          batches[0].config.submitter as any
        ).proposerSubmitter.safeAddress.toLowerCase(),
      ).to.equal(safeProposer.toLowerCase());
      expect(provider.getLogs.callCount).to.equal(2);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
    }
  });

  it('handles very large decimal-string timelock role positions without precision loss', async () => {
    const timelockOwner = '0x6969696969696969696969696969696969696969';
    const safeProposer = '0x7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      () =>
        ({
          owner: async () => timelockOwner,
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== safeProposer.toLowerCase()) {
          throw new Error('not safe');
        }
        return {
          getThreshold: async () => 1,
        } as any;
      });

    const newerGrant = {
      topics: ['0xgrant-newer'],
      data: '0x',
      blockNumber: '900719925474099312345679',
      transactionIndex: '0',
      logIndex: '0',
    };
    const olderRevoke = {
      topics: ['0xrevoke-older'],
      data: '0x',
      blockNumber: '900719925474099312345678',
      transactionIndex: '1',
      logIndex: '0',
    };

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (filter.topics?.[0] === 'RoleGranted') {
          return [newerGrant];
        }
        return [olderRevoke];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: () => ({ args: { account: safeProposer } }),
        },
      } as any);

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
      },
      registry: {
        getAddresses: async () => ({}),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.GNOSIS_TX_BUILDER);
      expect(
        (
          batches[0].config.submitter as any
        ).proposerSubmitter.safeAddress.toLowerCase(),
      ).to.equal(safeProposer.toLowerCase());
      expect(provider.getLogs.callCount).to.equal(2);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
    }
  });

  it('ignores malformed hex-string timelock role positions during ordering', async () => {
    const timelockOwner = '0x6a6a6a6a6a6a6a6a6a6a6a6a6a6a6a6a6a6a6a6a';
    const safeProposer = '0x7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      () =>
        ({
          owner: async () => timelockOwner,
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== safeProposer.toLowerCase()) {
          throw new Error('not safe');
        }
        return {
          getThreshold: async () => 1,
        } as any;
      });

    const validGrant = {
      topics: ['0xgrant-valid'],
      data: '0x',
      blockNumber: '1000',
      transactionIndex: '1',
      logIndex: '1',
    };
    const malformedHigherGrant = {
      topics: ['0xgrant-malformed-high'],
      data: '0x',
      blockNumber: '0xABCX',
      transactionIndex: '0',
      logIndex: '0',
    };
    const revoke = {
      topics: ['0xrevoke'],
      data: '0x',
      blockNumber: '999',
      transactionIndex: '0',
      logIndex: '0',
    };

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (filter.topics?.[0] === 'RoleGranted') {
          // malformed hex grant should not outrank valid grant
          return [validGrant, malformedHigherGrant];
        }
        return [revoke];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: () => ({ args: { account: safeProposer } }),
        },
      } as any);

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
      },
      registry: {
        getAddresses: async () => ({}),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.GNOSIS_TX_BUILDER);
      expect(
        (
          batches[0].config.submitter as any
        ).proposerSubmitter.safeAddress.toLowerCase(),
      ).to.equal(safeProposer.toLowerCase());
      expect(provider.getLogs.callCount).to.equal(2);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
    }
  });

  it('ignores empty-hex-prefix timelock role positions during ordering', async () => {
    const timelockOwner = '0x6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b';
    const safeProposer = '0x7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      () =>
        ({
          owner: async () => timelockOwner,
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== safeProposer.toLowerCase()) {
          throw new Error('not safe');
        }
        return {
          getThreshold: async () => 1,
        } as any;
      });

    const validGrant = {
      topics: ['0xgrant-valid'],
      data: '0x',
      blockNumber: '1001',
      transactionIndex: '1',
      logIndex: '1',
    };
    const malformedHexPrefixGrant = {
      topics: ['0xgrant-malformed-prefix'],
      data: '0x',
      blockNumber: '0x',
      transactionIndex: '0',
      logIndex: '0',
    };
    const revoke = {
      topics: ['0xrevoke'],
      data: '0x',
      blockNumber: '1000',
      transactionIndex: '0',
      logIndex: '0',
    };

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (filter.topics?.[0] === 'RoleGranted') {
          // empty hex prefix must not outrank valid proposer role event
          return [validGrant, malformedHexPrefixGrant];
        }
        return [revoke];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: () => ({ args: { account: safeProposer } }),
        },
      } as any);

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
      },
      registry: {
        getAddresses: async () => ({}),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.GNOSIS_TX_BUILDER);
      expect(
        (
          batches[0].config.submitter as any
        ).proposerSubmitter.safeAddress.toLowerCase(),
      ).to.equal(safeProposer.toLowerCase());
      expect(provider.getLogs.callCount).to.equal(2);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
    }
  });

  it('ignores non-integer string timelock role positions during ordering', async () => {
    const timelockOwner = '0x6060606060606060606060606060606060606060';
    const safeProposer = '0x7171717171717171717171717171717171717171';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      () =>
        ({
          owner: async () => timelockOwner,
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== safeProposer.toLowerCase()) {
          throw new Error('not safe');
        }
        return {
          getThreshold: async () => 1,
        } as any;
      });

    const validGrant = {
      topics: ['0xgrant-valid'],
      data: '0x',
      blockNumber: '1000',
      transactionIndex: '1',
      logIndex: '1',
    };
    const malformedHigherGrant = {
      topics: ['0xgrant-malformed-high'],
      data: '0x',
      blockNumber: '9999.9',
      transactionIndex: '0',
      logIndex: '0',
    };
    const revoke = {
      topics: ['0xrevoke'],
      data: '0x',
      blockNumber: '999',
      transactionIndex: '0',
      logIndex: '0',
    };

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (filter.topics?.[0] === 'RoleGranted') {
          // malformed grant appears later in array but should not outrank valid grant
          return [validGrant, malformedHigherGrant];
        }
        return [revoke];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: () => ({ args: { account: safeProposer } }),
        },
      } as any);

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
      },
      registry: {
        getAddresses: async () => ({}),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.GNOSIS_TX_BUILDER);
      expect(
        (
          batches[0].config.submitter as any
        ).proposerSubmitter.safeAddress.toLowerCase(),
      ).to.equal(safeProposer.toLowerCase());
      expect(provider.getLogs.callCount).to.equal(2);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
    }
  });

  it('ignores object-default-string timelock role positions during ordering', async () => {
    const timelockOwner = '0xe1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1';
    const safeProposer = '0xe2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      () =>
        ({
          owner: async () => timelockOwner,
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== safeProposer.toLowerCase()) {
          throw new Error('not safe');
        }
        return {
          getThreshold: async () => 1,
        } as any;
      });

    const validGrant = {
      topics: ['0xgrant-valid'],
      data: '0x',
      blockNumber: '1033',
      transactionIndex: '1',
      logIndex: '1',
    };
    const malformedObjectDefaultStringGrant = {
      topics: ['0xgrant-malformed-object-default-string'],
      data: '0x',
      blockNumber: '[object Object]',
      transactionIndex: '0',
      logIndex: '0',
    };
    const revoke = {
      topics: ['0xrevoke'],
      data: '0x',
      blockNumber: '1032',
      transactionIndex: '0',
      logIndex: '0',
    };

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (filter.topics?.[0] === 'RoleGranted') {
          return [validGrant, malformedObjectDefaultStringGrant];
        }
        return [revoke];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: () => ({ args: { account: safeProposer } }),
        },
      } as any);

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
      },
      registry: {
        getAddresses: async () => ({}),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.GNOSIS_TX_BUILDER);
      expect(
        (
          batches[0].config.submitter as any
        ).proposerSubmitter.safeAddress.toLowerCase(),
      ).to.equal(safeProposer.toLowerCase());
      expect(provider.getLogs.callCount).to.equal(2);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
    }
  });

  it('ignores whitespace-padded object-default-string timelock role positions during ordering', async () => {
    const timelockOwner = '0xe6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6';
    const safeProposer = '0xe7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      () =>
        ({
          owner: async () => timelockOwner,
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== safeProposer.toLowerCase()) {
          throw new Error('not safe');
        }
        return {
          getThreshold: async () => 1,
        } as any;
      });

    const validGrant = {
      topics: ['0xgrant-valid'],
      data: '0x',
      blockNumber: '1035',
      transactionIndex: '1',
      logIndex: '1',
    };
    const malformedWhitespacePaddedObjectDefaultStringGrant = {
      topics: ['0xgrant-malformed-whitespace-padded-object-default-string'],
      data: '0x',
      blockNumber: '   [object Object]   ',
      transactionIndex: '0',
      logIndex: '0',
    };
    const revoke = {
      topics: ['0xrevoke'],
      data: '0x',
      blockNumber: '1034',
      transactionIndex: '0',
      logIndex: '0',
    };

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (filter.topics?.[0] === 'RoleGranted') {
          return [
            validGrant,
            malformedWhitespacePaddedObjectDefaultStringGrant,
          ];
        }
        return [revoke];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: () => ({ args: { account: safeProposer } }),
        },
      } as any);

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
      },
      registry: {
        getAddresses: async () => ({}),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.GNOSIS_TX_BUILDER);
      expect(
        (
          batches[0].config.submitter as any
        ).proposerSubmitter.safeAddress.toLowerCase(),
      ).to.equal(safeProposer.toLowerCase());
      expect(provider.getLogs.callCount).to.equal(2);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
    }
  });

  it('ignores plus-prefixed decimal-string timelock role positions during ordering', async () => {
    const timelockOwner = '0x6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c';
    const safeProposer = '0x7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      () =>
        ({
          owner: async () => timelockOwner,
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== safeProposer.toLowerCase()) {
          throw new Error('not safe');
        }
        return {
          getThreshold: async () => 1,
        } as any;
      });

    const validGrant = {
      topics: ['0xgrant-valid'],
      data: '0x',
      blockNumber: '1002',
      transactionIndex: '1',
      logIndex: '1',
    };
    const malformedPlusGrant = {
      topics: ['0xgrant-malformed-plus'],
      data: '0x',
      blockNumber: '+9999',
      transactionIndex: '0',
      logIndex: '0',
    };
    const revoke = {
      topics: ['0xrevoke'],
      data: '0x',
      blockNumber: '1001',
      transactionIndex: '0',
      logIndex: '0',
    };

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (filter.topics?.[0] === 'RoleGranted') {
          return [validGrant, malformedPlusGrant];
        }
        return [revoke];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: () => ({ args: { account: safeProposer } }),
        },
      } as any);

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
      },
      registry: {
        getAddresses: async () => ({}),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.GNOSIS_TX_BUILDER);
      expect(
        (
          batches[0].config.submitter as any
        ).proposerSubmitter.safeAddress.toLowerCase(),
      ).to.equal(safeProposer.toLowerCase());
      expect(provider.getLogs.callCount).to.equal(2);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
    }
  });

  it('ignores plus-prefixed hex-string timelock role positions during ordering', async () => {
    const timelockOwner = '0xcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcb';
    const safeProposer = '0xcccccccccccccccccccccccccccccccccccccccc';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      () =>
        ({
          owner: async () => timelockOwner,
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== safeProposer.toLowerCase()) {
          throw new Error('not safe');
        }
        return {
          getThreshold: async () => 1,
        } as any;
      });

    const validGrant = {
      topics: ['0xgrant-valid'],
      data: '0x',
      blockNumber: '1026',
      transactionIndex: '1',
      logIndex: '1',
    };
    const malformedPlusHexGrant = {
      topics: ['0xgrant-malformed-plus-hex'],
      data: '0x',
      blockNumber: '+0x270f',
      transactionIndex: '0',
      logIndex: '0',
    };
    const malformedUppercasePlusHexGrant = {
      topics: ['0xgrant-malformed-uppercase-plus-hex'],
      data: '0x',
      blockNumber: '+0X270f',
      transactionIndex: '0',
      logIndex: '0',
    };
    const malformedRawBoundaryPlusHexGrant = {
      topics: ['0xgrant-malformed-raw-boundary-plus-hex'],
      data: '0x',
      blockNumber: `+0x${'0'.repeat(4093)}`,
      transactionIndex: '0',
      logIndex: '0',
    };
    const malformedRawPlusOnePlusHexGrant = {
      topics: ['0xgrant-malformed-raw-plus-one-plus-hex'],
      data: '0x',
      blockNumber: `+0x${'0'.repeat(4094)}`,
      transactionIndex: '0',
      logIndex: '0',
    };
    const revoke = {
      topics: ['0xrevoke'],
      data: '0x',
      blockNumber: '1025',
      transactionIndex: '0',
      logIndex: '0',
    };

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (filter.topics?.[0] === 'RoleGranted') {
          return [
            validGrant,
            malformedPlusHexGrant,
            malformedUppercasePlusHexGrant,
            malformedRawBoundaryPlusHexGrant,
            malformedRawPlusOnePlusHexGrant,
          ];
        }
        return [revoke];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: () => ({ args: { account: safeProposer } }),
        },
      } as any);

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
      },
      registry: {
        getAddresses: async () => ({}),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.GNOSIS_TX_BUILDER);
      expect(
        (
          batches[0].config.submitter as any
        ).proposerSubmitter.safeAddress.toLowerCase(),
      ).to.equal(safeProposer.toLowerCase());
      expect(provider.getLogs.callCount).to.equal(2);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
    }
  });

  it('ignores minus-prefixed hex-string timelock role positions during ordering', async () => {
    const timelockOwner = '0xcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcd';
    const safeProposer = '0xcececececececececececececececececececece';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      () =>
        ({
          owner: async () => timelockOwner,
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== safeProposer.toLowerCase()) {
          throw new Error('not safe');
        }
        return {
          getThreshold: async () => 1,
        } as any;
      });

    const validGrant = {
      topics: ['0xgrant-valid'],
      data: '0x',
      blockNumber: '1027',
      transactionIndex: '1',
      logIndex: '1',
    };
    const malformedMinusHexGrant = {
      topics: ['0xgrant-malformed-minus-hex'],
      data: '0x',
      blockNumber: '-0x270f',
      transactionIndex: '0',
      logIndex: '0',
    };
    const malformedUppercaseMinusHexGrant = {
      topics: ['0xgrant-malformed-uppercase-minus-hex'],
      data: '0x',
      blockNumber: '-0X270f',
      transactionIndex: '0',
      logIndex: '0',
    };
    const malformedRawBoundaryMinusHexGrant = {
      topics: ['0xgrant-malformed-raw-boundary-minus-hex'],
      data: '0x',
      blockNumber: `-0x${'0'.repeat(4093)}`,
      transactionIndex: '0',
      logIndex: '0',
    };
    const malformedRawPlusOneMinusHexGrant = {
      topics: ['0xgrant-malformed-raw-plus-one-minus-hex'],
      data: '0x',
      blockNumber: `-0x${'0'.repeat(4094)}`,
      transactionIndex: '0',
      logIndex: '0',
    };
    const revoke = {
      topics: ['0xrevoke'],
      data: '0x',
      blockNumber: '1026',
      transactionIndex: '0',
      logIndex: '0',
    };

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (filter.topics?.[0] === 'RoleGranted') {
          return [
            validGrant,
            malformedMinusHexGrant,
            malformedUppercaseMinusHexGrant,
            malformedRawBoundaryMinusHexGrant,
            malformedRawPlusOneMinusHexGrant,
          ];
        }
        return [revoke];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: () => ({ args: { account: safeProposer } }),
        },
      } as any);

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
      },
      registry: {
        getAddresses: async () => ({}),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.GNOSIS_TX_BUILDER);
      expect(
        (
          batches[0].config.submitter as any
        ).proposerSubmitter.safeAddress.toLowerCase(),
      ).to.equal(safeProposer.toLowerCase());
      expect(provider.getLogs.callCount).to.equal(2);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
    }
  });

  it('ignores signed empty-hex-prefix timelock role positions during ordering', async () => {
    const timelockOwner = '0xd2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2';
    const safeProposer = '0xd3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      () =>
        ({
          owner: async () => timelockOwner,
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== safeProposer.toLowerCase()) {
          throw new Error('not safe');
        }
        return {
          getThreshold: async () => 1,
        } as any;
      });

    const validGrant = {
      topics: ['0xgrant-valid'],
      data: '0x',
      blockNumber: '1029',
      transactionIndex: '1',
      logIndex: '1',
    };
    const malformedPlusEmptyHexGrant = {
      topics: ['0xgrant-malformed-plus-empty-hex'],
      data: '0x',
      blockNumber: '+0x',
      transactionIndex: '0',
      logIndex: '0',
    };
    const malformedMinusEmptyHexGrant = {
      topics: ['0xgrant-malformed-minus-empty-hex'],
      data: '0x',
      blockNumber: '-0x',
      transactionIndex: '0',
      logIndex: '0',
    };
    const malformedUppercasePlusEmptyHexGrant = {
      topics: ['0xgrant-malformed-uppercase-plus-empty-hex'],
      data: '0x',
      blockNumber: '+0X',
      transactionIndex: '0',
      logIndex: '0',
    };
    const malformedUppercaseMinusEmptyHexGrant = {
      topics: ['0xgrant-malformed-uppercase-minus-empty-hex'],
      data: '0x',
      blockNumber: '-0X',
      transactionIndex: '0',
      logIndex: '0',
    };
    const revoke = {
      topics: ['0xrevoke'],
      data: '0x',
      blockNumber: '1028',
      transactionIndex: '0',
      logIndex: '0',
    };

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (filter.topics?.[0] === 'RoleGranted') {
          return [
            validGrant,
            malformedPlusEmptyHexGrant,
            malformedMinusEmptyHexGrant,
            malformedUppercasePlusEmptyHexGrant,
            malformedUppercaseMinusEmptyHexGrant,
          ];
        }
        return [revoke];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: () => ({ args: { account: safeProposer } }),
        },
      } as any);

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
      },
      registry: {
        getAddresses: async () => ({}),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.GNOSIS_TX_BUILDER);
      expect(
        (
          batches[0].config.submitter as any
        ).proposerSubmitter.safeAddress.toLowerCase(),
      ).to.equal(safeProposer.toLowerCase());
      expect(provider.getLogs.callCount).to.equal(2);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
    }
  });

  it('ignores raw-length-boundary plus-prefixed timelock role positions during ordering', async () => {
    const timelockOwner = '0xb7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7';
    const safeProposer = '0xb8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      () =>
        ({
          owner: async () => timelockOwner,
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== safeProposer.toLowerCase()) {
          throw new Error('not safe');
        }
        return {
          getThreshold: async () => 1,
        } as any;
      });

    const validGrant = {
      topics: ['0xgrant-valid'],
      data: '0x',
      blockNumber: '1018',
      transactionIndex: '1',
      logIndex: '1',
    };
    const malformedRawBoundaryGrant = {
      topics: ['0xgrant-malformed-raw-boundary-plus'],
      data: '0x',
      blockNumber: `+${'0'.repeat(4095)}`,
      transactionIndex: '0',
      logIndex: '0',
    };
    const revoke = {
      topics: ['0xrevoke'],
      data: '0x',
      blockNumber: '1017',
      transactionIndex: '0',
      logIndex: '0',
    };

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (filter.topics?.[0] === 'RoleGranted') {
          return [validGrant, malformedRawBoundaryGrant];
        }
        return [revoke];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: () => ({ args: { account: safeProposer } }),
        },
      } as any);

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
      },
      registry: {
        getAddresses: async () => ({}),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.GNOSIS_TX_BUILDER);
      expect(
        (
          batches[0].config.submitter as any
        ).proposerSubmitter.safeAddress.toLowerCase(),
      ).to.equal(safeProposer.toLowerCase());
      expect(provider.getLogs.callCount).to.equal(2);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
    }
  });

  it('ignores raw-length-plus-one plus-prefixed timelock role positions during ordering', async () => {
    const timelockOwner = '0xb9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9';
    const safeProposer = '0xbabababababababababababababababababababa';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      () =>
        ({
          owner: async () => timelockOwner,
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== safeProposer.toLowerCase()) {
          throw new Error('not safe');
        }
        return {
          getThreshold: async () => 1,
        } as any;
      });

    const validGrant = {
      topics: ['0xgrant-valid'],
      data: '0x',
      blockNumber: '1019',
      transactionIndex: '1',
      logIndex: '1',
    };
    const malformedRawPlusOneGrant = {
      topics: ['0xgrant-malformed-raw-plus-one-plus'],
      data: '0x',
      blockNumber: `+${'0'.repeat(4096)}`,
      transactionIndex: '0',
      logIndex: '0',
    };
    const revoke = {
      topics: ['0xrevoke'],
      data: '0x',
      blockNumber: '1018',
      transactionIndex: '0',
      logIndex: '0',
    };

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (filter.topics?.[0] === 'RoleGranted') {
          return [validGrant, malformedRawPlusOneGrant];
        }
        return [revoke];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: () => ({ args: { account: safeProposer } }),
        },
      } as any);

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
      },
      registry: {
        getAddresses: async () => ({}),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.GNOSIS_TX_BUILDER);
      expect(
        (
          batches[0].config.submitter as any
        ).proposerSubmitter.safeAddress.toLowerCase(),
      ).to.equal(safeProposer.toLowerCase());
      expect(provider.getLogs.callCount).to.equal(2);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
    }
  });

  it('ignores raw-length-boundary minus-prefixed timelock role positions during ordering', async () => {
    const timelockOwner = '0xc1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1';
    const safeProposer = '0xc2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      () =>
        ({
          owner: async () => timelockOwner,
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== safeProposer.toLowerCase()) {
          throw new Error('not safe');
        }
        return {
          getThreshold: async () => 1,
        } as any;
      });

    const validGrant = {
      topics: ['0xgrant-valid'],
      data: '0x',
      blockNumber: '1022',
      transactionIndex: '1',
      logIndex: '1',
    };
    const malformedRawBoundaryGrant = {
      topics: ['0xgrant-malformed-raw-boundary-minus'],
      data: '0x',
      blockNumber: `-${'0'.repeat(4095)}`,
      transactionIndex: '0',
      logIndex: '0',
    };
    const revoke = {
      topics: ['0xrevoke'],
      data: '0x',
      blockNumber: '1021',
      transactionIndex: '0',
      logIndex: '0',
    };

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (filter.topics?.[0] === 'RoleGranted') {
          return [validGrant, malformedRawBoundaryGrant];
        }
        return [revoke];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: () => ({ args: { account: safeProposer } }),
        },
      } as any);

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
      },
      registry: {
        getAddresses: async () => ({}),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.GNOSIS_TX_BUILDER);
      expect(
        (
          batches[0].config.submitter as any
        ).proposerSubmitter.safeAddress.toLowerCase(),
      ).to.equal(safeProposer.toLowerCase());
      expect(provider.getLogs.callCount).to.equal(2);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
    }
  });

  it('ignores raw-length-plus-one minus-prefixed timelock role positions during ordering', async () => {
    const timelockOwner = '0xc3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3';
    const safeProposer = '0xc4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      () =>
        ({
          owner: async () => timelockOwner,
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== safeProposer.toLowerCase()) {
          throw new Error('not safe');
        }
        return {
          getThreshold: async () => 1,
        } as any;
      });

    const validGrant = {
      topics: ['0xgrant-valid'],
      data: '0x',
      blockNumber: '1023',
      transactionIndex: '1',
      logIndex: '1',
    };
    const malformedRawPlusOneGrant = {
      topics: ['0xgrant-malformed-raw-plus-one-minus'],
      data: '0x',
      blockNumber: `-${'0'.repeat(4096)}`,
      transactionIndex: '0',
      logIndex: '0',
    };
    const revoke = {
      topics: ['0xrevoke'],
      data: '0x',
      blockNumber: '1022',
      transactionIndex: '0',
      logIndex: '0',
    };

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (filter.topics?.[0] === 'RoleGranted') {
          return [validGrant, malformedRawPlusOneGrant];
        }
        return [revoke];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: () => ({ args: { account: safeProposer } }),
        },
      } as any);

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
      },
      registry: {
        getAddresses: async () => ({}),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.GNOSIS_TX_BUILDER);
      expect(
        (
          batches[0].config.submitter as any
        ).proposerSubmitter.safeAddress.toLowerCase(),
      ).to.equal(safeProposer.toLowerCase());
      expect(provider.getLogs.callCount).to.equal(2);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
    }
  });

  it('ignores overlong hex-string timelock role positions during ordering', async () => {
    const timelockOwner = '0x6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d';
    const safeProposer = '0x7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      () =>
        ({
          owner: async () => timelockOwner,
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== safeProposer.toLowerCase()) {
          throw new Error('not safe');
        }
        return {
          getThreshold: async () => 1,
        } as any;
      });

    const validGrant = {
      topics: ['0xgrant-valid'],
      data: '0x',
      blockNumber: '1003',
      transactionIndex: '1',
      logIndex: '1',
    };
    const malformedOverlongGrant = {
      topics: ['0xgrant-malformed-overlong'],
      data: '0x',
      blockNumber: `0x${'f'.repeat(300)}`,
      transactionIndex: '0',
      logIndex: '0',
    };
    const revoke = {
      topics: ['0xrevoke'],
      data: '0x',
      blockNumber: '1002',
      transactionIndex: '0',
      logIndex: '0',
    };

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (filter.topics?.[0] === 'RoleGranted') {
          return [validGrant, malformedOverlongGrant];
        }
        return [revoke];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: () => ({ args: { account: safeProposer } }),
        },
      } as any);

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
      },
      registry: {
        getAddresses: async () => ({}),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.GNOSIS_TX_BUILDER);
      expect(
        (
          batches[0].config.submitter as any
        ).proposerSubmitter.safeAddress.toLowerCase(),
      ).to.equal(safeProposer.toLowerCase());
      expect(provider.getLogs.callCount).to.equal(2);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
    }
  });

  it('accepts max-length hex-string timelock role positions deterministically', async () => {
    const timelockOwner = '0x8282828282828282828282828282828282828282';
    const safeProposer = '0x8383838383838383838383838383838383838383';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      () =>
        ({
          owner: async () => timelockOwner,
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== safeProposer.toLowerCase()) {
          throw new Error('not safe');
        }
        return {
          getThreshold: async () => 1,
        } as any;
      });

    const higherGrant = {
      topics: ['0xgrant-higher'],
      data: '0x',
      blockNumber: `0x${'f'.repeat(254)}`,
      transactionIndex: '0',
      logIndex: '0',
    };
    const lowerRevoke = {
      topics: ['0xrevoke-lower'],
      data: '0x',
      blockNumber: `0x${'f'.repeat(253)}`,
      transactionIndex: '0',
      logIndex: '0',
    };

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (filter.topics?.[0] === 'RoleGranted') {
          return [higherGrant];
        }
        return [lowerRevoke];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: () => ({ args: { account: safeProposer } }),
        },
      } as any);

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
      },
      registry: {
        getAddresses: async () => ({}),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.GNOSIS_TX_BUILDER);
      expect(
        (
          batches[0].config.submitter as any
        ).proposerSubmitter.safeAddress.toLowerCase(),
      ).to.equal(safeProposer.toLowerCase());
      expect(provider.getLogs.callCount).to.equal(2);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
    }
  });

  it('accepts overlong zero-padded hex timelock role positions deterministically', async () => {
    const timelockOwner = '0x8888888888888888888888888888888888888888';
    const safeProposer = '0x8989898989898989898989898989898989898989';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      () =>
        ({
          owner: async () => timelockOwner,
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== safeProposer.toLowerCase()) {
          throw new Error('not safe');
        }
        return {
          getThreshold: async () => 1,
        } as any;
      });

    const higherGrant = {
      topics: ['0xgrant-higher'],
      data: '0x',
      blockNumber: `0x${'0'.repeat(300)}2`,
      transactionIndex: '0',
      logIndex: '0',
    };
    const lowerRevoke = {
      topics: ['0xrevoke-lower'],
      data: '0x',
      blockNumber: `0x${'0'.repeat(300)}1`,
      transactionIndex: '0',
      logIndex: '0',
    };

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (filter.topics?.[0] === 'RoleGranted') {
          return [higherGrant];
        }
        return [lowerRevoke];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: () => ({ args: { account: safeProposer } }),
        },
      } as any);

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
      },
      registry: {
        getAddresses: async () => ({}),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.GNOSIS_TX_BUILDER);
      expect(
        (
          batches[0].config.submitter as any
        ).proposerSubmitter.safeAddress.toLowerCase(),
      ).to.equal(safeProposer.toLowerCase());
      expect(provider.getLogs.callCount).to.equal(2);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
    }
  });

  it('accepts overlong uppercase-zero-padded hex timelock role positions deterministically', async () => {
    const timelockOwner = '0x9595959595959595959595959595959595959595';
    const safeProposer = '0x9696969696969696969696969696969696969696';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      () =>
        ({
          owner: async () => timelockOwner,
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== safeProposer.toLowerCase()) {
          throw new Error('not safe');
        }
        return {
          getThreshold: async () => 1,
        } as any;
      });

    const higherGrant = {
      topics: ['0xgrant-higher'],
      data: '0x',
      blockNumber: `0X${'0'.repeat(300)}A`,
      transactionIndex: '0',
      logIndex: '0',
    };
    const lowerRevoke = {
      topics: ['0xrevoke-lower'],
      data: '0x',
      blockNumber: `0X${'0'.repeat(300)}9`,
      transactionIndex: '0',
      logIndex: '0',
    };

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (filter.topics?.[0] === 'RoleGranted') {
          return [higherGrant];
        }
        return [lowerRevoke];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: () => ({ args: { account: safeProposer } }),
        },
      } as any);

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
      },
      registry: {
        getAddresses: async () => ({}),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.GNOSIS_TX_BUILDER);
      expect(
        (
          batches[0].config.submitter as any
        ).proposerSubmitter.safeAddress.toLowerCase(),
      ).to.equal(safeProposer.toLowerCase());
      expect(provider.getLogs.callCount).to.equal(2);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
    }
  });

  it('accepts raw-length-boundary zero-padded hex timelock role positions deterministically', async () => {
    const timelockOwner = '0x9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f';
    const safeProposer = '0xa0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      () =>
        ({
          owner: async () => timelockOwner,
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== safeProposer.toLowerCase()) {
          throw new Error('not safe');
        }
        return {
          getThreshold: async () => 1,
        } as any;
      });

    const higherGrant = {
      topics: ['0xgrant-higher'],
      data: '0x',
      blockNumber: `0x${'0'.repeat(4093)}2`,
      transactionIndex: '0',
      logIndex: '0',
    };
    const lowerRevoke = {
      topics: ['0xrevoke-lower'],
      data: '0x',
      blockNumber: `0x${'0'.repeat(4093)}1`,
      transactionIndex: '0',
      logIndex: '0',
    };

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (filter.topics?.[0] === 'RoleGranted') {
          return [higherGrant];
        }
        return [lowerRevoke];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: () => ({ args: { account: safeProposer } }),
        },
      } as any);

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
      },
      registry: {
        getAddresses: async () => ({}),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.GNOSIS_TX_BUILDER);
      expect(
        (
          batches[0].config.submitter as any
        ).proposerSubmitter.safeAddress.toLowerCase(),
      ).to.equal(safeProposer.toLowerCase());
      expect(provider.getLogs.callCount).to.equal(2);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
    }
  });

  it('accepts raw-length-boundary uppercase-zero-padded hex timelock role positions deterministically', async () => {
    const timelockOwner = '0xa4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4';
    const safeProposer = '0xa5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      () =>
        ({
          owner: async () => timelockOwner,
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== safeProposer.toLowerCase()) {
          throw new Error('not safe');
        }
        return {
          getThreshold: async () => 1,
        } as any;
      });

    const higherGrant = {
      topics: ['0xgrant-higher'],
      data: '0x',
      blockNumber: `0X${'0'.repeat(4093)}A`,
      transactionIndex: '0',
      logIndex: '0',
    };
    const lowerRevoke = {
      topics: ['0xrevoke-lower'],
      data: '0x',
      blockNumber: `0X${'0'.repeat(4093)}9`,
      transactionIndex: '0',
      logIndex: '0',
    };

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (filter.topics?.[0] === 'RoleGranted') {
          return [higherGrant];
        }
        return [lowerRevoke];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: () => ({ args: { account: safeProposer } }),
        },
      } as any);

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
      },
      registry: {
        getAddresses: async () => ({}),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.GNOSIS_TX_BUILDER);
      expect(
        (
          batches[0].config.submitter as any
        ).proposerSubmitter.safeAddress.toLowerCase(),
      ).to.equal(safeProposer.toLowerCase());
      expect(provider.getLogs.callCount).to.equal(2);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
    }
  });

  it('ignores raw-length-plus-one zero-padded hex timelock role positions during ordering', async () => {
    const timelockOwner = '0xa1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1';
    const safeProposer = '0xa2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2';
    const malformedProposer = '0xa3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      () =>
        ({
          owner: async () => timelockOwner,
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== safeProposer.toLowerCase()) {
          throw new Error('not safe');
        }
        return {
          getThreshold: async () => 1,
        } as any;
      });

    const validGrant = {
      topics: ['0xgrant-valid'],
      data: '0x',
      blockNumber: '1011',
      transactionIndex: '1',
      logIndex: '1',
    };
    const malformedBoundaryPlusOneGrant = {
      topics: ['0xgrant-malformed-raw-plus-one-hex'],
      data: '0x',
      blockNumber: `0x${'0'.repeat(4094)}1`,
      transactionIndex: '0',
      logIndex: '0',
    };
    const revoke = {
      topics: ['0xrevoke'],
      data: '0x',
      blockNumber: '1010',
      transactionIndex: '0',
      logIndex: '0',
    };

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (filter.topics?.[0] === 'RoleGranted') {
          return [validGrant, malformedBoundaryPlusOneGrant];
        }
        return [revoke];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (log: any) => ({
            args: {
              account: log === validGrant ? safeProposer : malformedProposer,
            },
          }),
        },
      } as any);

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
      },
      registry: {
        getAddresses: async () => ({}),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.GNOSIS_TX_BUILDER);
      expect(
        (
          batches[0].config.submitter as any
        ).proposerSubmitter.safeAddress.toLowerCase(),
      ).to.equal(safeProposer.toLowerCase());
      expect(provider.getLogs.callCount).to.equal(2);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
    }
  });

  it('ignores raw-length-plus-one uppercase-zero-padded hex timelock role positions during ordering', async () => {
    const timelockOwner = '0xa6a6a6a6a6a6a6a6a6a6a6a6a6a6a6a6a6a6a6a6';
    const safeProposer = '0xa7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a7';
    const malformedProposer = '0xa8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      () =>
        ({
          owner: async () => timelockOwner,
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== safeProposer.toLowerCase()) {
          throw new Error('not safe');
        }
        return {
          getThreshold: async () => 1,
        } as any;
      });

    const validGrant = {
      topics: ['0xgrant-valid'],
      data: '0x',
      blockNumber: '1012',
      transactionIndex: '1',
      logIndex: '1',
    };
    const malformedBoundaryPlusOneGrant = {
      topics: ['0xgrant-malformed-raw-plus-one-uppercase-hex'],
      data: '0x',
      blockNumber: `0X${'0'.repeat(4094)}1`,
      transactionIndex: '0',
      logIndex: '0',
    };
    const revoke = {
      topics: ['0xrevoke'],
      data: '0x',
      blockNumber: '1011',
      transactionIndex: '0',
      logIndex: '0',
    };

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (filter.topics?.[0] === 'RoleGranted') {
          return [validGrant, malformedBoundaryPlusOneGrant];
        }
        return [revoke];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (log: any) => ({
            args: {
              account: log === validGrant ? safeProposer : malformedProposer,
            },
          }),
        },
      } as any);

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
      },
      registry: {
        getAddresses: async () => ({}),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.GNOSIS_TX_BUILDER);
      expect(
        (
          batches[0].config.submitter as any
        ).proposerSubmitter.safeAddress.toLowerCase(),
      ).to.equal(safeProposer.toLowerCase());
      expect(provider.getLogs.callCount).to.equal(2);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
    }
  });

  it('ignores overlong decimal-string timelock role positions during ordering', async () => {
    const timelockOwner = '0x6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e';
    const safeProposer = '0x7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      () =>
        ({
          owner: async () => timelockOwner,
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== safeProposer.toLowerCase()) {
          throw new Error('not safe');
        }
        return {
          getThreshold: async () => 1,
        } as any;
      });

    const validGrant = {
      topics: ['0xgrant-valid'],
      data: '0x',
      blockNumber: '1004',
      transactionIndex: '1',
      logIndex: '1',
    };
    const malformedOverlongGrant = {
      topics: ['0xgrant-malformed-overlong-decimal'],
      data: '0x',
      blockNumber: '9'.repeat(300),
      transactionIndex: '0',
      logIndex: '0',
    };
    const revoke = {
      topics: ['0xrevoke'],
      data: '0x',
      blockNumber: '1003',
      transactionIndex: '0',
      logIndex: '0',
    };

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (filter.topics?.[0] === 'RoleGranted') {
          return [validGrant, malformedOverlongGrant];
        }
        return [revoke];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: () => ({ args: { account: safeProposer } }),
        },
      } as any);

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
      },
      registry: {
        getAddresses: async () => ({}),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.GNOSIS_TX_BUILDER);
      expect(
        (
          batches[0].config.submitter as any
        ).proposerSubmitter.safeAddress.toLowerCase(),
      ).to.equal(safeProposer.toLowerCase());
      expect(provider.getLogs.callCount).to.equal(2);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
    }
  });

  it('accepts overlong zero-padded decimal timelock role positions deterministically', async () => {
    const timelockOwner = '0x8686868686868686868686868686868686868686';
    const safeProposer = '0x8787878787878787878787878787878787878787';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      () =>
        ({
          owner: async () => timelockOwner,
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== safeProposer.toLowerCase()) {
          throw new Error('not safe');
        }
        return {
          getThreshold: async () => 1,
        } as any;
      });

    const higherGrant = {
      topics: ['0xgrant-higher'],
      data: '0x',
      blockNumber: `${'0'.repeat(300)}2`,
      transactionIndex: '0',
      logIndex: '0',
    };
    const lowerRevoke = {
      topics: ['0xrevoke-lower'],
      data: '0x',
      blockNumber: `${'0'.repeat(300)}1`,
      transactionIndex: '0',
      logIndex: '0',
    };

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (filter.topics?.[0] === 'RoleGranted') {
          return [higherGrant];
        }
        return [lowerRevoke];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: () => ({ args: { account: safeProposer } }),
        },
      } as any);

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
      },
      registry: {
        getAddresses: async () => ({}),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.GNOSIS_TX_BUILDER);
      expect(
        (
          batches[0].config.submitter as any
        ).proposerSubmitter.safeAddress.toLowerCase(),
      ).to.equal(safeProposer.toLowerCase());
      expect(provider.getLogs.callCount).to.equal(2);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
    }
  });

  it('accepts raw-length-boundary zero-padded decimal timelock role positions deterministically', async () => {
    const timelockOwner = '0xafafafafafafafafafafafafafafafafafafafaf';
    const safeProposer = '0xb0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      () =>
        ({
          owner: async () => timelockOwner,
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== safeProposer.toLowerCase()) {
          throw new Error('not safe');
        }
        return {
          getThreshold: async () => 1,
        } as any;
      });

    const higherGrant = {
      topics: ['0xgrant-higher'],
      data: '0x',
      blockNumber: `${'0'.repeat(4095)}2`,
      transactionIndex: '0',
      logIndex: '0',
    };
    const lowerRevoke = {
      topics: ['0xrevoke-lower'],
      data: '0x',
      blockNumber: `${'0'.repeat(4095)}1`,
      transactionIndex: '0',
      logIndex: '0',
    };

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (filter.topics?.[0] === 'RoleGranted') {
          return [higherGrant];
        }
        return [lowerRevoke];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: () => ({ args: { account: safeProposer } }),
        },
      } as any);

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
      },
      registry: {
        getAddresses: async () => ({}),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.GNOSIS_TX_BUILDER);
      expect(
        (
          batches[0].config.submitter as any
        ).proposerSubmitter.safeAddress.toLowerCase(),
      ).to.equal(safeProposer.toLowerCase());
      expect(provider.getLogs.callCount).to.equal(2);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
    }
  });

  it('ignores raw-length-plus-one zero-padded decimal timelock role positions during ordering', async () => {
    const timelockOwner = '0xacacacacacacacacacacacacacacacacacacacac';
    const safeProposer = '0xadadadadadadadadadadadadadadadadadadadad';
    const malformedProposer = '0xaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeae';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      () =>
        ({
          owner: async () => timelockOwner,
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== safeProposer.toLowerCase()) {
          throw new Error('not safe');
        }
        return {
          getThreshold: async () => 1,
        } as any;
      });

    const validGrant = {
      topics: ['0xgrant-valid'],
      data: '0x',
      blockNumber: '1014',
      transactionIndex: '1',
      logIndex: '1',
    };
    const malformedBoundaryPlusOneGrant = {
      topics: ['0xgrant-malformed-raw-plus-one-decimal'],
      data: '0x',
      blockNumber: `${'0'.repeat(4096)}1`,
      transactionIndex: '0',
      logIndex: '0',
    };
    const revoke = {
      topics: ['0xrevoke'],
      data: '0x',
      blockNumber: '1013',
      transactionIndex: '0',
      logIndex: '0',
    };

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (filter.topics?.[0] === 'RoleGranted') {
          return [validGrant, malformedBoundaryPlusOneGrant];
        }
        return [revoke];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (log: any) => ({
            args: {
              account: log === validGrant ? safeProposer : malformedProposer,
            },
          }),
        },
      } as any);

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
      },
      registry: {
        getAddresses: async () => ({}),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.GNOSIS_TX_BUILDER);
      expect(
        (
          batches[0].config.submitter as any
        ).proposerSubmitter.safeAddress.toLowerCase(),
      ).to.equal(safeProposer.toLowerCase());
      expect(provider.getLogs.callCount).to.equal(2);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
    }
  });

  it('ignores excessively long raw decimal timelock role positions during ordering', async () => {
    const timelockOwner = '0x8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a';
    const safeProposer = '0x8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      () =>
        ({
          owner: async () => timelockOwner,
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== safeProposer.toLowerCase()) {
          throw new Error('not safe');
        }
        return {
          getThreshold: async () => 1,
        } as any;
      });

    const validGrant = {
      topics: ['0xgrant-valid'],
      data: '0x',
      blockNumber: '1006',
      transactionIndex: '1',
      logIndex: '1',
    };
    const malformedRawLengthGrant = {
      topics: ['0xgrant-malformed-raw-length'],
      data: '0x',
      blockNumber: `${'0'.repeat(5000)}2`,
      transactionIndex: '0',
      logIndex: '0',
    };
    const revoke = {
      topics: ['0xrevoke'],
      data: '0x',
      blockNumber: '1005',
      transactionIndex: '0',
      logIndex: '0',
    };

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (filter.topics?.[0] === 'RoleGranted') {
          return [validGrant, malformedRawLengthGrant];
        }
        return [revoke];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: () => ({ args: { account: safeProposer } }),
        },
      } as any);

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
      },
      registry: {
        getAddresses: async () => ({}),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.GNOSIS_TX_BUILDER);
      expect(
        (
          batches[0].config.submitter as any
        ).proposerSubmitter.safeAddress.toLowerCase(),
      ).to.equal(safeProposer.toLowerCase());
      expect(provider.getLogs.callCount).to.equal(2);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
    }
  });

  it('ignores excessively long raw whitespace-padded timelock role positions during ordering', async () => {
    const timelockOwner = '0x8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e';
    const safeProposer = '0x8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f';
    const malformedProposer = '0x9090909090909090909090909090909090909090';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      () =>
        ({
          owner: async () => timelockOwner,
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== safeProposer.toLowerCase()) {
          throw new Error('not safe');
        }
        return {
          getThreshold: async () => 1,
        } as any;
      });

    const validGrant = {
      topics: ['0xgrant-valid'],
      data: '0x',
      blockNumber: '1008',
      transactionIndex: '1',
      logIndex: '1',
    };
    const malformedRawWhitespaceGrant = {
      topics: ['0xgrant-malformed-raw-whitespace'],
      data: '0x',
      blockNumber: `${' '.repeat(5000)}9999`,
      transactionIndex: '0',
      logIndex: '0',
    };
    const revoke = {
      topics: ['0xrevoke'],
      data: '0x',
      blockNumber: '1007',
      transactionIndex: '0',
      logIndex: '0',
    };

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (filter.topics?.[0] === 'RoleGranted') {
          return [validGrant, malformedRawWhitespaceGrant];
        }
        return [revoke];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (log: any) => ({
            args: {
              account: log === validGrant ? safeProposer : malformedProposer,
            },
          }),
        },
      } as any);

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
      },
      registry: {
        getAddresses: async () => ({}),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.GNOSIS_TX_BUILDER);
      expect(
        (
          batches[0].config.submitter as any
        ).proposerSubmitter.safeAddress.toLowerCase(),
      ).to.equal(safeProposer.toLowerCase());
      expect(provider.getLogs.callCount).to.equal(2);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
    }
  });

  it('accepts raw-length-boundary whitespace-padded timelock role positions deterministically', async () => {
    const timelockOwner = '0x9191919191919191919191919191919191919191';
    const safeProposer = '0x9292929292929292929292929292929292929292';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      () =>
        ({
          owner: async () => timelockOwner,
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== safeProposer.toLowerCase()) {
          throw new Error('not safe');
        }
        return {
          getThreshold: async () => 1,
        } as any;
      });

    const higherGrant = {
      topics: ['0xgrant-higher'],
      data: '0x',
      blockNumber: `${' '.repeat(4095)}2`,
      transactionIndex: '0',
      logIndex: '0',
    };
    const lowerRevoke = {
      topics: ['0xrevoke-lower'],
      data: '0x',
      blockNumber: `${' '.repeat(4095)}1`,
      transactionIndex: '0',
      logIndex: '0',
    };

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (filter.topics?.[0] === 'RoleGranted') {
          return [higherGrant];
        }
        return [lowerRevoke];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: () => ({ args: { account: safeProposer } }),
        },
      } as any);

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
      },
      registry: {
        getAddresses: async () => ({}),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.GNOSIS_TX_BUILDER);
      expect(
        (
          batches[0].config.submitter as any
        ).proposerSubmitter.safeAddress.toLowerCase(),
      ).to.equal(safeProposer.toLowerCase());
      expect(provider.getLogs.callCount).to.equal(2);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
    }
  });

  it('ignores raw-length-plus-one whitespace-padded timelock role positions during ordering', async () => {
    const timelockOwner = '0x9999999999999999999999999999999999999999';
    const safeProposer = '0x9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a';
    const malformedProposer = '0x9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      () =>
        ({
          owner: async () => timelockOwner,
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== safeProposer.toLowerCase()) {
          throw new Error('not safe');
        }
        return {
          getThreshold: async () => 1,
        } as any;
      });

    const validGrant = {
      topics: ['0xgrant-valid'],
      data: '0x',
      blockNumber: '1009',
      transactionIndex: '1',
      logIndex: '1',
    };
    const malformedBoundaryPlusOneGrant = {
      topics: ['0xgrant-malformed-raw-boundary-plus-one'],
      data: '0x',
      blockNumber: `${' '.repeat(4096)}1`,
      transactionIndex: '0',
      logIndex: '0',
    };
    const revoke = {
      topics: ['0xrevoke'],
      data: '0x',
      blockNumber: '1008',
      transactionIndex: '0',
      logIndex: '0',
    };

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (filter.topics?.[0] === 'RoleGranted') {
          return [validGrant, malformedBoundaryPlusOneGrant];
        }
        return [revoke];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (log: any) => ({
            args: {
              account: log === validGrant ? safeProposer : malformedProposer,
            },
          }),
        },
      } as any);

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
      },
      registry: {
        getAddresses: async () => ({}),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.GNOSIS_TX_BUILDER);
      expect(
        (
          batches[0].config.submitter as any
        ).proposerSubmitter.safeAddress.toLowerCase(),
      ).to.equal(safeProposer.toLowerCase());
      expect(provider.getLogs.callCount).to.equal(2);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
    }
  });

  it('accepts max-length decimal-string timelock role positions deterministically', async () => {
    const timelockOwner = '0x8484848484848484848484848484848484848484';
    const safeProposer = '0x8585858585858585858585858585858585858585';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      () =>
        ({
          owner: async () => timelockOwner,
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== safeProposer.toLowerCase()) {
          throw new Error('not safe');
        }
        return {
          getThreshold: async () => 1,
        } as any;
      });

    const higherGrant = {
      topics: ['0xgrant-higher'],
      data: '0x',
      blockNumber: '1'.repeat(256),
      transactionIndex: '0',
      logIndex: '0',
    };
    const lowerRevoke = {
      topics: ['0xrevoke-lower'],
      data: '0x',
      blockNumber: '9'.repeat(255),
      transactionIndex: '0',
      logIndex: '0',
    };

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (filter.topics?.[0] === 'RoleGranted') {
          return [higherGrant];
        }
        return [lowerRevoke];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: () => ({ args: { account: safeProposer } }),
        },
      } as any);

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
      },
      registry: {
        getAddresses: async () => ({}),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.GNOSIS_TX_BUILDER);
      expect(
        (
          batches[0].config.submitter as any
        ).proposerSubmitter.safeAddress.toLowerCase(),
      ).to.equal(safeProposer.toLowerCase());
      expect(provider.getLogs.callCount).to.equal(2);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
    }
  });

  it('ignores overlong toString timelock role positions during ordering', async () => {
    const timelockOwner = '0x8080808080808080808080808080808080808080';
    const safeProposer = '0x8181818181818181818181818181818181818181';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      () =>
        ({
          owner: async () => timelockOwner,
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== safeProposer.toLowerCase()) {
          throw new Error('not safe');
        }
        return {
          getThreshold: async () => 1,
        } as any;
      });

    const validGrant = {
      topics: ['0xgrant-valid'],
      data: '0x',
      blockNumber: '1005',
      transactionIndex: '1',
      logIndex: '1',
    };
    const malformedToStringGrant = {
      topics: ['0xgrant-malformed-tostring-overlong'],
      data: '0x',
      blockNumber: {
        toString: () => `0x${'f'.repeat(300)}`,
      },
      transactionIndex: '0',
      logIndex: '0',
    };
    const revoke = {
      topics: ['0xrevoke'],
      data: '0x',
      blockNumber: '1004',
      transactionIndex: '0',
      logIndex: '0',
    };

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (filter.topics?.[0] === 'RoleGranted') {
          return [validGrant, malformedToStringGrant];
        }
        return [revoke];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: () => ({ args: { account: safeProposer } }),
        },
      } as any);

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
      },
      registry: {
        getAddresses: async () => ({}),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.GNOSIS_TX_BUILDER);
      expect(
        (
          batches[0].config.submitter as any
        ).proposerSubmitter.safeAddress.toLowerCase(),
      ).to.equal(safeProposer.toLowerCase());
      expect(provider.getLogs.callCount).to.equal(2);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
    }
  });

  it('ignores excessively long raw toString timelock role positions during ordering', async () => {
    const timelockOwner = '0x8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c';
    const safeProposer = '0x8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      () =>
        ({
          owner: async () => timelockOwner,
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== safeProposer.toLowerCase()) {
          throw new Error('not safe');
        }
        return {
          getThreshold: async () => 1,
        } as any;
      });

    const validGrant = {
      topics: ['0xgrant-valid'],
      data: '0x',
      blockNumber: '1007',
      transactionIndex: '1',
      logIndex: '1',
    };
    const malformedRawToStringGrant = {
      topics: ['0xgrant-malformed-raw-tostring'],
      data: '0x',
      blockNumber: {
        toString: () => `${'0'.repeat(5000)}2`,
      },
      transactionIndex: '0',
      logIndex: '0',
    };
    const revoke = {
      topics: ['0xrevoke'],
      data: '0x',
      blockNumber: '1006',
      transactionIndex: '0',
      logIndex: '0',
    };

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (filter.topics?.[0] === 'RoleGranted') {
          return [validGrant, malformedRawToStringGrant];
        }
        return [revoke];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: () => ({ args: { account: safeProposer } }),
        },
      } as any);

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
      },
      registry: {
        getAddresses: async () => ({}),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.GNOSIS_TX_BUILDER);
      expect(
        (
          batches[0].config.submitter as any
        ).proposerSubmitter.safeAddress.toLowerCase(),
      ).to.equal(safeProposer.toLowerCase());
      expect(provider.getLogs.callCount).to.equal(2);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
    }
  });

  it('accepts raw-length-boundary toString timelock role positions deterministically', async () => {
    const timelockOwner = '0x9393939393939393939393939393939393939393';
    const safeProposer = '0x9494949494949494949494949494949494949494';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      () =>
        ({
          owner: async () => timelockOwner,
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== safeProposer.toLowerCase()) {
          throw new Error('not safe');
        }
        return {
          getThreshold: async () => 1,
        } as any;
      });

    const higherGrant = {
      topics: ['0xgrant-higher'],
      data: '0x',
      blockNumber: {
        toString: () => `${' '.repeat(4095)}2`,
      },
      transactionIndex: '0',
      logIndex: '0',
    };
    const lowerRevoke = {
      topics: ['0xrevoke-lower'],
      data: '0x',
      blockNumber: {
        toString: () => `${' '.repeat(4095)}1`,
      },
      transactionIndex: '0',
      logIndex: '0',
    };

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (filter.topics?.[0] === 'RoleGranted') {
          return [higherGrant];
        }
        return [lowerRevoke];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: () => ({ args: { account: safeProposer } }),
        },
      } as any);

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
      },
      registry: {
        getAddresses: async () => ({}),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.GNOSIS_TX_BUILDER);
      expect(
        (
          batches[0].config.submitter as any
        ).proposerSubmitter.safeAddress.toLowerCase(),
      ).to.equal(safeProposer.toLowerCase());
      expect(provider.getLogs.callCount).to.equal(2);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
    }
  });

  it('accepts raw-length-boundary uppercase-zero-padded toString timelock positions deterministically', async () => {
    const timelockOwner = '0x9797979797979797979797979797979797979797';
    const safeProposer = '0x9898989898989898989898989898989898989898';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      () =>
        ({
          owner: async () => timelockOwner,
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== safeProposer.toLowerCase()) {
          throw new Error('not safe');
        }
        return {
          getThreshold: async () => 1,
        } as any;
      });

    const higherGrant = {
      topics: ['0xgrant-higher'],
      data: '0x',
      blockNumber: {
        toString: () => `0X${'0'.repeat(4093)}A`,
      },
      transactionIndex: '0',
      logIndex: '0',
    };
    const lowerRevoke = {
      topics: ['0xrevoke-lower'],
      data: '0x',
      blockNumber: {
        toString: () => `0X${'0'.repeat(4093)}9`,
      },
      transactionIndex: '0',
      logIndex: '0',
    };

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (filter.topics?.[0] === 'RoleGranted') {
          return [higherGrant];
        }
        return [lowerRevoke];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: () => ({ args: { account: safeProposer } }),
        },
      } as any);

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
      },
      registry: {
        getAddresses: async () => ({}),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.GNOSIS_TX_BUILDER);
      expect(
        (
          batches[0].config.submitter as any
        ).proposerSubmitter.safeAddress.toLowerCase(),
      ).to.equal(safeProposer.toLowerCase());
      expect(provider.getLogs.callCount).to.equal(2);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
    }
  });

  it('ignores raw-length-plus-one toString timelock positions during ordering', async () => {
    const timelockOwner = '0x9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c';
    const safeProposer = '0x9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d';
    const malformedProposer = '0x9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      () =>
        ({
          owner: async () => timelockOwner,
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== safeProposer.toLowerCase()) {
          throw new Error('not safe');
        }
        return {
          getThreshold: async () => 1,
        } as any;
      });

    const validGrant = {
      topics: ['0xgrant-valid'],
      data: '0x',
      blockNumber: '1010',
      transactionIndex: '1',
      logIndex: '1',
    };
    const malformedBoundaryPlusOneGrant = {
      topics: ['0xgrant-malformed-raw-plus-one-tostring'],
      data: '0x',
      blockNumber: {
        toString: () => `${' '.repeat(4096)}1`,
      },
      transactionIndex: '0',
      logIndex: '0',
    };
    const revoke = {
      topics: ['0xrevoke'],
      data: '0x',
      blockNumber: '1009',
      transactionIndex: '0',
      logIndex: '0',
    };

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (filter.topics?.[0] === 'RoleGranted') {
          return [validGrant, malformedBoundaryPlusOneGrant];
        }
        return [revoke];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (log: any) => ({
            args: {
              account: log === validGrant ? safeProposer : malformedProposer,
            },
          }),
        },
      } as any);

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
      },
      registry: {
        getAddresses: async () => ({}),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.GNOSIS_TX_BUILDER);
      expect(
        (
          batches[0].config.submitter as any
        ).proposerSubmitter.safeAddress.toLowerCase(),
      ).to.equal(safeProposer.toLowerCase());
      expect(provider.getLogs.callCount).to.equal(2);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
    }
  });

  it('ignores raw-length-plus-one uppercase-zero-padded toString timelock positions during ordering', async () => {
    const timelockOwner = '0xa9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9';
    const safeProposer = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa';
    const malformedProposer = '0xabababababababababababababababababababab';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      () =>
        ({
          owner: async () => timelockOwner,
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== safeProposer.toLowerCase()) {
          throw new Error('not safe');
        }
        return {
          getThreshold: async () => 1,
        } as any;
      });

    const validGrant = {
      topics: ['0xgrant-valid'],
      data: '0x',
      blockNumber: '1013',
      transactionIndex: '1',
      logIndex: '1',
    };
    const malformedBoundaryPlusOneGrant = {
      topics: ['0xgrant-malformed-raw-plus-one-uppercase-tostring'],
      data: '0x',
      blockNumber: {
        toString: () => `0X${'0'.repeat(4094)}1`,
      },
      transactionIndex: '0',
      logIndex: '0',
    };
    const revoke = {
      topics: ['0xrevoke'],
      data: '0x',
      blockNumber: '1012',
      transactionIndex: '0',
      logIndex: '0',
    };

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (filter.topics?.[0] === 'RoleGranted') {
          return [validGrant, malformedBoundaryPlusOneGrant];
        }
        return [revoke];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (log: any) => ({
            args: {
              account: log === validGrant ? safeProposer : malformedProposer,
            },
          }),
        },
      } as any);

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
      },
      registry: {
        getAddresses: async () => ({}),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.GNOSIS_TX_BUILDER);
      expect(
        (
          batches[0].config.submitter as any
        ).proposerSubmitter.safeAddress.toLowerCase(),
      ).to.equal(safeProposer.toLowerCase());
      expect(provider.getLogs.callCount).to.equal(2);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
    }
  });

  it('ignores signed-hex toString timelock role positions during ordering', async () => {
    const timelockOwner = '0xd7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7';
    const safeProposer = '0xd8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      () =>
        ({
          owner: async () => timelockOwner,
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== safeProposer.toLowerCase()) {
          throw new Error('not safe');
        }
        return {
          getThreshold: async () => 1,
        } as any;
      });

    const validGrant = {
      topics: ['0xgrant-valid'],
      data: '0x',
      blockNumber: '1031',
      transactionIndex: '1',
      logIndex: '1',
    };
    const malformedPlusGrant = {
      topics: ['0xgrant-malformed-signed-plus-tostring'],
      data: '0x',
      blockNumber: {
        toString: () => '+0X270f',
      },
      transactionIndex: '0',
      logIndex: '0',
    };
    const malformedMinusGrant = {
      topics: ['0xgrant-malformed-signed-minus-tostring'],
      data: '0x',
      blockNumber: {
        toString: () => '-0x270f',
      },
      transactionIndex: '0',
      logIndex: '0',
    };
    const malformedPlusEmptyHexGrant = {
      topics: ['0xgrant-malformed-signed-plus-empty-hex-tostring'],
      data: '0x',
      blockNumber: {
        toString: () => '+0x',
      },
      transactionIndex: '0',
      logIndex: '0',
    };
    const malformedMinusEmptyHexGrant = {
      topics: ['0xgrant-malformed-signed-minus-empty-hex-tostring'],
      data: '0x',
      blockNumber: {
        toString: () => '-0X',
      },
      transactionIndex: '0',
      logIndex: '0',
    };
    const revoke = {
      topics: ['0xrevoke'],
      data: '0x',
      blockNumber: '1030',
      transactionIndex: '0',
      logIndex: '0',
    };

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (filter.topics?.[0] === 'RoleGranted') {
          return [
            validGrant,
            malformedPlusGrant,
            malformedMinusGrant,
            malformedPlusEmptyHexGrant,
            malformedMinusEmptyHexGrant,
          ];
        }
        return [revoke];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: () => ({ args: { account: safeProposer } }),
        },
      } as any);

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
      },
      registry: {
        getAddresses: async () => ({}),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.GNOSIS_TX_BUILDER);
      expect(
        (
          batches[0].config.submitter as any
        ).proposerSubmitter.safeAddress.toLowerCase(),
      ).to.equal(safeProposer.toLowerCase());
      expect(provider.getLogs.callCount).to.equal(2);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
    }
  });

  it('ignores non-string toString timelock role positions during ordering', async () => {
    const timelockOwner = '0x6161616161616161616161616161616161616161';
    const safeProposer = '0x7272727272727272727272727272727272727272';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      () =>
        ({
          owner: async () => timelockOwner,
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== safeProposer.toLowerCase()) {
          throw new Error('not safe');
        }
        return {
          getThreshold: async () => 1,
        } as any;
      });

    const validGrant = {
      topics: ['0xgrant-valid'],
      data: '0x',
      blockNumber: '1200',
      transactionIndex: '1',
      logIndex: '1',
    };
    const malformedGrant = {
      topics: ['0xgrant-malformed'],
      data: '0x',
      blockNumber: {
        toString: () => ({}) as any,
      },
      transactionIndex: '0',
      logIndex: '0',
    };
    const revoke = {
      topics: ['0xrevoke'],
      data: '0x',
      blockNumber: '1199',
      transactionIndex: '0',
      logIndex: '0',
    };

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (filter.topics?.[0] === 'RoleGranted') {
          return [validGrant, malformedGrant];
        }
        return [revoke];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: () => ({ args: { account: safeProposer } }),
        },
      } as any);

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
      },
      registry: {
        getAddresses: async () => ({}),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.GNOSIS_TX_BUILDER);
      expect(
        (
          batches[0].config.submitter as any
        ).proposerSubmitter.safeAddress.toLowerCase(),
      ).to.equal(safeProposer.toLowerCase());
      expect(provider.getLogs.callCount).to.equal(2);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
    }
  });

  it('ignores object-default toString timelock role positions during ordering', async () => {
    const timelockOwner = '0xdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdc';
    const safeProposer = '0xdddddddddddddddddddddddddddddddddddddddd';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      () =>
        ({
          owner: async () => timelockOwner,
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== safeProposer.toLowerCase()) {
          throw new Error('not safe');
        }
        return {
          getThreshold: async () => 1,
        } as any;
      });

    const validGrant = {
      topics: ['0xgrant-valid'],
      data: '0x',
      blockNumber: '1201',
      transactionIndex: '1',
      logIndex: '1',
    };
    const malformedGrant = {
      topics: ['0xgrant-malformed-object-default-tostring'],
      data: '0x',
      blockNumber: {
        toString: () => '[object Object]',
      },
      transactionIndex: '0',
      logIndex: '0',
    };
    const revoke = {
      topics: ['0xrevoke'],
      data: '0x',
      blockNumber: '1200',
      transactionIndex: '0',
      logIndex: '0',
    };

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (filter.topics?.[0] === 'RoleGranted') {
          return [validGrant, malformedGrant];
        }
        return [revoke];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: () => ({ args: { account: safeProposer } }),
        },
      } as any);

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
      },
      registry: {
        getAddresses: async () => ({}),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.GNOSIS_TX_BUILDER);
      expect(
        (
          batches[0].config.submitter as any
        ).proposerSubmitter.safeAddress.toLowerCase(),
      ).to.equal(safeProposer.toLowerCase());
      expect(provider.getLogs.callCount).to.equal(2);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
    }
  });

  it('ignores throwing toString timelock role positions during ordering', async () => {
    const timelockOwner = '0x6767676767676767676767676767676767676767';
    const safeProposer = '0x7878787878787878787878787878787878787878';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      () =>
        ({
          owner: async () => timelockOwner,
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== safeProposer.toLowerCase()) {
          throw new Error('not safe');
        }
        return {
          getThreshold: async () => 1,
        } as any;
      });

    const validGrant = {
      topics: ['0xgrant-valid'],
      data: '0x',
      blockNumber: '1600',
      transactionIndex: '1',
      logIndex: '1',
    };
    const malformedGrant = {
      topics: ['0xgrant-malformed'],
      data: '0x',
      blockNumber: {
        toString: () => {
          throw new Error('toString failed');
        },
      },
      transactionIndex: '0',
      logIndex: '0',
    };
    const revoke = {
      topics: ['0xrevoke'],
      data: '0x',
      blockNumber: '1599',
      transactionIndex: '0',
      logIndex: '0',
    };

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (filter.topics?.[0] === 'RoleGranted') {
          return [validGrant, malformedGrant];
        }
        return [revoke];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: () => ({ args: { account: safeProposer } }),
        },
      } as any);

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
      },
      registry: {
        getAddresses: async () => ({}),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.GNOSIS_TX_BUILDER);
      expect(
        (
          batches[0].config.submitter as any
        ).proposerSubmitter.safeAddress.toLowerCase(),
      ).to.equal(safeProposer.toLowerCase());
      expect(provider.getLogs.callCount).to.equal(2);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
    }
  });

  it('ignores unsafe-number timelock role positions during ordering', async () => {
    const timelockOwner = '0x6363636363636363636363636363636363636363';
    const safeProposer = '0x7474747474747474747474747474747474747474';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      () =>
        ({
          owner: async () => timelockOwner,
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== safeProposer.toLowerCase()) {
          throw new Error('not safe');
        }
        return {
          getThreshold: async () => 1,
        } as any;
      });

    const validGrant = {
      topics: ['0xgrant-valid'],
      data: '0x',
      blockNumber: 1400,
      transactionIndex: 1,
      logIndex: 1,
    };
    const malformedGrant = {
      topics: ['0xgrant-malformed'],
      data: '0x',
      blockNumber: 1e20,
      transactionIndex: 0,
      logIndex: 0,
    };
    const revoke = {
      topics: ['0xrevoke'],
      data: '0x',
      blockNumber: 1399,
      transactionIndex: 0,
      logIndex: 0,
    };

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (filter.topics?.[0] === 'RoleGranted') {
          return [validGrant, malformedGrant];
        }
        return [revoke];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: () => ({ args: { account: safeProposer } }),
        },
      } as any);

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
      },
      registry: {
        getAddresses: async () => ({}),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.GNOSIS_TX_BUILDER);
      expect(
        (
          batches[0].config.submitter as any
        ).proposerSubmitter.safeAddress.toLowerCase(),
      ).to.equal(safeProposer.toLowerCase());
      expect(provider.getLogs.callCount).to.equal(2);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
    }
  });

  it('ignores non-finite-number timelock role positions during ordering', async () => {
    const timelockOwner = '0xf5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5';
    const safeProposer = '0xf6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      () =>
        ({
          owner: async () => timelockOwner,
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== safeProposer.toLowerCase()) {
          throw new Error('not safe');
        }
        return {
          getThreshold: async () => 1,
        } as any;
      });

    const validGrant = {
      topics: ['0xgrant-valid'],
      data: '0x',
      blockNumber: 1401,
      transactionIndex: 1,
      logIndex: 1,
    };
    const malformedInfinityGrant = {
      topics: ['0xgrant-malformed-infinity'],
      data: '0x',
      blockNumber: Number.POSITIVE_INFINITY,
      transactionIndex: 999,
      logIndex: 999,
    };
    const malformedNaNGrant = {
      topics: ['0xgrant-malformed-nan'],
      data: '0x',
      blockNumber: Number.NaN,
      transactionIndex: 999,
      logIndex: 999,
    };
    const malformedNegativeInfinityGrant = {
      topics: ['0xgrant-malformed-negative-infinity'],
      data: '0x',
      blockNumber: Number.NEGATIVE_INFINITY,
      transactionIndex: 999,
      logIndex: 999,
    };
    const revoke = {
      topics: ['0xrevoke'],
      data: '0x',
      blockNumber: 1400,
      transactionIndex: 0,
      logIndex: 0,
    };

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (filter.topics?.[0] === 'RoleGranted') {
          return [
            malformedInfinityGrant,
            malformedNaNGrant,
            malformedNegativeInfinityGrant,
            validGrant,
          ];
        }
        return [revoke];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: () => ({ args: { account: safeProposer } }),
        },
      } as any);

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
      },
      registry: {
        getAddresses: async () => ({}),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.GNOSIS_TX_BUILDER);
      expect(
        (
          batches[0].config.submitter as any
        ).proposerSubmitter.safeAddress.toLowerCase(),
      ).to.equal(safeProposer.toLowerCase());
      expect(provider.getLogs.callCount).to.equal(2);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
    }
  });

  it('accepts max-safe-number timelock role positions deterministically', async () => {
    const timelockOwner = '0xebebebebebebebebebebebebebebebebebebebeb';
    const safeProposer = '0xecececececececececececececececececececec';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      () =>
        ({
          owner: async () => timelockOwner,
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== safeProposer.toLowerCase()) {
          throw new Error('not safe');
        }
        return {
          getThreshold: async () => 1,
        } as any;
      });

    const higherGrant = {
      topics: ['0xgrant-higher'],
      data: '0x',
      blockNumber: Number.MAX_SAFE_INTEGER,
      transactionIndex: 1,
      logIndex: 1,
    };
    const lowerRevoke = {
      topics: ['0xrevoke-lower'],
      data: '0x',
      blockNumber: Number.MAX_SAFE_INTEGER - 1,
      transactionIndex: 0,
      logIndex: 0,
    };

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (filter.topics?.[0] === 'RoleGranted') {
          return [higherGrant];
        }
        return [lowerRevoke];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: () => ({ args: { account: safeProposer } }),
        },
      } as any);

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
      },
      registry: {
        getAddresses: async () => ({}),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.GNOSIS_TX_BUILDER);
      expect(
        (
          batches[0].config.submitter as any
        ).proposerSubmitter.safeAddress.toLowerCase(),
      ).to.equal(safeProposer.toLowerCase());
      expect(provider.getLogs.callCount).to.equal(2);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
    }
  });

  it('ignores negative-number timelock role positions during ordering', async () => {
    const timelockOwner = '0xf0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0';
    const safeProposer = '0xf1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      () =>
        ({
          owner: async () => timelockOwner,
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== safeProposer.toLowerCase()) {
          throw new Error('not safe');
        }
        return {
          getThreshold: async () => 1,
        } as any;
      });

    const validGrant = {
      topics: ['0xgrant-valid'],
      data: '0x',
      blockNumber: 1303,
      transactionIndex: 1,
      logIndex: 1,
    };
    const malformedNegativeGrant = {
      topics: ['0xgrant-malformed-negative'],
      data: '0x',
      blockNumber: -1,
      transactionIndex: 0,
      logIndex: 0,
    };
    const revoke = {
      topics: ['0xrevoke'],
      data: '0x',
      blockNumber: 1302,
      transactionIndex: 0,
      logIndex: 0,
    };

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (filter.topics?.[0] === 'RoleGranted') {
          return [validGrant, malformedNegativeGrant];
        }
        return [revoke];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: () => ({ args: { account: safeProposer } }),
        },
      } as any);

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
      },
      registry: {
        getAddresses: async () => ({}),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.GNOSIS_TX_BUILDER);
      expect(
        (
          batches[0].config.submitter as any
        ).proposerSubmitter.safeAddress.toLowerCase(),
      ).to.equal(safeProposer.toLowerCase());
      expect(provider.getLogs.callCount).to.equal(2);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
    }
  });

  it('ignores fractional-number timelock role positions during ordering', async () => {
    const timelockOwner = '0x6868686868686868686868686868686868686868';
    const safeProposer = '0x7979797979797979797979797979797979797979';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      () =>
        ({
          owner: async () => timelockOwner,
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() !== safeProposer.toLowerCase()) {
          throw new Error('not safe');
        }
        return {
          getThreshold: async () => 1,
        } as any;
      });

    const validGrant = {
      topics: ['0xgrant-valid'],
      data: '0x',
      blockNumber: 1800,
      transactionIndex: 1,
      logIndex: 1,
    };
    const malformedGrant = {
      topics: ['0xgrant-malformed'],
      data: '0x',
      blockNumber: 1800.5,
      transactionIndex: 0,
      logIndex: 0,
    };
    const revoke = {
      topics: ['0xrevoke'],
      data: '0x',
      blockNumber: 1799,
      transactionIndex: 0,
      logIndex: 0,
    };

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (filter.topics?.[0] === 'RoleGranted') {
          return [validGrant, malformedGrant];
        }
        return [revoke];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: () => ({ args: { account: safeProposer } }),
        },
      } as any);

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
      },
      registry: {
        getAddresses: async () => ({}),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.GNOSIS_TX_BUILDER);
      expect(
        (
          batches[0].config.submitter as any
        ).proposerSubmitter.safeAddress.toLowerCase(),
      ).to.equal(safeProposer.toLowerCase());
      expect(provider.getLogs.callCount).to.equal(2);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
    }
  });

  it('ignores malformed proposer account addresses in timelock role logs', async () => {
    const timelockOwner = '0x5555555555555555555555555555555555555555';
    const safeProposer = '0x6666666666666666666666666666666666666666';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      () =>
        ({
          owner: async () => timelockOwner,
        }) as any,
    );

    const checkedSafeAddresses: string[] = [];
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .callsFake((address: string) => {
        checkedSafeAddresses.push(address.toLowerCase());
        if (address.toLowerCase() !== safeProposer.toLowerCase()) {
          throw new Error('not safe');
        }
        return {
          getThreshold: async () => 1,
        } as any;
      });

    const invalidAccountLog = { topics: ['0xinvalid-account'], data: '0x' };
    const validGrantedLog = { topics: ['0xvalid-granted'], data: '0x' };
    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (filter.topics?.[0] === 'RoleGranted') {
          return [invalidAccountLog, validGrantedLog];
        }
        return [];
      }),
    };
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (log: any) => {
            if (log === invalidAccountLog) {
              return { args: { account: 'not-an-address' } };
            }
            return { args: { account: safeProposer } };
          },
        },
      } as any);

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
      },
      registry: {
        getAddresses: async () => ({}),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.GNOSIS_TX_BUILDER);
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.safeAddress,
      ).to.equal(safeProposer);
      expect(checkedSafeAddresses).to.deep.equal([
        timelockOwner.toLowerCase(),
        safeProposer.toLowerCase(),
      ]);
      expect(provider.getLogs.callCount).to.equal(2);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
    }
  });

  it('ignores zero proposer account addresses in timelock role logs', async () => {
    const timelockOwner = '0x5757575757575757575757575757575757575757';
    const safeProposer = '0x6868686868686868686868686868686868686868';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      () =>
        ({
          owner: async () => timelockOwner,
        }) as any,
    );

    const checkedSafeAddresses: string[] = [];
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .callsFake((address: string) => {
        checkedSafeAddresses.push(address.toLowerCase());
        if (address.toLowerCase() !== safeProposer.toLowerCase()) {
          throw new Error('not safe');
        }
        return {
          getThreshold: async () => 1,
        } as any;
      });

    const zeroAccountLog = { topics: ['0xzero-account'], data: '0x' };
    const validGrantedLog = { topics: ['0xvalid-granted'], data: '0x' };
    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (filter.topics?.[0] === 'RoleGranted') {
          return [zeroAccountLog, validGrantedLog];
        }
        return [];
      }),
    };
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (log: any) => {
            if (log === zeroAccountLog) {
              return { args: { account: ethersConstants.AddressZero } };
            }
            return { args: { account: safeProposer } };
          },
        },
      } as any);

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
      },
      registry: {
        getAddresses: async () => ({}),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.GNOSIS_TX_BUILDER);
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.safeAddress,
      ).to.equal(safeProposer);
      expect(checkedSafeAddresses).to.deep.equal([
        timelockOwner.toLowerCase(),
        safeProposer.toLowerCase(),
      ]);
      expect(provider.getLogs.callCount).to.equal(2);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
    }
  });

  it('falls back to default timelock proposer when registry lookup fails', async () => {
    const timelockOwner = '0x7777777777777777777777777777777777777777';
    const nonSafeProposer = '0x8888888888888888888888888888888888888888';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      () =>
        ({
          owner: async () => timelockOwner,
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (filter.topics?.[0] === 'RoleGranted') {
          return [{ topics: ['0xvalid-granted'], data: '0x' }];
        }
        return [];
      }),
    };
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: () => ({ args: { account: nonSafeProposer } }),
        },
      } as any);

    let registryReads = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
      },
      registry: {
        getAddresses: async () => {
          registryReads += 1;
          throw new Error('registry unavailable');
        },
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          TX as any,
          { ...TX, to: '0x9999999999999999999999999999999999999999' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(registryReads).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
    }
  });

  it('falls back to default timelock proposer when destination router address is invalid', async () => {
    const timelockOwner = '0x7979797979797979797979797979797979797979';
    const nonSafeProposer = '0x7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      () =>
        ({
          owner: async () => timelockOwner,
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (filter.topics?.[0] === 'RoleGranted') {
          return [{ topics: ['0xvalid-granted'], data: '0x' }];
        }
        return [];
      }),
    };
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: () => ({ args: { account: nonSafeProposer } }),
        },
      } as any);

    let registryReads = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
      },
      registry: {
        getAddresses: async () => {
          registryReads += 1;
          return {
            [CHAIN]: {
              interchainAccountRouter: 'not-an-address',
            },
            anvil3: {
              interchainAccountRouter:
                '0x8888888888888888888888888888888888888888',
            },
          };
        },
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          TX as any,
          { ...TX, to: '0x9999999999999999999999999999999999999999' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(registryReads).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(2);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
    }
  });

  it('falls back to default timelock proposer when destination router address is zero', async () => {
    const timelockOwner = '0x7979797979797979797979797979797979797979';
    const nonSafeProposer = '0x7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      () =>
        ({
          owner: async () => timelockOwner,
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (filter.topics?.[0] === 'RoleGranted') {
          return [{ topics: ['0xvalid-granted'], data: '0x' }];
        }
        return [];
      }),
    };
    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: () => ({ args: { account: nonSafeProposer } }),
        },
      } as any);

    let registryReads = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
      },
      registry: {
        getAddresses: async () => {
          registryReads += 1;
          return {
            [CHAIN]: {
              interchainAccountRouter: ethersConstants.AddressZero,
            },
            anvil3: {
              interchainAccountRouter:
                '0x8888888888888888888888888888888888888888',
            },
          };
        },
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          TX as any,
          { ...TX, to: '0x9999999999999999999999999999999999999999' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(registryReads).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(2);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
    }
  });

  it('infers timelock proposer ICA from proposer role account derivation', async () => {
    const timelockOwner = '0x5555555555555555555555555555555555555555';
    const proposerIca = '0x6666666666666666666666666666666666666666';
    const destinationRouterAddress =
      '0x7777777777777777777777777777777777777777';
    const originRouterAddress = '0x8888888888888888888888888888888888888888';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => timelockOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          filter.address?.toLowerCase() === timelockOwner.toLowerCase() &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const hasRoleStub = sinon
      .stub()
      .callsFake(async (_role: string, account: string) => {
        return account.toLowerCase() === proposerIca.toLowerCase();
      });

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: hasRoleStub,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.INTERCHAIN_ACCOUNT);
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.owner,
      ).to.equal(SIGNER);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('falls back to default timelock proposer when role-derived ICA proposer is zero address', async () => {
    const timelockOwner = '0x5555555555555555555555555555555555555555';
    const proposerIca = '0x6666666666666666666666666666666666666666';
    const destinationRouterAddress =
      '0x7777777777777777777777777777777777777777';
    const originRouterAddress = '0x8888888888888888888888888888888888888888';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => timelockOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          filter.address?.toLowerCase() === timelockOwner.toLowerCase() &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    let derivationCalls = 0;
    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']:
              async () => {
                derivationCalls += 1;
                return ethersConstants.AddressZero;
              },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any, TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(derivationCalls).to.equal(3);
      expect(provider.getLogs.callCount).to.equal(3);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('falls back to default timelock proposer when role-derived ICA proposer is malformed', async () => {
    const timelockOwner = '0x5555555555555555555555555555555555555555';
    const proposerIca = '0x6666666666666666666666666666666666666666';
    const destinationRouterAddress =
      '0x7777777777777777777777777777777777777777';
    const originRouterAddress = '0x8888888888888888888888888888888888888888';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => timelockOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          filter.address === timelockOwner &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    let derivationCalls = 0;
    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']:
              async () => {
                derivationCalls += 1;
                return 'not-an-evm-address';
              },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any, TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(derivationCalls).to.equal(3);
      expect(provider.getLogs.callCount).to.equal(3);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('infers timelock proposer ICA from signer-derived fallback when role logs are empty', async () => {
    const timelockOwner = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa';
    const derivedIcaProposer = '0xbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb';
    const destinationRouterAddress =
      '0xcccccccccccccccccccccccccccccccccccccccc';
    const originRouterAddress = '0xdddddddddddddddddddddddddddddddddddddddd';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => timelockOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().resolves([]),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async (_role: string, account: string) =>
          account.toLowerCase() === derivedIcaProposer.toLowerCase(),
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: SIGNER } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              derivedIcaProposer,
          } as any;
        }

        throw new Error('unexpected router');
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.INTERCHAIN_ACCOUNT);
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.owner,
      ).to.equal(SIGNER);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('infers timelock proposer ICA when origin signer probe throws but signer address lookup succeeds', async () => {
    const timelockOwner = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa';
    const derivedIcaProposer = '0xbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb';
    const destinationRouterAddress =
      '0xcccccccccccccccccccccccccccccccccccccccc';
    const originRouterAddress = '0xdddddddddddddddddddddddddddddddddddddddd';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => timelockOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().resolves([]),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async (_role: string, account: string) =>
          account.toLowerCase() === derivedIcaProposer.toLowerCase(),
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: SIGNER } }),
        },
      } as any);

    let originDerivationCalls = 0;
    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']:
              async () => {
                originDerivationCalls += 1;
                return derivedIcaProposer;
              },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName !== CHAIN) {
            originSignerAddressLookups += 1;
          }
          return SIGNER;
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          throw new Error(`origin signer probe failed for ${chainName}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.INTERCHAIN_ACCOUNT);
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.owner,
      ).to.equal(SIGNER);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(originDerivationCalls).to.equal(2);
      expect(provider.getLogs.callCount).to.equal(3);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('falls back to default timelock proposer when signer-derived ICA proposer is zero address', async () => {
    const timelockOwner = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa';
    const destinationRouterAddress =
      '0xcccccccccccccccccccccccccccccccccccccccc';
    const originRouterAddress = '0xdddddddddddddddddddddddddddddddddddddddd';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => timelockOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().resolves([]),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: SIGNER } }),
        },
      } as any);

    let derivationCalls = 0;
    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']:
              async () => {
                derivationCalls += 1;
                return ethersConstants.AddressZero;
              },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any, TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(derivationCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(2);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('falls back to default timelock proposer when signer-derived ICA proposer is malformed', async () => {
    const timelockOwner = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa';
    const destinationRouterAddress =
      '0xcccccccccccccccccccccccccccccccccccccccc';
    const originRouterAddress = '0xdddddddddddddddddddddddddddddddddddddddd';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => timelockOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().resolves([]),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: SIGNER } }),
        },
      } as any);

    let derivationCalls = 0;
    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']:
              async () => {
                derivationCalls += 1;
                return 'not-an-evm-address';
              },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any, TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(derivationCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(2);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('ignores unknown registry chains while deriving timelock ICA proposer fallback', async () => {
    const timelockOwner = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa';
    const derivedIcaProposer = '0xbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb';
    const destinationRouterAddress =
      '0xcccccccccccccccccccccccccccccccccccccccc';
    const originRouterAddress = '0xdddddddddddddddddddddddddddddddddddddddd';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => timelockOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().resolves([]),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async (_role: string, account: string) =>
          account.toLowerCase() === derivedIcaProposer.toLowerCase(),
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: SIGNER } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              derivedIcaProposer,
          } as any;
        }

        throw new Error('unexpected router');
      });

    const context = {
      multiProvider: {
        getProtocol: (chainName: string) => {
          if (chainName === 'unknownChain') {
            throw new Error('unknown chain metadata');
          }
          return ProtocolType.Ethereum;
        },
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          unknownChain: {
            interchainAccountRouter:
              '0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee',
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.INTERCHAIN_ACCOUNT);
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.owner,
      ).to.equal(SIGNER);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('ignores zero-address origin routers while deriving timelock ICA proposer fallback', async () => {
    const timelockOwner = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa';
    const derivedIcaProposer = '0xbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb';
    const destinationRouterAddress =
      '0xcccccccccccccccccccccccccccccccccccccccc';
    const originRouterAddress = '0xdddddddddddddddddddddddddddddddddddddddd';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => timelockOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().resolves([]),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async (_role: string, account: string) =>
          account.toLowerCase() === derivedIcaProposer.toLowerCase(),
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: SIGNER } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              derivedIcaProposer,
          } as any;
        }

        throw new Error('unexpected router');
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          zeroRouterChain: {
            interchainAccountRouter: ethersConstants.AddressZero,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.INTERCHAIN_ACCOUNT);
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.owner,
      ).to.equal(SIGNER);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('ignores invalid origin routers while deriving timelock ICA proposer fallback', async () => {
    const timelockOwner = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa';
    const derivedIcaProposer = '0xbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb';
    const destinationRouterAddress =
      '0xcccccccccccccccccccccccccccccccccccccccc';
    const originRouterAddress = '0xdddddddddddddddddddddddddddddddddddddddd';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => timelockOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().resolves([]),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async (_role: string, account: string) =>
          account.toLowerCase() === derivedIcaProposer.toLowerCase(),
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: SIGNER } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              derivedIcaProposer,
          } as any;
        }

        throw new Error('unexpected router');
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          invalidRouterChain: {
            interchainAccountRouter: 'not-an-address',
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.INTERCHAIN_ACCOUNT);
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.owner,
      ).to.equal(SIGNER);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches protocol checks while deriving timelock ICA proposer fallback', async () => {
    const timelockOwnerA = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa';
    const timelockOwnerB = '0xbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb';
    const derivedIcaProposer = '0xcccccccccccccccccccccccccccccccccccccccc';
    const destinationRouterAddress =
      '0xdddddddddddddddddddddddddddddddddddddddd';
    const originRouterAddress = '0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().resolves([]),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .callsFake(
        () =>
          ({
            getMinDelay: async () => 0,
            hasRole: async (_role: string, account: string) =>
              account.toLowerCase() === derivedIcaProposer.toLowerCase(),
            interface: {
              getEventTopic: (name: string) => name,
              parseLog: (_log: unknown) => ({ args: { account: SIGNER } }),
            },
          }) as any,
      );

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              derivedIcaProposer,
          } as any;
        }

        throw new Error('unexpected router');
      });

    const protocolCalls: Record<string, number> = {};
    let registryReads = 0;
    const context = {
      multiProvider: {
        getProtocol: (chainName: string) => {
          protocolCalls[chainName] = (protocolCalls[chainName] ?? 0) + 1;
          if (chainName === 'unknownChain') {
            throw new Error('unknown chain metadata');
          }
          return ProtocolType.Ethereum;
        },
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
      },
      registry: {
        getAddresses: async () => {
          registryReads += 1;
          return {
            [CHAIN]: {
              interchainAccountRouter: destinationRouterAddress,
            },
            unknownChain: {
              interchainAccountRouter:
                '0xffffffffffffffffffffffffffffffffffffffff',
            },
            anvil3: {
              interchainAccountRouter: originRouterAddress,
            },
          };
        },
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(protocolCalls.unknownChain).to.equal(1);
      expect(protocolCalls.anvil3).to.equal(1);
      expect(registryReads).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('falls back to jsonRpc when timelock ICA origin signer is unavailable', async () => {
    const timelockOwner = '0x1111111111111111111111111111111111111111';
    const proposerIca = '0x2222222222222222222222222222222222222222';
    const destinationRouterAddress =
      '0x3333333333333333333333333333333333333333';
    const originRouterAddress = '0x4444444444444444444444444444444444444444';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => timelockOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          filter.address === timelockOwner &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async () => SIGNER,
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => (chainName === CHAIN ? {} : null),
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('falls back to jsonRpc when timelock ICA origin signer lookup fails without tryGetSigner', async () => {
    const timelockOwner = '0x5151515151515151515151515151515151515151';
    const proposerIca = '0x5252525252525252525252525252525252525252';
    const destinationRouterAddress =
      '0x5353535353535353535353535353535353535353';
    const originRouterAddress = '0x5454545454545454545454545454545454545454';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => timelockOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          filter.address === timelockOwner &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let signerAddressCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCalls += 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error('origin signer unavailable');
        },
        getProvider: () => provider,
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any, TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(signerAddressCalls).to.equal(2);
      expect(provider.getLogs.callCount).to.equal(3);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('infers timelock proposer ICA when origin signer lookup fails but tryGetSigner signer exposes getAddress', async () => {
    const timelockOwner = '0x5151515151515151515151515151515151515151';
    const proposerIca = '0x5252525252525252525252525252525252525252';
    const destinationRouterAddress =
      '0x5353535353535353535353535353535353535353';
    const originRouterAddress = '0x5454545454545454545454545454545454545454';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => timelockOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          filter.address === timelockOwner &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerObjectAddressCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error('origin signer unavailable');
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          if (chainName === 'anvil3') {
            return {
              getAddress: async () => {
                originSignerObjectAddressCalls += 1;
                return SIGNER;
              },
            };
          }
          return null;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any, TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      const proposerSubmitter = (batches[0].config.submitter as any)
        .proposerSubmitter;
      expect(proposerSubmitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      expect(proposerSubmitter.chain).to.equal('anvil3');
      expect(proposerSubmitter.owner).to.equal(SIGNER);
      expect(proposerSubmitter.internalSubmitter.type).to.equal(
        TxSubmitterType.JSON_RPC,
      );
      expect(originSignerObjectAddressCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(3);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('infers timelock proposer ICA when signer probe returns sync signer object with getAddress fallback', async () => {
    const timelockOwner = '0x5151515151515151515151515151515151515151';
    const proposerIca = '0x5252525252525252525252525252525252525252';
    const destinationRouterAddress =
      '0x5353535353535353535353535353535353535353';
    const originRouterAddress = '0x5454545454545454545454545454545454545454';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => timelockOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          filter.address === timelockOwner &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerObjectAddressCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error('origin signer unavailable');
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          if (chainName === 'anvil3') {
            return {
              getAddress: () => {
                originSignerObjectAddressCalls += 1;
                return SIGNER;
              },
            };
          }
          return null;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any, TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      const proposerSubmitter = (batches[0].config.submitter as any)
        .proposerSubmitter;
      expect(proposerSubmitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      expect(originSignerObjectAddressCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(3);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('infers timelock proposer ICA when signer probe exposes non-function then and getAddress fallback', async () => {
    const timelockOwner = '0x6969696969696969696969696969696969696969';
    const proposerIca = '0x7070707070707070707070707070707070707070';
    const destinationRouterAddress =
      '0x5353535353535353535353535353535353535353';
    const originRouterAddress = '0x5454545454545454545454545454545454545454';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => timelockOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          filter.address?.toLowerCase() === timelockOwner.toLowerCase() &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerObjectAddressCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error('origin signer unavailable');
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          if (chainName === 'anvil3') {
            return {
              then: 1,
              getAddress: () => {
                originSignerObjectAddressCalls += 1;
                return SIGNER;
              },
            };
          }
          return null;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any, TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      const proposerSubmitter = (batches[0].config.submitter as any)
        .proposerSubmitter;
      expect(proposerSubmitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      expect(originSignerObjectAddressCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(3);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('infers timelock proposer ICA when signer probe then getter throws but signer object getAddress succeeds', async () => {
    const timelockOwner = '0x5757575757575757575757575757575757575757';
    const proposerIca = '0x5858585858585858585858585858585858585858';
    const destinationRouterAddress =
      '0x5353535353535353535353535353535353535353';
    const originRouterAddress = '0x5454545454545454545454545454545454545454';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => timelockOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          filter.address === timelockOwner &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerObjectAddressCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error('origin signer unavailable');
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          if (chainName === 'anvil3') {
            return {
              getAddress: () => {
                originSignerObjectAddressCalls += 1;
                return SIGNER;
              },
              get then() {
                throw new Error('broken then getter');
              },
            };
          }
          return null;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any, TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      const proposerSubmitter = (batches[0].config.submitter as any)
        .proposerSubmitter;
      expect(proposerSubmitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      expect(originSignerObjectAddressCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(3);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('falls back to jsonRpc timelock proposer when signer probe then getter throws and signer object getAddress is malformed', async () => {
    const timelockOwner = '0x5757575757575757575757575757575757575757';
    const proposerIca = '0x5858585858585858585858585858585858585858';
    const destinationRouterAddress =
      '0x5353535353535353535353535353535353535353';
    const originRouterAddress = '0x5454545454545454545454545454545454545454';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => timelockOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          filter.address?.toLowerCase() === timelockOwner.toLowerCase() &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerObjectAddressCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          return 'not-an-evm-address';
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          if (chainName === 'anvil3') {
            return {
              getAddress: () => {
                originSignerObjectAddressCalls += 1;
                return 'not-an-evm-address';
              },
              get then() {
                throw new Error('broken then getter');
              },
            };
          }
          return null;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any, TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      const proposerSubmitter = (batches[0].config.submitter as any)
        .proposerSubmitter;
      expect(proposerSubmitter.type).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerObjectAddressCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(3);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('infers timelock proposer ICA when direct origin signer lookup succeeds without calling signer object getAddress', async () => {
    const timelockOwner = '0x5555555555555555555555555555555555555555';
    const proposerIca = '0x5656565656565656565656565656565656565656';
    const destinationRouterAddress =
      '0x5353535353535353535353535353535353535353';
    const originRouterAddress = '0x5454545454545454545454545454545454545454';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => timelockOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          filter.address === timelockOwner &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerObjectAddressCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          return SIGNER;
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          if (chainName === 'anvil3') {
            return {
              getAddress: () => {
                originSignerObjectAddressCalls += 1;
                throw new Error('unexpected signer getAddress call');
              },
            };
          }
          return null;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any, TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      const proposerSubmitter = (batches[0].config.submitter as any)
        .proposerSubmitter;
      expect(proposerSubmitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      expect(originSignerObjectAddressCalls).to.equal(0);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(3);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('infers timelock proposer ICA when tryGetSigner getter throws by falling back to direct signer lookup', async () => {
    const timelockOwner = '0x5959595959595959595959595959595959595959';
    const proposerIca = '0x5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a';
    const destinationRouterAddress =
      '0x5353535353535353535353535353535353535353';
    const originRouterAddress = '0x5454545454545454545454545454545454545454';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => timelockOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          filter.address === timelockOwner &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          return SIGNER;
        },
        getProvider: () => provider,
        get tryGetSigner() {
          throw new Error('broken tryGetSigner getter');
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any, TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      const proposerSubmitter = (batches[0].config.submitter as any)
        .proposerSubmitter;
      expect(proposerSubmitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(3);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('infers timelock proposer ICA when tryGetSigner returns bad thenable by falling back to direct signer lookup', async () => {
    const timelockOwner = '0x6565656565656565656565656565656565656565';
    const proposerIca = '0x6666666666666666666666666666666666666666';
    const destinationRouterAddress =
      '0x5353535353535353535353535353535353535353';
    const originRouterAddress = '0x5454545454545454545454545454545454545454';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => timelockOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          filter.address?.toLowerCase() === timelockOwner.toLowerCase() &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          return SIGNER;
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === 'anvil3') {
            return {
              then: () => {
                throw new Error('bad thenable');
              },
            };
          }
          return {};
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any, TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      const proposerSubmitter = (batches[0].config.submitter as any)
        .proposerSubmitter;
      expect(proposerSubmitter.type).to.equal(
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      );
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(3);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('falls back to jsonRpc timelock proposer when tryGetSigner getter throws and origin signer lookup is malformed', async () => {
    const timelockOwner = '0x5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d';
    const proposerIca = '0x5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e';
    const destinationRouterAddress =
      '0x5353535353535353535353535353535353535353';
    const originRouterAddress = '0x5454545454545454545454545454545454545454';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => timelockOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          filter.address?.toLowerCase() === timelockOwner.toLowerCase() &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          return 'not-an-evm-address';
        },
        getProvider: () => provider,
        get tryGetSigner() {
          throw new Error('broken tryGetSigner getter');
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any, TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      const proposerSubmitter = (batches[0].config.submitter as any)
        .proposerSubmitter;
      expect(proposerSubmitter.type).to.equal(TxSubmitterType.JSON_RPC);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(3);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('falls back to jsonRpc timelock proposer when tryGetSigner getter throws and origin signer lookup throws', async () => {
    const timelockOwner = '0x6161616161616161616161616161616161616161';
    const proposerIca = '0x6262626262626262626262626262626262626262';
    const destinationRouterAddress =
      '0x5353535353535353535353535353535353535353';
    const originRouterAddress = '0x5454545454545454545454545454545454545454';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => timelockOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          filter.address?.toLowerCase() === timelockOwner.toLowerCase() &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error('origin signer lookup failed');
        },
        getProvider: () => provider,
        get tryGetSigner() {
          throw new Error('broken tryGetSigner getter');
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any, TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      const proposerSubmitter = (batches[0].config.submitter as any)
        .proposerSubmitter;
      expect(proposerSubmitter.type).to.equal(TxSubmitterType.JSON_RPC);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(3);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('falls back to jsonRpc timelock proposer when tryGetSigner returns bad thenable and origin signer lookup is malformed', async () => {
    const timelockOwner = '0x6363636363636363636363636363636363636363';
    const proposerIca = '0x6464646464646464646464646464646464646464';
    const destinationRouterAddress =
      '0x5353535353535353535353535353535353535353';
    const originRouterAddress = '0x5454545454545454545454545454545454545454';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => timelockOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          filter.address?.toLowerCase() === timelockOwner.toLowerCase() &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          return 'not-an-evm-address';
        },
        getProvider: () => provider,
        tryGetSigner: (_chainName: string) => ({
          then: () => {
            throw new Error('bad thenable');
          },
        }),
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any, TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      const proposerSubmitter = (batches[0].config.submitter as any)
        .proposerSubmitter;
      expect(proposerSubmitter.type).to.equal(TxSubmitterType.JSON_RPC);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(3);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches malformed bad-thenable signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x6969696969696969696969696969696969696969';
    const timelockOwnerB = '0x7070707070707070707070707070707070707070';
    const proposerIcaA = '0x7171717171717171717171717171717171717171';
    const proposerIcaB = '0x7272727272727272727272727272727272727272';
    const destinationRouterAddress =
      '0x5353535353535353535353535353535353535353';
    const originRouterAddress = '0x5454545454545454545454545454545454545454';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: filter.address }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .callsFake(
        (_address: string) =>
          ({
            getMinDelay: async () => 0,
            hasRole: async () => false,
            interface: {
              getEventTopic: (name: string) => name,
              parseLog: (log: any) => ({
                args: {
                  account:
                    log.data?.toLowerCase() === timelockOwnerA.toLowerCase()
                      ? proposerIcaA
                      : proposerIcaB,
                },
              }),
            },
          }) as any,
      );

    let originDerivationCalls = 0;
    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']:
              async () => {
                originDerivationCalls += 1;
                return proposerIcaA;
              },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          return 'not-an-evm-address';
        },
        getProvider: (chainName: string) => {
          if (chainName === CHAIN) {
            return provider;
          }
          throw new Error(`unexpected provider lookup for ${chainName}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return {
            then: () => {
              throw new Error(`bad thenable for ${chainName}`);
            },
          };
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(originDerivationCalls).to.equal(0);
      expect(provider.getLogs.callCount).to.equal(6);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches successful bad-thenable signer probe fallback across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x9090909090909090909090909090909090909095';
    const timelockOwnerB = '0x9090909090909090909090909090909090909096';
    const proposerIca = '0x9090909090909090909090909090909090909097';
    const destinationRouterAddress =
      '0x9090909090909090909090909090909090909098';
    const originRouterAddress = '0x9090909090909090909090909090909090909099';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: filter.address }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .callsFake(
        (address: string) =>
          ({
            getMinDelay: async () => 0,
            hasRole: async () => false,
            interface: {
              getEventTopic: (name: string) => name,
              parseLog: (_log: any) => ({
                args: {
                  account: proposerIca,
                },
              }),
            },
          }) as any,
      );

    let originDerivationCalls = 0;
    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']:
              async () => {
                originDerivationCalls += 1;
                return proposerIca;
              },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN || chainName === 'anvil3') {
            if (chainName === 'anvil3') {
              originSignerAddressLookups += 1;
            }
            return SIGNER;
          }
          throw new Error(`unknown signer lookup for ${chainName}`);
        },
        getProvider: (chainName: string) => {
          if (chainName === CHAIN || chainName === 'anvil3') {
            return provider;
          }
          throw new Error(`unexpected provider lookup for ${chainName}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return {
            then: () => {
              throw new Error(`bad thenable for ${chainName}`);
            },
          };
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.INTERCHAIN_ACCOUNT);
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.owner,
      ).to.equal(SIGNER);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.INTERCHAIN_ACCOUNT);
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.owner,
      ).to.equal(SIGNER);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(originDerivationCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches zero-address bad-thenable signer probe fallback across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x90909090909090909090909090909090909090a5';
    const timelockOwnerB = '0x90909090909090909090909090909090909090a6';
    const proposerIcaA = '0x90909090909090909090909090909090909090a7';
    const proposerIcaB = '0x90909090909090909090909090909090909090a8';
    const destinationRouterAddress =
      '0x90909090909090909090909090909090909090a9';
    const originRouterAddress = '0x90909090909090909090909090909090909090aa';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: filter.address }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .callsFake(
        (_address: string) =>
          ({
            getMinDelay: async () => 0,
            hasRole: async () => false,
            interface: {
              getEventTopic: (name: string) => name,
              parseLog: (log: any) => ({
                args: {
                  account:
                    log.data?.toLowerCase() === timelockOwnerA.toLowerCase()
                      ? proposerIcaA
                      : proposerIcaB,
                },
              }),
            },
          }) as any,
      );

    let originDerivationCalls = 0;
    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']:
              async () => {
                originDerivationCalls += 1;
                return proposerIcaA;
              },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          return ethersConstants.AddressZero;
        },
        getProvider: (chainName: string) => {
          if (chainName === CHAIN || chainName === 'anvil3') {
            return provider;
          }
          throw new Error(`unexpected provider lookup for ${chainName}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return {
            then: () => {
              throw new Error(`bad thenable for ${chainName}`);
            },
          };
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(originDerivationCalls).to.equal(0);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches throwing bad-thenable signer probe fallback across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x90909090909090909090909090909090909090b5';
    const timelockOwnerB = '0x90909090909090909090909090909090909090b6';
    const proposerIcaA = '0x90909090909090909090909090909090909090b7';
    const proposerIcaB = '0x90909090909090909090909090909090909090b8';
    const destinationRouterAddress =
      '0x90909090909090909090909090909090909090b9';
    const originRouterAddress = '0x90909090909090909090909090909090909090ba';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: filter.address }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .callsFake(
        (_address: string) =>
          ({
            getMinDelay: async () => 0,
            hasRole: async () => false,
            interface: {
              getEventTopic: (name: string) => name,
              parseLog: (log: any) => ({
                args: {
                  account:
                    log.data?.toLowerCase() === timelockOwnerA.toLowerCase()
                      ? proposerIcaA
                      : proposerIcaB,
                },
              }),
            },
          }) as any,
      );

    let originDerivationCalls = 0;
    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']:
              async () => {
                originDerivationCalls += 1;
                return proposerIcaA;
              },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`signer lookup failed for ${chainName}`);
        },
        getProvider: (chainName: string) => {
          if (chainName === CHAIN || chainName === 'anvil3') {
            return provider;
          }
          throw new Error(`unexpected provider lookup for ${chainName}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return {
            then: () => {
              throw new Error(`bad thenable for ${chainName}`);
            },
          };
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(originDerivationCalls).to.equal(0);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('falls back to jsonRpc timelock proposer when tryGetSigner returns bad thenable and origin signer lookup throws', async () => {
    const timelockOwner = '0x6767676767676767676767676767676767676767';
    const proposerIca = '0x6868686868686868686868686868686868686868';
    const destinationRouterAddress =
      '0x5353535353535353535353535353535353535353';
    const originRouterAddress = '0x5454545454545454545454545454545454545454';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => timelockOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          filter.address?.toLowerCase() === timelockOwner.toLowerCase() &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error('origin signer lookup failed');
        },
        getProvider: () => provider,
        tryGetSigner: (_chainName: string) => ({
          then: () => {
            throw new Error('bad thenable');
          },
        }),
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any, TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      const proposerSubmitter = (batches[0].config.submitter as any)
        .proposerSubmitter;
      expect(proposerSubmitter.type).to.equal(TxSubmitterType.JSON_RPC);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(3);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('falls back to jsonRpc timelock proposer when tryGetSigner is non-function and origin signer lookup is malformed', async () => {
    const timelockOwner = '0x5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f';
    const proposerIca = '0x6060606060606060606060606060606060606060';
    const destinationRouterAddress =
      '0x5353535353535353535353535353535353535353';
    const originRouterAddress = '0x5454545454545454545454545454545454545454';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => timelockOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          filter.address?.toLowerCase() === timelockOwner.toLowerCase() &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          return 'not-an-evm-address';
        },
        getProvider: () => provider,
        tryGetSigner: {},
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any, TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      const proposerSubmitter = (batches[0].config.submitter as any)
        .proposerSubmitter;
      expect(proposerSubmitter.type).to.equal(TxSubmitterType.JSON_RPC);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(3);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches malformed signer-address fallback when tryGetSigner is non-function across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xd2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2';
    const timelockOwnerB = '0xd3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3';
    const proposerIcaA = '0xd4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4';
    const proposerIcaB = '0xd5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5';
    const destinationRouterAddress =
      '0xd6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6';
    const originRouterAddress = '0xd7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: filter.address }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .callsFake(
        (_address: string) =>
          ({
            getMinDelay: async () => 0,
            hasRole: async () => false,
            interface: {
              getEventTopic: (name: string) => name,
              parseLog: (log: any) => ({
                args: {
                  account:
                    log.data?.toLowerCase() === timelockOwnerA.toLowerCase()
                      ? proposerIcaA
                      : proposerIcaB,
                },
              }),
            },
          }) as any,
      );

    let originDerivationCalls = 0;
    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']:
              async () => {
                originDerivationCalls += 1;
                return proposerIcaA;
              },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          return 'not-an-evm-address';
        },
        getProvider: (chainName: string) => {
          if (chainName === CHAIN) {
            return provider;
          }
          throw new Error(`unexpected provider lookup for ${chainName}`);
        },
        tryGetSigner: {},
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(originDerivationCalls).to.equal(0);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches zero signer-address fallback when tryGetSigner is non-function across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xe3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3';
    const timelockOwnerB = '0xe4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4';
    const proposerIcaA = '0xe5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5';
    const proposerIcaB = '0xe6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6';
    const destinationRouterAddress =
      '0xe7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7';
    const originRouterAddress = '0xe8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: filter.address }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .callsFake(
        (_address: string) =>
          ({
            getMinDelay: async () => 0,
            hasRole: async () => false,
            interface: {
              getEventTopic: (name: string) => name,
              parseLog: (log: any) => ({
                args: {
                  account:
                    log.data?.toLowerCase() === timelockOwnerA.toLowerCase()
                      ? proposerIcaA
                      : proposerIcaB,
                },
              }),
            },
          }) as any,
      );

    let originDerivationCalls = 0;
    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']:
              async () => {
                originDerivationCalls += 1;
                return proposerIcaA;
              },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          return ethersConstants.AddressZero;
        },
        getProvider: (chainName: string) => {
          if (chainName === CHAIN) {
            return provider;
          }
          throw new Error(`unexpected provider lookup for ${chainName}`);
        },
        tryGetSigner: {},
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(originDerivationCalls).to.equal(0);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches throwing signer-address fallback when tryGetSigner is non-function across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xe9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9';
    const timelockOwnerB = '0xeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaea';
    const proposerIcaA = '0xebebebebebebebebebebebebebebebebebebebeb';
    const proposerIcaB = '0xecececececececececececececececececececec';
    const destinationRouterAddress =
      '0xedededededededededededededededededededed';
    const originRouterAddress = '0xefefefefefefefefefefefefefefefefefefefef';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: filter.address }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .callsFake(
        (_address: string) =>
          ({
            getMinDelay: async () => 0,
            hasRole: async () => false,
            interface: {
              getEventTopic: (name: string) => name,
              parseLog: (log: any) => ({
                args: {
                  account:
                    log.data?.toLowerCase() === timelockOwnerA.toLowerCase()
                      ? proposerIcaA
                      : proposerIcaB,
                },
              }),
            },
          }) as any,
      );

    let originDerivationCalls = 0;
    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']:
              async () => {
                originDerivationCalls += 1;
                return proposerIcaA;
              },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error('origin signer lookup failed');
        },
        getProvider: (chainName: string) => {
          if (chainName === CHAIN) {
            return provider;
          }
          throw new Error(`unexpected provider lookup for ${chainName}`);
        },
        tryGetSigner: {},
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(originDerivationCalls).to.equal(0);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches successful signer-address fallback when tryGetSigner is non-function across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xf4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4';
    const timelockOwnerB = '0xf5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5';
    const proposerIca = '0xf6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6';
    const destinationRouterAddress =
      '0xf7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7';
    const originRouterAddress = '0xf8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: filter.address }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .callsFake(
        (address: string) =>
          ({
            getMinDelay: async () => 0,
            hasRole: async (_role: string, account: string) =>
              account.toLowerCase() === proposerIca.toLowerCase(),
            interface: {
              getEventTopic: (name: string) => name,
              parseLog: (_log: any) => ({
                args: {
                  account: proposerIca,
                },
              }),
            },
          }) as any,
      );

    let originDerivationCalls = 0;
    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']:
              async () => {
                originDerivationCalls += 1;
                return proposerIca;
              },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN || chainName === 'anvil3') {
            return SIGNER;
          }
          throw new Error(`unknown signer lookup for ${chainName}`);
        },
        getProvider: (chainName: string) => {
          if (chainName === CHAIN || chainName === 'anvil3') {
            return provider;
          }
          throw new Error(`unexpected provider lookup for ${chainName}`);
        },
        tryGetSigner: {},
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.INTERCHAIN_ACCOUNT);
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.owner,
      ).to.equal(SIGNER);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.INTERCHAIN_ACCOUNT);
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.owner,
      ).to.equal(SIGNER);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(originDerivationCalls).to.equal(3);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('infers timelock proposer ICA when signer lookup is malformed but signer object getAddress succeeds', async () => {
    const timelockOwnerA = '0x8787878787878787878787878787878787878787';
    const timelockOwnerB = '0x8888888888888888888888888888888888888888';
    const proposerIcaA = '0x8989898989898989898989898989898989898989';
    const proposerIcaB = '0x9090909090909090909090909090909090909090';
    const destinationRouterAddress =
      '0x5353535353535353535353535353535353535353';
    const originRouterAddress = '0x5454545454545454545454545454545454545454';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: filter.address }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .callsFake(
        (_address: string) =>
          ({
            getMinDelay: async () => 0,
            hasRole: async (_role: string, account: string) =>
              account.toLowerCase() === proposerIcaA.toLowerCase() ||
              account.toLowerCase() === proposerIcaB.toLowerCase(),
            interface: {
              getEventTopic: (name: string) => name,
              parseLog: (log: any) => ({
                args: {
                  account:
                    log.data?.toLowerCase() === timelockOwnerA.toLowerCase()
                      ? proposerIcaA
                      : proposerIcaB,
                },
              }),
            },
          }) as any,
      );

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async (
              owner: string,
            ) => {
              if (owner.toLowerCase() === SIGNER.toLowerCase()) {
                return proposerIcaA;
              }
              return proposerIcaB;
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerObjectAddressCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          return 'not-an-evm-address';
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          if (chainName === 'anvil3') {
            return {
              getAddress: () => {
                originSignerObjectAddressCalls += 1;
                return SIGNER;
              },
            };
          }
          return null;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      const proposerSubmitterTypes = batches.map(
        (batch) => (batch.config.submitter as any).proposerSubmitter.type,
      );
      expect(proposerSubmitterTypes).to.deep.equal([
        TxSubmitterType.INTERCHAIN_ACCOUNT,
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      ]);
      expect(originSignerObjectAddressCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(6);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('infers timelock proposer ICA when signer lookup is zero but async signer object getAddress succeeds', async () => {
    const timelockOwnerA = '0x9191919191919191919191919191919191919191';
    const timelockOwnerB = '0x9292929292929292929292929292929292929292';
    const proposerIcaA = '0x9393939393939393939393939393939393939393';
    const proposerIcaB = '0x9494949494949494949494949494949494949494';
    const destinationRouterAddress =
      '0x5353535353535353535353535353535353535353';
    const originRouterAddress = '0x5454545454545454545454545454545454545454';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: filter.address }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .callsFake(
        (_address: string) =>
          ({
            getMinDelay: async () => 0,
            hasRole: async (_role: string, account: string) =>
              account.toLowerCase() === proposerIcaA.toLowerCase() ||
              account.toLowerCase() === proposerIcaB.toLowerCase(),
            interface: {
              getEventTopic: (name: string) => name,
              parseLog: (log: any) => ({
                args: {
                  account:
                    log.data?.toLowerCase() === timelockOwnerA.toLowerCase()
                      ? proposerIcaA
                      : proposerIcaB,
                },
              }),
            },
          }) as any,
      );

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async (
              owner: string,
            ) => {
              if (owner.toLowerCase() === SIGNER.toLowerCase()) {
                return proposerIcaA;
              }
              return proposerIcaB;
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerObjectAddressCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          return ethersConstants.AddressZero;
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          if (chainName === 'anvil3') {
            return {
              getAddress: async () => {
                originSignerObjectAddressCalls += 1;
                return SIGNER;
              },
            };
          }
          return null;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      const proposerSubmitterTypes = batches.map(
        (batch) => (batch.config.submitter as any).proposerSubmitter.type,
      );
      expect(proposerSubmitterTypes).to.deep.equal([
        TxSubmitterType.INTERCHAIN_ACCOUNT,
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      ]);
      expect(originSignerObjectAddressCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(6);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('infers timelock proposer ICA when async signer probe resolves non-function-then signer object with getAddress fallback', async () => {
    const timelockOwnerA = '0x9696969696969696969696969696969696969696';
    const timelockOwnerB = '0x9797979797979797979797979797979797979797';
    const proposerIcaA = '0x9898989898989898989898989898989898989898';
    const proposerIcaB = '0x9999999999999999999999999999999999999999';
    const destinationRouterAddress =
      '0x5353535353535353535353535353535353535353';
    const originRouterAddress = '0x5454545454545454545454545454545454545454';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: filter.address }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .callsFake(
        (_address: string) =>
          ({
            getMinDelay: async () => 0,
            hasRole: async (_role: string, account: string) =>
              account.toLowerCase() === proposerIcaA.toLowerCase() ||
              account.toLowerCase() === proposerIcaB.toLowerCase(),
            interface: {
              getEventTopic: (name: string) => name,
              parseLog: (log: any) => ({
                args: {
                  account:
                    log.data?.toLowerCase() === timelockOwnerA.toLowerCase()
                      ? proposerIcaA
                      : proposerIcaB,
                },
              }),
            },
          }) as any,
      );

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async (
              owner: string,
            ) => {
              if (owner.toLowerCase() === SIGNER.toLowerCase()) {
                return proposerIcaA;
              }
              return proposerIcaB;
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerObjectAddressCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          return ethersConstants.AddressZero;
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          if (chainName === 'anvil3') {
            return {
              then: 1,
              getAddress: async () => {
                originSignerObjectAddressCalls += 1;
                return SIGNER;
              },
            };
          }
          return null;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      const proposerSubmitterTypes = batches.map(
        (batch) => (batch.config.submitter as any).proposerSubmitter.type,
      );
      expect(proposerSubmitterTypes).to.deep.equal([
        TxSubmitterType.INTERCHAIN_ACCOUNT,
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      ]);
      expect(originSignerObjectAddressCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(6);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches signer-object getAddress fallback across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x6161616161616161616161616161616161616161';
    const timelockOwnerB = '0x6262626262626262626262626262626262626262';
    const proposerIcaA = '0x6363636363636363636363636363636363636363';
    const proposerIcaB = '0x6464646464646464646464646464646464646464';
    const destinationRouterAddress =
      '0x5353535353535353535353535353535353535353';
    const originRouterAddress = '0x5454545454545454545454545454545454545454';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: filter.address }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .callsFake(
        (_address: string) =>
          ({
            getMinDelay: async () => 0,
            hasRole: async (_role: string, account: string) =>
              account.toLowerCase() === proposerIcaA.toLowerCase() ||
              account.toLowerCase() === proposerIcaB.toLowerCase(),
            interface: {
              getEventTopic: (name: string) => name,
              parseLog: (log: any) => ({
                args: {
                  account:
                    log.data?.toLowerCase() === timelockOwnerA.toLowerCase()
                      ? proposerIcaA
                      : proposerIcaB,
                },
              }),
            },
          }) as any,
      );

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async (
              owner: string,
            ) => {
              if (owner.toLowerCase() === SIGNER.toLowerCase()) {
                return proposerIcaA;
              }
              return proposerIcaB;
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerObjectAddressCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error('origin signer unavailable');
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          if (chainName === 'anvil3') {
            return {
              getAddress: async () => {
                originSignerObjectAddressCalls += 1;
                return SIGNER;
              },
            };
          }
          return null;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      const proposerSubmitterTypes = batches.map(
        (batch) => (batch.config.submitter as any).proposerSubmitter.type,
      );
      expect(proposerSubmitterTypes).to.deep.equal([
        TxSubmitterType.INTERCHAIN_ACCOUNT,
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      ]);
      expect(originSignerObjectAddressCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(6);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches non-function-then signer-object getAddress fallback across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x7272727272727272727272727272727272727272';
    const timelockOwnerB = '0x7373737373737373737373737373737373737373';
    const proposerIcaA = '0x7474747474747474747474747474747474747474';
    const proposerIcaB = '0x7575757575757575757575757575757575757575';
    const destinationRouterAddress =
      '0x5353535353535353535353535353535353535353';
    const originRouterAddress = '0x5454545454545454545454545454545454545454';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: filter.address }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .callsFake(
        (_address: string) =>
          ({
            getMinDelay: async () => 0,
            hasRole: async (_role: string, account: string) =>
              account.toLowerCase() === proposerIcaA.toLowerCase() ||
              account.toLowerCase() === proposerIcaB.toLowerCase(),
            interface: {
              getEventTopic: (name: string) => name,
              parseLog: (log: any) => ({
                args: {
                  account:
                    log.data?.toLowerCase() === timelockOwnerA.toLowerCase()
                      ? proposerIcaA
                      : proposerIcaB,
                },
              }),
            },
          }) as any,
      );

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async (
              owner: string,
            ) => {
              if (owner.toLowerCase() === SIGNER.toLowerCase()) {
                return proposerIcaA;
              }
              return proposerIcaB;
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerObjectAddressCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error('origin signer unavailable');
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          if (chainName === 'anvil3') {
            return {
              then: 1,
              getAddress: async () => {
                originSignerObjectAddressCalls += 1;
                return SIGNER;
              },
            };
          }
          return null;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      const proposerSubmitterTypes = batches.map(
        (batch) => (batch.config.submitter as any).proposerSubmitter.type,
      );
      expect(proposerSubmitterTypes).to.deep.equal([
        TxSubmitterType.INTERCHAIN_ACCOUNT,
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      ]);
      expect(originSignerObjectAddressCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(6);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async non-function-then signer-object getAddress fallback across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xa2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2';
    const timelockOwnerB = '0xa3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3';
    const proposerIcaA = '0xa4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4';
    const proposerIcaB = '0xa5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5';
    const destinationRouterAddress =
      '0x5353535353535353535353535353535353535353';
    const originRouterAddress = '0x5454545454545454545454545454545454545454';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: filter.address }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .callsFake(
        (_address: string) =>
          ({
            getMinDelay: async () => 0,
            hasRole: async (_role: string, account: string) =>
              account.toLowerCase() === proposerIcaA.toLowerCase() ||
              account.toLowerCase() === proposerIcaB.toLowerCase(),
            interface: {
              getEventTopic: (name: string) => name,
              parseLog: (log: any) => ({
                args: {
                  account:
                    log.data?.toLowerCase() === timelockOwnerA.toLowerCase()
                      ? proposerIcaA
                      : proposerIcaB,
                },
              }),
            },
          }) as any,
      );

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async (
              owner: string,
            ) => {
              if (owner.toLowerCase() === SIGNER.toLowerCase()) {
                return proposerIcaA;
              }
              return proposerIcaB;
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerObjectAddressCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error('origin signer unavailable');
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          if (chainName === 'anvil3') {
            return {
              then: 1,
              getAddress: async () => {
                originSignerObjectAddressCalls += 1;
                return SIGNER;
              },
            };
          }
          return null;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      const proposerSubmitterTypes = batches.map(
        (batch) => (batch.config.submitter as any).proposerSubmitter.type,
      );
      expect(proposerSubmitterTypes).to.deep.equal([
        TxSubmitterType.INTERCHAIN_ACCOUNT,
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      ]);
      expect(originSignerObjectAddressCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async signer-object getAddress fallback across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x6565656565656565656565656565656565656565';
    const timelockOwnerB = '0x6666666666666666666666666666666666666666';
    const proposerIcaA = '0x6767676767676767676767676767676767676767';
    const proposerIcaB = '0x6868686868686868686868686868686868686868';
    const destinationRouterAddress =
      '0x5353535353535353535353535353535353535353';
    const originRouterAddress = '0x5454545454545454545454545454545454545454';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: filter.address }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .callsFake(
        (_address: string) =>
          ({
            getMinDelay: async () => 0,
            hasRole: async (_role: string, account: string) =>
              account.toLowerCase() === proposerIcaA.toLowerCase() ||
              account.toLowerCase() === proposerIcaB.toLowerCase(),
            interface: {
              getEventTopic: (name: string) => name,
              parseLog: (log: any) => ({
                args: {
                  account:
                    log.data?.toLowerCase() === timelockOwnerA.toLowerCase()
                      ? proposerIcaA
                      : proposerIcaB,
                },
              }),
            },
          }) as any,
      );

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async (
              owner: string,
            ) => {
              if (owner.toLowerCase() === SIGNER.toLowerCase()) {
                return proposerIcaA;
              }
              return proposerIcaB;
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerObjectAddressCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error('origin signer unavailable');
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          if (chainName === 'anvil3') {
            return {
              getAddress: async () => {
                originSignerObjectAddressCalls += 1;
                return SIGNER;
              },
            };
          }
          return null;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      const proposerSubmitterTypes = batches.map(
        (batch) => (batch.config.submitter as any).proposerSubmitter.type,
      );
      expect(proposerSubmitterTypes).to.deep.equal([
        TxSubmitterType.INTERCHAIN_ACCOUNT,
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      ]);
      expect(originSignerObjectAddressCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(6);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches signer-object getAddress fallback when origin signer lookup is malformed across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xdadadadadadadadadadadadadadadadadadadada';
    const timelockOwnerB = '0xdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdb';
    const proposerIcaA = '0xdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdc';
    const proposerIcaB = '0xdddddddddddddddddddddddddddddddddddddddd';
    const destinationRouterAddress =
      '0x5353535353535353535353535353535353535353';
    const originRouterAddress = '0x5454545454545454545454545454545454545454';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: filter.address }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .callsFake(
        (_address: string) =>
          ({
            getMinDelay: async () => 0,
            hasRole: async (_role: string, account: string) =>
              account.toLowerCase() === proposerIcaA.toLowerCase() ||
              account.toLowerCase() === proposerIcaB.toLowerCase(),
            interface: {
              getEventTopic: (name: string) => name,
              parseLog: (log: any) => ({
                args: {
                  account:
                    log.data?.toLowerCase() === timelockOwnerA.toLowerCase()
                      ? proposerIcaA
                      : proposerIcaB,
                },
              }),
            },
          }) as any,
      );

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async (
              owner: string,
            ) => {
              if (owner.toLowerCase() === SIGNER.toLowerCase()) {
                return proposerIcaA;
              }
              return proposerIcaB;
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerObjectAddressCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          return 'not-an-evm-address';
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          if (chainName === 'anvil3') {
            return {
              getAddress: async () => {
                originSignerObjectAddressCalls += 1;
                return SIGNER;
              },
            };
          }
          return null;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      const proposerSubmitterTypes = batches.map(
        (batch) => (batch.config.submitter as any).proposerSubmitter.type,
      );
      expect(proposerSubmitterTypes).to.deep.equal([
        TxSubmitterType.INTERCHAIN_ACCOUNT,
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      ]);
      expect(originSignerObjectAddressCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async signer-object getAddress fallback when origin signer lookup is malformed across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xdededededededededededededededededededede';
    const timelockOwnerB = '0xdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdf';
    const proposerIcaA = '0xe0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0';
    const proposerIcaB = '0xe1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1';
    const destinationRouterAddress =
      '0x5353535353535353535353535353535353535353';
    const originRouterAddress = '0x5454545454545454545454545454545454545454';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: filter.address }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .callsFake(
        (_address: string) =>
          ({
            getMinDelay: async () => 0,
            hasRole: async (_role: string, account: string) =>
              account.toLowerCase() === proposerIcaA.toLowerCase() ||
              account.toLowerCase() === proposerIcaB.toLowerCase(),
            interface: {
              getEventTopic: (name: string) => name,
              parseLog: (log: any) => ({
                args: {
                  account:
                    log.data?.toLowerCase() === timelockOwnerA.toLowerCase()
                      ? proposerIcaA
                      : proposerIcaB,
                },
              }),
            },
          }) as any,
      );

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async (
              owner: string,
            ) => {
              if (owner.toLowerCase() === SIGNER.toLowerCase()) {
                return proposerIcaA;
              }
              return proposerIcaB;
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerObjectAddressCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          return 'not-an-evm-address';
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          if (chainName === 'anvil3') {
            return {
              getAddress: async () => {
                originSignerObjectAddressCalls += 1;
                return SIGNER;
              },
            };
          }
          return null;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      const proposerSubmitterTypes = batches.map(
        (batch) => (batch.config.submitter as any).proposerSubmitter.type,
      );
      expect(proposerSubmitterTypes).to.deep.equal([
        TxSubmitterType.INTERCHAIN_ACCOUNT,
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      ]);
      expect(originSignerObjectAddressCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches non-function-then signer-object getAddress fallback when origin signer lookup is malformed across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xe2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2';
    const timelockOwnerB = '0xe3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3';
    const proposerIcaA = '0xe4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4';
    const proposerIcaB = '0xe5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5';
    const destinationRouterAddress =
      '0x5353535353535353535353535353535353535353';
    const originRouterAddress = '0x5454545454545454545454545454545454545454';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: filter.address }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .callsFake(
        (_address: string) =>
          ({
            getMinDelay: async () => 0,
            hasRole: async (_role: string, account: string) =>
              account.toLowerCase() === proposerIcaA.toLowerCase() ||
              account.toLowerCase() === proposerIcaB.toLowerCase(),
            interface: {
              getEventTopic: (name: string) => name,
              parseLog: (log: any) => ({
                args: {
                  account:
                    log.data?.toLowerCase() === timelockOwnerA.toLowerCase()
                      ? proposerIcaA
                      : proposerIcaB,
                },
              }),
            },
          }) as any,
      );

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async (
              owner: string,
            ) => {
              if (owner.toLowerCase() === SIGNER.toLowerCase()) {
                return proposerIcaA;
              }
              return proposerIcaB;
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerObjectAddressCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          return 'not-an-evm-address';
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          if (chainName === 'anvil3') {
            return {
              then: 1,
              getAddress: async () => {
                originSignerObjectAddressCalls += 1;
                return SIGNER;
              },
            };
          }
          return null;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      const proposerSubmitterTypes = batches.map(
        (batch) => (batch.config.submitter as any).proposerSubmitter.type,
      );
      expect(proposerSubmitterTypes).to.deep.equal([
        TxSubmitterType.INTERCHAIN_ACCOUNT,
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      ]);
      expect(originSignerObjectAddressCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async non-function-then signer-object getAddress fallback when origin signer lookup is malformed across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xe6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6';
    const timelockOwnerB = '0xe7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7';
    const proposerIcaA = '0xe8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8';
    const proposerIcaB = '0xe9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9';
    const destinationRouterAddress =
      '0x5353535353535353535353535353535353535353';
    const originRouterAddress = '0x5454545454545454545454545454545454545454';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: filter.address }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .callsFake(
        (_address: string) =>
          ({
            getMinDelay: async () => 0,
            hasRole: async (_role: string, account: string) =>
              account.toLowerCase() === proposerIcaA.toLowerCase() ||
              account.toLowerCase() === proposerIcaB.toLowerCase(),
            interface: {
              getEventTopic: (name: string) => name,
              parseLog: (log: any) => ({
                args: {
                  account:
                    log.data?.toLowerCase() === timelockOwnerA.toLowerCase()
                      ? proposerIcaA
                      : proposerIcaB,
                },
              }),
            },
          }) as any,
      );

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async (
              owner: string,
            ) => {
              if (owner.toLowerCase() === SIGNER.toLowerCase()) {
                return proposerIcaA;
              }
              return proposerIcaB;
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerObjectAddressCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          return 'not-an-evm-address';
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          if (chainName === 'anvil3') {
            return {
              then: 1,
              getAddress: async () => {
                originSignerObjectAddressCalls += 1;
                return SIGNER;
              },
            };
          }
          return null;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      const proposerSubmitterTypes = batches.map(
        (batch) => (batch.config.submitter as any).proposerSubmitter.type,
      );
      expect(proposerSubmitterTypes).to.deep.equal([
        TxSubmitterType.INTERCHAIN_ACCOUNT,
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      ]);
      expect(originSignerObjectAddressCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches signer-object getAddress getter throw fallback when origin signer lookup is malformed across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaea';
    const timelockOwnerB = '0xebebebebebebebebebebebebebebebebebebebeb';
    const proposerIcaA = '0xecececececececececececececececececececec';
    const proposerIcaB = '0xedededededededededededededededededededed';
    const destinationRouterAddress =
      '0x5353535353535353535353535353535353535353';
    const originRouterAddress = '0x5454545454545454545454545454545454545454';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: filter.address }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .callsFake(
        (_address: string) =>
          ({
            getMinDelay: async () => 0,
            hasRole: async () => false,
            interface: {
              getEventTopic: (name: string) => name,
              parseLog: (log: any) => ({
                args: {
                  account:
                    log.data?.toLowerCase() === timelockOwnerA.toLowerCase()
                      ? proposerIcaA
                      : proposerIcaB,
                },
              }),
            },
          }) as any,
      );

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async (
              owner: string,
            ) => {
              if (owner.toLowerCase() === SIGNER.toLowerCase()) {
                return proposerIcaA;
              }
              return proposerIcaB;
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerGetAddressGetterCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          return 'not-an-evm-address';
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          if (chainName === 'anvil3') {
            return {
              get getAddress() {
                originSignerGetAddressGetterCalls += 1;
                throw new Error('signer object getAddress getter failed');
              },
            };
          }
          return null;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      const proposerSubmitterTypes = batches.map(
        (batch) => (batch.config.submitter as any).proposerSubmitter.type,
      );
      expect(proposerSubmitterTypes).to.deep.equal([
        TxSubmitterType.JSON_RPC,
        TxSubmitterType.JSON_RPC,
      ]);
      expect(originSignerGetAddressGetterCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches non-function-then signer-object getAddress getter throw fallback when origin signer lookup is malformed across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee';
    const timelockOwnerB = '0xefefefefefefefefefefefefefefefefefefefef';
    const proposerIcaA = '0xf0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0';
    const proposerIcaB = '0xf1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1';
    const destinationRouterAddress =
      '0x5353535353535353535353535353535353535353';
    const originRouterAddress = '0x5454545454545454545454545454545454545454';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: filter.address }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .callsFake(
        (_address: string) =>
          ({
            getMinDelay: async () => 0,
            hasRole: async () => false,
            interface: {
              getEventTopic: (name: string) => name,
              parseLog: (log: any) => ({
                args: {
                  account:
                    log.data?.toLowerCase() === timelockOwnerA.toLowerCase()
                      ? proposerIcaA
                      : proposerIcaB,
                },
              }),
            },
          }) as any,
      );

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async (
              owner: string,
            ) => {
              if (owner.toLowerCase() === SIGNER.toLowerCase()) {
                return proposerIcaA;
              }
              return proposerIcaB;
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerGetAddressGetterCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          return 'not-an-evm-address';
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          if (chainName === 'anvil3') {
            return {
              then: 1,
              get getAddress() {
                originSignerGetAddressGetterCalls += 1;
                throw new Error('signer object getAddress getter failed');
              },
            };
          }
          return null;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      const proposerSubmitterTypes = batches.map(
        (batch) => (batch.config.submitter as any).proposerSubmitter.type,
      );
      expect(proposerSubmitterTypes).to.deep.equal([
        TxSubmitterType.JSON_RPC,
        TxSubmitterType.JSON_RPC,
      ]);
      expect(originSignerGetAddressGetterCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async signer-object getAddress getter throw fallback when origin signer lookup is malformed across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xf2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2';
    const timelockOwnerB = '0xf3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3';
    const proposerIcaA = '0xf4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4';
    const proposerIcaB = '0xf5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5';
    const destinationRouterAddress =
      '0x5353535353535353535353535353535353535353';
    const originRouterAddress = '0x5454545454545454545454545454545454545454';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: filter.address }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .callsFake(
        (_address: string) =>
          ({
            getMinDelay: async () => 0,
            hasRole: async () => false,
            interface: {
              getEventTopic: (name: string) => name,
              parseLog: (log: any) => ({
                args: {
                  account:
                    log.data?.toLowerCase() === timelockOwnerA.toLowerCase()
                      ? proposerIcaA
                      : proposerIcaB,
                },
              }),
            },
          }) as any,
      );

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async (
              owner: string,
            ) => {
              if (owner.toLowerCase() === SIGNER.toLowerCase()) {
                return proposerIcaA;
              }
              return proposerIcaB;
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerGetAddressGetterCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          return 'not-an-evm-address';
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          if (chainName === 'anvil3') {
            return {
              get getAddress() {
                originSignerGetAddressGetterCalls += 1;
                throw new Error('signer object getAddress getter failed');
              },
            };
          }
          return null;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      const proposerSubmitterTypes = batches.map(
        (batch) => (batch.config.submitter as any).proposerSubmitter.type,
      );
      expect(proposerSubmitterTypes).to.deep.equal([
        TxSubmitterType.JSON_RPC,
        TxSubmitterType.JSON_RPC,
      ]);
      expect(originSignerGetAddressGetterCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async non-function-then signer-object getAddress getter throw fallback when origin signer lookup is malformed across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xf6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6';
    const timelockOwnerB = '0xf7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7';
    const proposerIcaA = '0xf8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8';
    const proposerIcaB = '0xf9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9';
    const destinationRouterAddress =
      '0x5353535353535353535353535353535353535353';
    const originRouterAddress = '0x5454545454545454545454545454545454545454';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: filter.address }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .callsFake(
        (_address: string) =>
          ({
            getMinDelay: async () => 0,
            hasRole: async () => false,
            interface: {
              getEventTopic: (name: string) => name,
              parseLog: (log: any) => ({
                args: {
                  account:
                    log.data?.toLowerCase() === timelockOwnerA.toLowerCase()
                      ? proposerIcaA
                      : proposerIcaB,
                },
              }),
            },
          }) as any,
      );

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async (
              owner: string,
            ) => {
              if (owner.toLowerCase() === SIGNER.toLowerCase()) {
                return proposerIcaA;
              }
              return proposerIcaB;
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerGetAddressGetterCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          return 'not-an-evm-address';
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          if (chainName === 'anvil3') {
            return {
              then: 1,
              get getAddress() {
                originSignerGetAddressGetterCalls += 1;
                throw new Error('signer object getAddress getter failed');
              },
            };
          }
          return null;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      const proposerSubmitterTypes = batches.map(
        (batch) => (batch.config.submitter as any).proposerSubmitter.type,
      );
      expect(proposerSubmitterTypes).to.deep.equal([
        TxSubmitterType.JSON_RPC,
        TxSubmitterType.JSON_RPC,
      ]);
      expect(originSignerGetAddressGetterCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches signer-object without getAddress fallback across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b';
    const timelockOwnerB = '0x6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c';
    const proposerIcaA = '0x6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d';
    const proposerIcaB = '0x6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e';
    const destinationRouterAddress =
      '0x5353535353535353535353535353535353535353';
    const originRouterAddress = '0x5454545454545454545454545454545454545454';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: filter.address }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .callsFake(
        (_address: string) =>
          ({
            getMinDelay: async () => 0,
            hasRole: async () => false,
            interface: {
              getEventTopic: (name: string) => name,
              parseLog: (log: any) => ({
                args: {
                  account:
                    log.data?.toLowerCase() === timelockOwnerA.toLowerCase()
                      ? proposerIcaA
                      : proposerIcaB,
                },
              }),
            },
          }) as any,
      );

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async (
              owner: string,
            ) => {
              if (owner.toLowerCase() === SIGNER.toLowerCase()) {
                return proposerIcaA;
              }
              return proposerIcaB;
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerProbeCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error('origin signer unavailable');
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          if (chainName === 'anvil3') {
            originSignerProbeCalls += 1;
            return {};
          }
          return null;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      const proposerSubmitterTypes = batches.map(
        (batch) => (batch.config.submitter as any).proposerSubmitter.type,
      );
      expect(proposerSubmitterTypes).to.deep.equal([
        TxSubmitterType.JSON_RPC,
        TxSubmitterType.JSON_RPC,
      ]);
      expect(originSignerProbeCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async signer-object without getAddress fallback across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f';
    const timelockOwnerB = '0x7070707070707070707070707070707070707070';
    const proposerIcaA = '0x7171717171717171717171717171717171717171';
    const proposerIcaB = '0x7272727272727272727272727272727272727272';
    const destinationRouterAddress =
      '0x5353535353535353535353535353535353535353';
    const originRouterAddress = '0x5454545454545454545454545454545454545454';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: filter.address }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .callsFake(
        (_address: string) =>
          ({
            getMinDelay: async () => 0,
            hasRole: async () => false,
            interface: {
              getEventTopic: (name: string) => name,
              parseLog: (log: any) => ({
                args: {
                  account:
                    log.data?.toLowerCase() === timelockOwnerA.toLowerCase()
                      ? proposerIcaA
                      : proposerIcaB,
                },
              }),
            },
          }) as any,
      );

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async (
              owner: string,
            ) => {
              if (owner.toLowerCase() === SIGNER.toLowerCase()) {
                return proposerIcaA;
              }
              return proposerIcaB;
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerProbeCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error('origin signer unavailable');
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          if (chainName === 'anvil3') {
            originSignerProbeCalls += 1;
            return {};
          }
          return null;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      const proposerSubmitterTypes = batches.map(
        (batch) => (batch.config.submitter as any).proposerSubmitter.type,
      );
      expect(proposerSubmitterTypes).to.deep.equal([
        TxSubmitterType.JSON_RPC,
        TxSubmitterType.JSON_RPC,
      ]);
      expect(originSignerProbeCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches non-function-then signer-object without getAddress fallback across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x7373737373737373737373737373737373737373';
    const timelockOwnerB = '0x7474747474747474747474747474747474747474';
    const proposerIcaA = '0x7575757575757575757575757575757575757575';
    const proposerIcaB = '0x7676767676767676767676767676767676767676';
    const destinationRouterAddress =
      '0x5353535353535353535353535353535353535353';
    const originRouterAddress = '0x5454545454545454545454545454545454545454';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: filter.address }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .callsFake(
        (_address: string) =>
          ({
            getMinDelay: async () => 0,
            hasRole: async () => false,
            interface: {
              getEventTopic: (name: string) => name,
              parseLog: (log: any) => ({
                args: {
                  account:
                    log.data?.toLowerCase() === timelockOwnerA.toLowerCase()
                      ? proposerIcaA
                      : proposerIcaB,
                },
              }),
            },
          }) as any,
      );

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async (
              owner: string,
            ) => {
              if (owner.toLowerCase() === SIGNER.toLowerCase()) {
                return proposerIcaA;
              }
              return proposerIcaB;
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerProbeCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error('origin signer unavailable');
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          if (chainName === 'anvil3') {
            originSignerProbeCalls += 1;
            return { then: 1 };
          }
          return null;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      const proposerSubmitterTypes = batches.map(
        (batch) => (batch.config.submitter as any).proposerSubmitter.type,
      );
      expect(proposerSubmitterTypes).to.deep.equal([
        TxSubmitterType.JSON_RPC,
        TxSubmitterType.JSON_RPC,
      ]);
      expect(originSignerProbeCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(6);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async non-function-then signer-object without getAddress fallback across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x7777777777777777777777777777777777777777';
    const timelockOwnerB = '0x7878787878787878787878787878787878787878';
    const proposerIcaA = '0x7979797979797979797979797979797979797979';
    const proposerIcaB = '0x8080808080808080808080808080808080808080';
    const destinationRouterAddress =
      '0x5353535353535353535353535353535353535353';
    const originRouterAddress = '0x5454545454545454545454545454545454545454';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: filter.address }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .callsFake(
        (_address: string) =>
          ({
            getMinDelay: async () => 0,
            hasRole: async () => false,
            interface: {
              getEventTopic: (name: string) => name,
              parseLog: (log: any) => ({
                args: {
                  account:
                    log.data?.toLowerCase() === timelockOwnerA.toLowerCase()
                      ? proposerIcaA
                      : proposerIcaB,
                },
              }),
            },
          }) as any,
      );

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async (
              owner: string,
            ) => {
              if (owner.toLowerCase() === SIGNER.toLowerCase()) {
                return proposerIcaA;
              }
              return proposerIcaB;
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerProbeCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error('origin signer unavailable');
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          if (chainName === 'anvil3') {
            originSignerProbeCalls += 1;
            return { then: 1 };
          }
          return null;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      const proposerSubmitterTypes = batches.map(
        (batch) => (batch.config.submitter as any).proposerSubmitter.type,
      );
      expect(proposerSubmitterTypes).to.deep.equal([
        TxSubmitterType.JSON_RPC,
        TxSubmitterType.JSON_RPC,
      ]);
      expect(originSignerProbeCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(6);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches signer-object without getAddress fallback when origin signer lookup is malformed across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x8181818181818181818181818181818181818181';
    const timelockOwnerB = '0x8282828282828282828282828282828282828282';
    const proposerIcaA = '0x8383838383838383838383838383838383838383';
    const proposerIcaB = '0x8484848484848484848484848484848484848484';
    const destinationRouterAddress =
      '0x5353535353535353535353535353535353535353';
    const originRouterAddress = '0x5454545454545454545454545454545454545454';
    const malformedOriginSignerAddress = 'invalid-origin-signer';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: filter.address }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .callsFake(
        (_address: string) =>
          ({
            getMinDelay: async () => 0,
            hasRole: async () => false,
            interface: {
              getEventTopic: (name: string) => name,
              parseLog: (log: any) => ({
                args: {
                  account:
                    log.data?.toLowerCase() === timelockOwnerA.toLowerCase()
                      ? proposerIcaA
                      : proposerIcaB,
                },
              }),
            },
          }) as any,
      );

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async (
              owner: string,
            ) => {
              if (owner.toLowerCase() === SIGNER.toLowerCase()) {
                return proposerIcaA;
              }
              return proposerIcaB;
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerProbeCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          return malformedOriginSignerAddress;
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          if (chainName === 'anvil3') {
            originSignerProbeCalls += 1;
            return {};
          }
          return null;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      const proposerSubmitterTypes = batches.map(
        (batch) => (batch.config.submitter as any).proposerSubmitter.type,
      );
      expect(proposerSubmitterTypes).to.deep.equal([
        TxSubmitterType.JSON_RPC,
        TxSubmitterType.JSON_RPC,
      ]);
      expect(originSignerProbeCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(6);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async signer-object without getAddress fallback when origin signer lookup is malformed across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x8585858585858585858585858585858585858585';
    const timelockOwnerB = '0x8686868686868686868686868686868686868686';
    const proposerIcaA = '0x8787878787878787878787878787878787878787';
    const proposerIcaB = '0x8888888888888888888888888888888888888888';
    const destinationRouterAddress =
      '0x5353535353535353535353535353535353535353';
    const originRouterAddress = '0x5454545454545454545454545454545454545454';
    const malformedOriginSignerAddress = 'invalid-origin-signer';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: filter.address }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .callsFake(
        (_address: string) =>
          ({
            getMinDelay: async () => 0,
            hasRole: async () => false,
            interface: {
              getEventTopic: (name: string) => name,
              parseLog: (log: any) => ({
                args: {
                  account:
                    log.data?.toLowerCase() === timelockOwnerA.toLowerCase()
                      ? proposerIcaA
                      : proposerIcaB,
                },
              }),
            },
          }) as any,
      );

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async (
              owner: string,
            ) => {
              if (owner.toLowerCase() === SIGNER.toLowerCase()) {
                return proposerIcaA;
              }
              return proposerIcaB;
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerProbeCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          return malformedOriginSignerAddress;
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          if (chainName === 'anvil3') {
            originSignerProbeCalls += 1;
            return {};
          }
          return null;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      const proposerSubmitterTypes = batches.map(
        (batch) => (batch.config.submitter as any).proposerSubmitter.type,
      );
      expect(proposerSubmitterTypes).to.deep.equal([
        TxSubmitterType.JSON_RPC,
        TxSubmitterType.JSON_RPC,
      ]);
      expect(originSignerProbeCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(6);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches non-function-then signer-object without getAddress fallback when origin signer lookup is malformed across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x8989898989898989898989898989898989898989';
    const timelockOwnerB = '0x9090909090909090909090909090909090909090';
    const proposerIcaA = '0x9191919191919191919191919191919191919191';
    const proposerIcaB = '0x9292929292929292929292929292929292929292';
    const destinationRouterAddress =
      '0x5353535353535353535353535353535353535353';
    const originRouterAddress = '0x5454545454545454545454545454545454545454';
    const malformedOriginSignerAddress = 'invalid-origin-signer';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: filter.address }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .callsFake(
        (_address: string) =>
          ({
            getMinDelay: async () => 0,
            hasRole: async () => false,
            interface: {
              getEventTopic: (name: string) => name,
              parseLog: (log: any) => ({
                args: {
                  account:
                    log.data?.toLowerCase() === timelockOwnerA.toLowerCase()
                      ? proposerIcaA
                      : proposerIcaB,
                },
              }),
            },
          }) as any,
      );

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async (
              owner: string,
            ) => {
              if (owner.toLowerCase() === SIGNER.toLowerCase()) {
                return proposerIcaA;
              }
              return proposerIcaB;
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerProbeCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          return malformedOriginSignerAddress;
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          if (chainName === 'anvil3') {
            originSignerProbeCalls += 1;
            return { then: 1 };
          }
          return null;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      const proposerSubmitterTypes = batches.map(
        (batch) => (batch.config.submitter as any).proposerSubmitter.type,
      );
      expect(proposerSubmitterTypes).to.deep.equal([
        TxSubmitterType.JSON_RPC,
        TxSubmitterType.JSON_RPC,
      ]);
      expect(originSignerProbeCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(6);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async non-function-then signer-object without getAddress fallback when origin signer lookup is malformed across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x9393939393939393939393939393939393939393';
    const timelockOwnerB = '0x9494949494949494949494949494949494949494';
    const proposerIcaA = '0x9595959595959595959595959595959595959595';
    const proposerIcaB = '0x9696969696969696969696969696969696969696';
    const destinationRouterAddress =
      '0x5353535353535353535353535353535353535353';
    const originRouterAddress = '0x5454545454545454545454545454545454545454';
    const malformedOriginSignerAddress = 'invalid-origin-signer';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: filter.address }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .callsFake(
        (_address: string) =>
          ({
            getMinDelay: async () => 0,
            hasRole: async () => false,
            interface: {
              getEventTopic: (name: string) => name,
              parseLog: (log: any) => ({
                args: {
                  account:
                    log.data?.toLowerCase() === timelockOwnerA.toLowerCase()
                      ? proposerIcaA
                      : proposerIcaB,
                },
              }),
            },
          }) as any,
      );

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async (
              owner: string,
            ) => {
              if (owner.toLowerCase() === SIGNER.toLowerCase()) {
                return proposerIcaA;
              }
              return proposerIcaB;
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerProbeCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          return malformedOriginSignerAddress;
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          if (chainName === 'anvil3') {
            originSignerProbeCalls += 1;
            return { then: 1 };
          }
          return null;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      const proposerSubmitterTypes = batches.map(
        (batch) => (batch.config.submitter as any).proposerSubmitter.type,
      );
      expect(proposerSubmitterTypes).to.deep.equal([
        TxSubmitterType.JSON_RPC,
        TxSubmitterType.JSON_RPC,
      ]);
      expect(originSignerProbeCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(6);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches primitive signer probe fallback when origin signer lookup is malformed across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x9797979797979797979797979797979797979797';
    const timelockOwnerB = '0x9898989898989898989898989898989898989898';
    const proposerIcaA = '0x9999999999999999999999999999999999999999';
    const proposerIcaB = '0xa0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0';
    const destinationRouterAddress =
      '0x5353535353535353535353535353535353535353';
    const originRouterAddress = '0x5454545454545454545454545454545454545454';
    const malformedOriginSignerAddress = 'invalid-origin-signer';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: filter.address }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .callsFake(
        (_address: string) =>
          ({
            getMinDelay: async () => 0,
            hasRole: async () => false,
            interface: {
              getEventTopic: (name: string) => name,
              parseLog: (log: any) => ({
                args: {
                  account:
                    log.data?.toLowerCase() === timelockOwnerA.toLowerCase()
                      ? proposerIcaA
                      : proposerIcaB,
                },
              }),
            },
          }) as any,
      );

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async (
              owner: string,
            ) => {
              if (owner.toLowerCase() === SIGNER.toLowerCase()) {
                return proposerIcaA;
              }
              return proposerIcaB;
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerProbeCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          return malformedOriginSignerAddress;
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          if (chainName === 'anvil3') {
            originSignerProbeCalls += 1;
            return 1;
          }
          return null;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      const proposerSubmitterTypes = batches.map(
        (batch) => (batch.config.submitter as any).proposerSubmitter.type,
      );
      expect(proposerSubmitterTypes).to.deep.equal([
        TxSubmitterType.JSON_RPC,
        TxSubmitterType.JSON_RPC,
      ]);
      expect(originSignerProbeCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(6);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async primitive signer probe fallback when origin signer lookup is malformed across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xa1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1';
    const timelockOwnerB = '0xa2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2';
    const proposerIcaA = '0xa3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3';
    const proposerIcaB = '0xa4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4';
    const destinationRouterAddress =
      '0x5353535353535353535353535353535353535353';
    const originRouterAddress = '0x5454545454545454545454545454545454545454';
    const malformedOriginSignerAddress = 'invalid-origin-signer';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: filter.address }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .callsFake(
        (_address: string) =>
          ({
            getMinDelay: async () => 0,
            hasRole: async () => false,
            interface: {
              getEventTopic: (name: string) => name,
              parseLog: (log: any) => ({
                args: {
                  account:
                    log.data?.toLowerCase() === timelockOwnerA.toLowerCase()
                      ? proposerIcaA
                      : proposerIcaB,
                },
              }),
            },
          }) as any,
      );

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async (
              owner: string,
            ) => {
              if (owner.toLowerCase() === SIGNER.toLowerCase()) {
                return proposerIcaA;
              }
              return proposerIcaB;
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerProbeCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          return malformedOriginSignerAddress;
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          if (chainName === 'anvil3') {
            originSignerProbeCalls += 1;
            return 1;
          }
          return null;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      const proposerSubmitterTypes = batches.map(
        (batch) => (batch.config.submitter as any).proposerSubmitter.type,
      );
      expect(proposerSubmitterTypes).to.deep.equal([
        TxSubmitterType.JSON_RPC,
        TxSubmitterType.JSON_RPC,
      ]);
      expect(originSignerProbeCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches primitive signer probe fallback when origin signer lookup fails across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xa5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5';
    const timelockOwnerB = '0xa6a6a6a6a6a6a6a6a6a6a6a6a6a6a6a6a6a6a6a6';
    const proposerIcaA = '0xa7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a7';
    const proposerIcaB = '0xa8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8';
    const destinationRouterAddress =
      '0x5353535353535353535353535353535353535353';
    const originRouterAddress = '0x5454545454545454545454545454545454545454';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: filter.address }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .callsFake(
        (_address: string) =>
          ({
            getMinDelay: async () => 0,
            hasRole: async () => false,
            interface: {
              getEventTopic: (name: string) => name,
              parseLog: (log: any) => ({
                args: {
                  account:
                    log.data?.toLowerCase() === timelockOwnerA.toLowerCase()
                      ? proposerIcaA
                      : proposerIcaB,
                },
              }),
            },
          }) as any,
      );

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async (
              owner: string,
            ) => {
              if (owner.toLowerCase() === SIGNER.toLowerCase()) {
                return proposerIcaA;
              }
              return proposerIcaB;
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerProbeCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error('origin signer unavailable');
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          if (chainName === 'anvil3') {
            originSignerProbeCalls += 1;
            return 1;
          }
          return null;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      const proposerSubmitterTypes = batches.map(
        (batch) => (batch.config.submitter as any).proposerSubmitter.type,
      );
      expect(proposerSubmitterTypes).to.deep.equal([
        TxSubmitterType.JSON_RPC,
        TxSubmitterType.JSON_RPC,
      ]);
      expect(originSignerProbeCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async primitive signer probe fallback when origin signer lookup fails across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xa9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9';
    const timelockOwnerB = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa';
    const proposerIcaA = '0xabababababababababababababababababababab';
    const proposerIcaB = '0xacacacacacacacacacacacacacacacacacacacac';
    const destinationRouterAddress =
      '0x5353535353535353535353535353535353535353';
    const originRouterAddress = '0x5454545454545454545454545454545454545454';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: filter.address }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .callsFake(
        (_address: string) =>
          ({
            getMinDelay: async () => 0,
            hasRole: async () => false,
            interface: {
              getEventTopic: (name: string) => name,
              parseLog: (log: any) => ({
                args: {
                  account:
                    log.data?.toLowerCase() === timelockOwnerA.toLowerCase()
                      ? proposerIcaA
                      : proposerIcaB,
                },
              }),
            },
          }) as any,
      );

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async (
              owner: string,
            ) => {
              if (owner.toLowerCase() === SIGNER.toLowerCase()) {
                return proposerIcaA;
              }
              return proposerIcaB;
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerProbeCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error('origin signer unavailable');
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          if (chainName === 'anvil3') {
            originSignerProbeCalls += 1;
            return 1;
          }
          return null;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      const proposerSubmitterTypes = batches.map(
        (batch) => (batch.config.submitter as any).proposerSubmitter.type,
      );
      expect(proposerSubmitterTypes).to.deep.equal([
        TxSubmitterType.JSON_RPC,
        TxSubmitterType.JSON_RPC,
      ]);
      expect(originSignerProbeCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches primitive signer probe zero-address fallback across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xb5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5';
    const timelockOwnerB = '0xb6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6';
    const proposerIcaA = '0xb7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7';
    const proposerIcaB = '0xb8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8';
    const destinationRouterAddress =
      '0x5353535353535353535353535353535353535353';
    const originRouterAddress = '0x5454545454545454545454545454545454545454';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: filter.address }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .callsFake(
        (_address: string) =>
          ({
            getMinDelay: async () => 0,
            hasRole: async () => false,
            interface: {
              getEventTopic: (name: string) => name,
              parseLog: (log: any) => ({
                args: {
                  account:
                    log.data?.toLowerCase() === timelockOwnerA.toLowerCase()
                      ? proposerIcaA
                      : proposerIcaB,
                },
              }),
            },
          }) as any,
      );

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async (
              owner: string,
            ) => {
              if (owner.toLowerCase() === SIGNER.toLowerCase()) {
                return proposerIcaA;
              }
              return proposerIcaB;
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerProbeCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          return ethersConstants.AddressZero;
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          if (chainName === 'anvil3') {
            originSignerProbeCalls += 1;
            return 1;
          }
          return null;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      const proposerSubmitterTypes = batches.map(
        (batch) => (batch.config.submitter as any).proposerSubmitter.type,
      );
      expect(proposerSubmitterTypes).to.deep.equal([
        TxSubmitterType.JSON_RPC,
        TxSubmitterType.JSON_RPC,
      ]);
      expect(originSignerProbeCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async primitive signer probe zero-address fallback across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xb9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9';
    const timelockOwnerB = '0xbabababababababababababababababababababa';
    const proposerIcaA = '0xbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb';
    const proposerIcaB = '0xbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbc';
    const destinationRouterAddress =
      '0x5353535353535353535353535353535353535353';
    const originRouterAddress = '0x5454545454545454545454545454545454545454';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: filter.address }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .callsFake(
        (_address: string) =>
          ({
            getMinDelay: async () => 0,
            hasRole: async () => false,
            interface: {
              getEventTopic: (name: string) => name,
              parseLog: (log: any) => ({
                args: {
                  account:
                    log.data?.toLowerCase() === timelockOwnerA.toLowerCase()
                      ? proposerIcaA
                      : proposerIcaB,
                },
              }),
            },
          }) as any,
      );

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async (
              owner: string,
            ) => {
              if (owner.toLowerCase() === SIGNER.toLowerCase()) {
                return proposerIcaA;
              }
              return proposerIcaB;
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerProbeCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          return ethersConstants.AddressZero;
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          if (chainName === 'anvil3') {
            originSignerProbeCalls += 1;
            return 1;
          }
          return null;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      const proposerSubmitterTypes = batches.map(
        (batch) => (batch.config.submitter as any).proposerSubmitter.type,
      );
      expect(proposerSubmitterTypes).to.deep.equal([
        TxSubmitterType.JSON_RPC,
        TxSubmitterType.JSON_RPC,
      ]);
      expect(originSignerProbeCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches primitive signer-address short-circuit across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xadadadadadadadadadadadadadadadadadadadad';
    const timelockOwnerB = '0xaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeae';
    const proposerIcaA = '0xafafafafafafafafafafafafafafafafafafafaf';
    const proposerIcaB = '0xb0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0';
    const destinationRouterAddress =
      '0x5353535353535353535353535353535353535353';
    const originRouterAddress = '0x5454545454545454545454545454545454545454';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: filter.address }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .callsFake(
        (_address: string) =>
          ({
            getMinDelay: async () => 0,
            hasRole: async () => false,
            interface: {
              getEventTopic: (name: string) => name,
              parseLog: (log: any) => ({
                args: {
                  account:
                    log.data?.toLowerCase() === timelockOwnerA.toLowerCase()
                      ? proposerIcaA
                      : proposerIcaB,
                },
              }),
            },
          }) as any,
      );

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async (
              owner: string,
            ) => {
              if (owner.toLowerCase() === SIGNER.toLowerCase()) {
                return proposerIcaA;
              }
              return proposerIcaB;
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerProbeCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN || chainName === 'anvil3') {
            return SIGNER;
          }
          throw new Error(`unknown signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          if (chainName === 'anvil3') {
            originSignerProbeCalls += 1;
            return 1;
          }
          return null;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      const proposerSubmitterTypes = batches.map(
        (batch) => (batch.config.submitter as any).proposerSubmitter.type,
      );
      expect(proposerSubmitterTypes).to.deep.equal([
        TxSubmitterType.JSON_RPC,
        TxSubmitterType.JSON_RPC,
      ]);
      expect(originSignerProbeCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async primitive signer-address short-circuit across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xb1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1';
    const timelockOwnerB = '0xb2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2';
    const proposerIcaA = '0xb3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3';
    const proposerIcaB = '0xb4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4';
    const destinationRouterAddress =
      '0x5353535353535353535353535353535353535353';
    const originRouterAddress = '0x5454545454545454545454545454545454545454';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: filter.address }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .callsFake(
        (_address: string) =>
          ({
            getMinDelay: async () => 0,
            hasRole: async () => false,
            interface: {
              getEventTopic: (name: string) => name,
              parseLog: (log: any) => ({
                args: {
                  account:
                    log.data?.toLowerCase() === timelockOwnerA.toLowerCase()
                      ? proposerIcaA
                      : proposerIcaB,
                },
              }),
            },
          }) as any,
      );

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async (
              owner: string,
            ) => {
              if (owner.toLowerCase() === SIGNER.toLowerCase()) {
                return proposerIcaA;
              }
              return proposerIcaB;
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerProbeCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN || chainName === 'anvil3') {
            return SIGNER;
          }
          throw new Error(`unknown signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          if (chainName === 'anvil3') {
            originSignerProbeCalls += 1;
            return 1;
          }
          return null;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      const proposerSubmitterTypes = batches.map(
        (batch) => (batch.config.submitter as any).proposerSubmitter.type,
      );
      expect(proposerSubmitterTypes).to.deep.equal([
        TxSubmitterType.JSON_RPC,
        TxSubmitterType.JSON_RPC,
      ]);
      expect(originSignerProbeCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('normalizes whitespace-padded uppercase signer-object getAddress fallback for timelock ICA inference', async () => {
    const timelockOwnerA = '0x6969696969696969696969696969696969696969';
    const timelockOwnerB = '0x7070707070707070707070707070707070707070';
    const proposerIcaA = '0x7171717171717171717171717171717171717171';
    const proposerIcaB = '0x7272727272727272727272727272727272727272';
    const destinationRouterAddress =
      '0x5353535353535353535353535353535353535353';
    const originRouterAddress = '0x5454545454545454545454545454545454545454';
    const signerObjectAddress = `  0X${SIGNER.slice(2).toUpperCase()}  `;

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: filter.address }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .callsFake(
        (_address: string) =>
          ({
            getMinDelay: async () => 0,
            hasRole: async (_role: string, account: string) =>
              account.toLowerCase() === proposerIcaA.toLowerCase() ||
              account.toLowerCase() === proposerIcaB.toLowerCase(),
            interface: {
              getEventTopic: (name: string) => name,
              parseLog: (log: any) => ({
                args: {
                  account:
                    log.data?.toLowerCase() === timelockOwnerA.toLowerCase()
                      ? proposerIcaA
                      : proposerIcaB,
                },
              }),
            },
          }) as any,
      );

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async (
              owner: string,
            ) => {
              if (owner.toLowerCase() === SIGNER.toLowerCase()) {
                return proposerIcaA;
              }
              return proposerIcaB;
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerObjectAddressCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error('origin signer unavailable');
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          if (chainName === 'anvil3') {
            return {
              getAddress: async () => {
                originSignerObjectAddressCalls += 1;
                return signerObjectAddress;
              },
            };
          }
          return null;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      const proposerSubmitterTypes = batches.map(
        (batch) => (batch.config.submitter as any).proposerSubmitter.type,
      );
      expect(proposerSubmitterTypes).to.deep.equal([
        TxSubmitterType.INTERCHAIN_ACCOUNT,
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      ]);
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.owner,
      ).to.equal(SIGNER);
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.owner,
      ).to.equal(SIGNER);
      expect(originSignerObjectAddressCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(6);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('normalizes whitespace-padded uppercase non-function-then signer-object getAddress fallback for timelock ICA inference', async () => {
    const timelockOwnerA = '0x7676767676767676767676767676767676767676';
    const timelockOwnerB = '0x7777777777777777777777777777777777777777';
    const proposerIcaA = '0x7878787878787878787878787878787878787878';
    const proposerIcaB = '0x7979797979797979797979797979797979797979';
    const destinationRouterAddress =
      '0x5353535353535353535353535353535353535353';
    const originRouterAddress = '0x5454545454545454545454545454545454545454';
    const signerObjectAddress = `  0X${SIGNER.slice(2).toUpperCase()}  `;

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: filter.address }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .callsFake(
        (_address: string) =>
          ({
            getMinDelay: async () => 0,
            hasRole: async (_role: string, account: string) =>
              account.toLowerCase() === proposerIcaA.toLowerCase() ||
              account.toLowerCase() === proposerIcaB.toLowerCase(),
            interface: {
              getEventTopic: (name: string) => name,
              parseLog: (log: any) => ({
                args: {
                  account:
                    log.data?.toLowerCase() === timelockOwnerA.toLowerCase()
                      ? proposerIcaA
                      : proposerIcaB,
                },
              }),
            },
          }) as any,
      );

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async (
              owner: string,
            ) => {
              if (owner.toLowerCase() === SIGNER.toLowerCase()) {
                return proposerIcaA;
              }
              return proposerIcaB;
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerObjectAddressCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error('origin signer unavailable');
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          if (chainName === 'anvil3') {
            return {
              then: 1,
              getAddress: async () => {
                originSignerObjectAddressCalls += 1;
                return signerObjectAddress;
              },
            };
          }
          return null;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      const proposerSubmitterTypes = batches.map(
        (batch) => (batch.config.submitter as any).proposerSubmitter.type,
      );
      expect(proposerSubmitterTypes).to.deep.equal([
        TxSubmitterType.INTERCHAIN_ACCOUNT,
        TxSubmitterType.INTERCHAIN_ACCOUNT,
      ]);
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.owner,
      ).to.equal(SIGNER);
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.owner,
      ).to.equal(SIGNER);
      expect(originSignerObjectAddressCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(6);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('falls back to jsonRpc when timelock signer object getAddress is malformed', async () => {
    const timelockOwner = '0x5151515151515151515151515151515151515151';
    const proposerIca = '0x5252525252525252525252525252525252525252';
    const destinationRouterAddress =
      '0x5353535353535353535353535353535353535353';
    const originRouterAddress = '0x5454545454545454545454545454545454545454';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => timelockOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          filter.address === timelockOwner &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerObjectAddressCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error('origin signer unavailable');
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          if (chainName === 'anvil3') {
            return {
              getAddress: async () => {
                originSignerObjectAddressCalls += 1;
                return 'not-an-evm-address';
              },
            };
          }
          return null;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any, TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerObjectAddressCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(3);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('falls back to jsonRpc when async non-function-then timelock signer object getAddress is malformed', async () => {
    const timelockOwner = '0x5151515151515151515151515151515151515151';
    const proposerIca = '0x5252525252525252525252525252525252525252';
    const destinationRouterAddress =
      '0x5353535353535353535353535353535353535353';
    const originRouterAddress = '0x5454545454545454545454545454545454545454';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => timelockOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          filter.address === timelockOwner &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerObjectAddressCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error('origin signer unavailable');
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          if (chainName === 'anvil3') {
            return {
              then: 1,
              getAddress: async () => {
                originSignerObjectAddressCalls += 1;
                return 'not-an-evm-address';
              },
            };
          }
          return null;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any, TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerObjectAddressCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(3);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('falls back to jsonRpc when async non-function-then timelock signer object getAddress throws', async () => {
    const timelockOwner = '0x5151515151515151515151515151515151515151';
    const proposerIca = '0x5252525252525252525252525252525252525252';
    const destinationRouterAddress =
      '0x5353535353535353535353535353535353535353';
    const originRouterAddress = '0x5454545454545454545454545454545454545454';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => timelockOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          filter.address === timelockOwner &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerObjectAddressCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error('origin signer unavailable');
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          if (chainName === 'anvil3') {
            return {
              then: 1,
              getAddress: async () => {
                originSignerObjectAddressCalls += 1;
                throw new Error('signer object address failed');
              },
            };
          }
          return null;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any, TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerObjectAddressCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(3);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('falls back to jsonRpc when non-function-then timelock signer object getAddress throws', async () => {
    const timelockOwner = '0x5151515151515151515151515151515151515151';
    const proposerIca = '0x5252525252525252525252525252525252525252';
    const destinationRouterAddress =
      '0x5353535353535353535353535353535353535353';
    const originRouterAddress = '0x5454545454545454545454545454545454545454';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => timelockOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          filter.address === timelockOwner &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerObjectAddressCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error('origin signer unavailable');
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          if (chainName === 'anvil3') {
            return {
              then: 1,
              getAddress: () => {
                originSignerObjectAddressCalls += 1;
                throw new Error('signer object address failed');
              },
            };
          }
          return null;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any, TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerObjectAddressCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(3);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('falls back to jsonRpc when async non-function-then timelock signer object getAddress getter throws', async () => {
    const timelockOwner = '0x5151515151515151515151515151515151515151';
    const proposerIca = '0x5252525252525252525252525252525252525252';
    const destinationRouterAddress =
      '0x5353535353535353535353535353535353535353';
    const originRouterAddress = '0x5454545454545454545454545454545454545454';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => timelockOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          filter.address === timelockOwner &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerGetAddressGetterCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error('origin signer unavailable');
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          if (chainName === 'anvil3') {
            return {
              then: 1,
              get getAddress() {
                originSignerGetAddressGetterCalls += 1;
                throw new Error('signer object getAddress getter failed');
              },
            };
          }
          return null;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any, TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerGetAddressGetterCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(3);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('falls back to jsonRpc when non-function-then timelock signer object getAddress getter throws', async () => {
    const timelockOwner = '0x5151515151515151515151515151515151515151';
    const proposerIca = '0x5252525252525252525252525252525252525252';
    const destinationRouterAddress =
      '0x5353535353535353535353535353535353535353';
    const originRouterAddress = '0x5454545454545454545454545454545454545454';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => timelockOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          filter.address === timelockOwner &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerGetAddressGetterCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error('origin signer unavailable');
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          if (chainName === 'anvil3') {
            return {
              then: 1,
              get getAddress() {
                originSignerGetAddressGetterCalls += 1;
                throw new Error('signer object getAddress getter failed');
              },
            };
          }
          return null;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any, TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerGetAddressGetterCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(3);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('falls back to jsonRpc when timelock signer object has no getAddress', async () => {
    const timelockOwner = '0x5151515151515151515151515151515151515151';
    const proposerIca = '0x5252525252525252525252525252525252525252';
    const destinationRouterAddress =
      '0x5353535353535353535353535353535353535353';
    const originRouterAddress = '0x5454545454545454545454545454545454545454';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => timelockOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          filter.address === timelockOwner &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerProbeCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error('origin signer unavailable');
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          if (chainName === 'anvil3') {
            originSignerProbeCalls += 1;
            return {};
          }
          return null;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any, TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(3);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('falls back to jsonRpc when async timelock signer object has no getAddress', async () => {
    const timelockOwnerA = '0x8787878787878787878787878787878787878787';
    const timelockOwnerB = '0x8888888888888888888888888888888888888888';
    const proposerIcaA = '0x8989898989898989898989898989898989898989';
    const proposerIcaB = '0x9090909090909090909090909090909090909090';
    const destinationRouterAddress =
      '0x5353535353535353535353535353535353535353';
    const originRouterAddress = '0x5454545454545454545454545454545454545454';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: filter.address }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .callsFake(
        (_address: string) =>
          ({
            getMinDelay: async () => 0,
            hasRole: async (_role: string, account: string) =>
              account.toLowerCase() === proposerIcaA.toLowerCase() ||
              account.toLowerCase() === proposerIcaB.toLowerCase(),
            interface: {
              getEventTopic: (name: string) => name,
              parseLog: (log: any) => ({
                args: {
                  account:
                    log.data?.toLowerCase() === timelockOwnerA.toLowerCase()
                      ? proposerIcaA
                      : proposerIcaB,
                },
              }),
            },
          }) as any,
      );

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async (
              owner: string,
            ) => {
              if (owner.toLowerCase() === SIGNER.toLowerCase()) {
                return proposerIcaA;
              }
              return proposerIcaB;
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerProbeCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error('origin signer unavailable');
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          if (chainName === 'anvil3') {
            originSignerProbeCalls += 1;
            return {};
          }
          return null;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      const proposerSubmitterTypes = batches.map(
        (batch) => (batch.config.submitter as any).proposerSubmitter.type,
      );
      expect(proposerSubmitterTypes).to.deep.equal([
        TxSubmitterType.JSON_RPC,
        TxSubmitterType.JSON_RPC,
      ]);
      expect(originSignerProbeCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(6);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches malformed signer-object getAddress fallback across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x7979797979797979797979797979797979797979';
    const timelockOwnerB = '0x8080808080808080808080808080808080808080';
    const proposerIcaA = '0x8181818181818181818181818181818181818181';
    const proposerIcaB = '0x8282828282828282828282828282828282828282';
    const destinationRouterAddress =
      '0x5353535353535353535353535353535353535353';
    const originRouterAddress = '0x5454545454545454545454545454545454545454';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: filter.address }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .callsFake(
        (_address: string) =>
          ({
            getMinDelay: async () => 0,
            hasRole: async () => false,
            interface: {
              getEventTopic: (name: string) => name,
              parseLog: (log: any) => ({
                args: {
                  account:
                    log.data?.toLowerCase() === timelockOwnerA.toLowerCase()
                      ? proposerIcaA
                      : proposerIcaB,
                },
              }),
            },
          }) as any,
      );

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async (
              owner: string,
            ) => {
              if (owner.toLowerCase() === SIGNER.toLowerCase()) {
                return proposerIcaA;
              }
              return proposerIcaB;
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerObjectAddressCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error('origin signer unavailable');
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          if (chainName === 'anvil3') {
            return {
              getAddress: async () => {
                originSignerObjectAddressCalls += 1;
                return 'not-an-evm-address';
              },
            };
          }
          return null;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      const proposerSubmitterTypes = batches.map(
        (batch) => (batch.config.submitter as any).proposerSubmitter.type,
      );
      expect(proposerSubmitterTypes).to.deep.equal([
        TxSubmitterType.JSON_RPC,
        TxSubmitterType.JSON_RPC,
      ]);
      expect(originSignerObjectAddressCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(6);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async malformed signer-object getAddress fallback across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x8383838383838383838383838383838383838383';
    const timelockOwnerB = '0x8484848484848484848484848484848484848484';
    const proposerIcaA = '0x8585858585858585858585858585858585858585';
    const proposerIcaB = '0x8686868686868686868686868686868686868686';
    const destinationRouterAddress =
      '0x5353535353535353535353535353535353535353';
    const originRouterAddress = '0x5454545454545454545454545454545454545454';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: filter.address }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .callsFake(
        (_address: string) =>
          ({
            getMinDelay: async () => 0,
            hasRole: async () => false,
            interface: {
              getEventTopic: (name: string) => name,
              parseLog: (log: any) => ({
                args: {
                  account:
                    log.data?.toLowerCase() === timelockOwnerA.toLowerCase()
                      ? proposerIcaA
                      : proposerIcaB,
                },
              }),
            },
          }) as any,
      );

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async (
              owner: string,
            ) => {
              if (owner.toLowerCase() === SIGNER.toLowerCase()) {
                return proposerIcaA;
              }
              return proposerIcaB;
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerObjectAddressCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error('origin signer unavailable');
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          if (chainName === 'anvil3') {
            return {
              getAddress: async () => {
                originSignerObjectAddressCalls += 1;
                return 'not-an-evm-address';
              },
            };
          }
          return null;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      const proposerSubmitterTypes = batches.map(
        (batch) => (batch.config.submitter as any).proposerSubmitter.type,
      );
      expect(proposerSubmitterTypes).to.deep.equal([
        TxSubmitterType.JSON_RPC,
        TxSubmitterType.JSON_RPC,
      ]);
      expect(originSignerObjectAddressCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(6);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches malformed non-function-then signer-object getAddress fallback across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xd3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3';
    const timelockOwnerB = '0xd4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4';
    const proposerIcaA = '0xd5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5';
    const proposerIcaB = '0xd6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6';
    const destinationRouterAddress =
      '0x5353535353535353535353535353535353535353';
    const originRouterAddress = '0x5454545454545454545454545454545454545454';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: filter.address }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .callsFake(
        (_address: string) =>
          ({
            getMinDelay: async () => 0,
            hasRole: async () => false,
            interface: {
              getEventTopic: (name: string) => name,
              parseLog: (log: any) => ({
                args: {
                  account:
                    log.data?.toLowerCase() === timelockOwnerA.toLowerCase()
                      ? proposerIcaA
                      : proposerIcaB,
                },
              }),
            },
          }) as any,
      );

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async (
              owner: string,
            ) => {
              if (owner.toLowerCase() === SIGNER.toLowerCase()) {
                return proposerIcaA;
              }
              return proposerIcaB;
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerObjectAddressCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error('origin signer unavailable');
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          if (chainName === 'anvil3') {
            return {
              then: 1,
              getAddress: async () => {
                originSignerObjectAddressCalls += 1;
                return 'not-an-evm-address';
              },
            };
          }
          return null;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      const proposerSubmitterTypes = batches.map(
        (batch) => (batch.config.submitter as any).proposerSubmitter.type,
      );
      expect(proposerSubmitterTypes).to.deep.equal([
        TxSubmitterType.JSON_RPC,
        TxSubmitterType.JSON_RPC,
      ]);
      expect(originSignerObjectAddressCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async malformed non-function-then signer-object getAddress fallback across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdb';
    const timelockOwnerB = '0xdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdc';
    const proposerIcaA = '0xdddddddddddddddddddddddddddddddddddddddd';
    const proposerIcaB = '0xdededededededededededededededededededede';
    const destinationRouterAddress =
      '0x5353535353535353535353535353535353535353';
    const originRouterAddress = '0x5454545454545454545454545454545454545454';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: filter.address }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .callsFake(
        (_address: string) =>
          ({
            getMinDelay: async () => 0,
            hasRole: async () => false,
            interface: {
              getEventTopic: (name: string) => name,
              parseLog: (log: any) => ({
                args: {
                  account:
                    log.data?.toLowerCase() === timelockOwnerA.toLowerCase()
                      ? proposerIcaA
                      : proposerIcaB,
                },
              }),
            },
          }) as any,
      );

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async (
              owner: string,
            ) => {
              if (owner.toLowerCase() === SIGNER.toLowerCase()) {
                return proposerIcaA;
              }
              return proposerIcaB;
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerObjectAddressCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error('origin signer unavailable');
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          if (chainName === 'anvil3') {
            return {
              then: 1,
              getAddress: async () => {
                originSignerObjectAddressCalls += 1;
                return 'not-an-evm-address';
              },
            };
          }
          return null;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      const proposerSubmitterTypes = batches.map(
        (batch) => (batch.config.submitter as any).proposerSubmitter.type,
      );
      expect(proposerSubmitterTypes).to.deep.equal([
        TxSubmitterType.JSON_RPC,
        TxSubmitterType.JSON_RPC,
      ]);
      expect(originSignerObjectAddressCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches zero non-function-then signer-object getAddress fallback across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xd7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7';
    const timelockOwnerB = '0xd8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8';
    const proposerIcaA = '0xd9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9';
    const proposerIcaB = '0xdadadadadadadadadadadadadadadadadadadada';
    const destinationRouterAddress =
      '0x5353535353535353535353535353535353535353';
    const originRouterAddress = '0x5454545454545454545454545454545454545454';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: filter.address }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .callsFake(
        (_address: string) =>
          ({
            getMinDelay: async () => 0,
            hasRole: async () => false,
            interface: {
              getEventTopic: (name: string) => name,
              parseLog: (log: any) => ({
                args: {
                  account:
                    log.data?.toLowerCase() === timelockOwnerA.toLowerCase()
                      ? proposerIcaA
                      : proposerIcaB,
                },
              }),
            },
          }) as any,
      );

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async (
              owner: string,
            ) => {
              if (owner.toLowerCase() === SIGNER.toLowerCase()) {
                return proposerIcaA;
              }
              return proposerIcaB;
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerObjectAddressCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error('origin signer unavailable');
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          if (chainName === 'anvil3') {
            return {
              then: 1,
              getAddress: async () => {
                originSignerObjectAddressCalls += 1;
                return ethersConstants.AddressZero;
              },
            };
          }
          return null;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      const proposerSubmitterTypes = batches.map(
        (batch) => (batch.config.submitter as any).proposerSubmitter.type,
      );
      expect(proposerSubmitterTypes).to.deep.equal([
        TxSubmitterType.JSON_RPC,
        TxSubmitterType.JSON_RPC,
      ]);
      expect(originSignerObjectAddressCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async zero non-function-then signer-object getAddress fallback across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdf';
    const timelockOwnerB = '0xe0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0';
    const proposerIcaA = '0xe1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1';
    const proposerIcaB = '0xe2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2';
    const destinationRouterAddress =
      '0x5353535353535353535353535353535353535353';
    const originRouterAddress = '0x5454545454545454545454545454545454545454';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: filter.address }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .callsFake(
        (_address: string) =>
          ({
            getMinDelay: async () => 0,
            hasRole: async () => false,
            interface: {
              getEventTopic: (name: string) => name,
              parseLog: (log: any) => ({
                args: {
                  account:
                    log.data?.toLowerCase() === timelockOwnerA.toLowerCase()
                      ? proposerIcaA
                      : proposerIcaB,
                },
              }),
            },
          }) as any,
      );

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async (
              owner: string,
            ) => {
              if (owner.toLowerCase() === SIGNER.toLowerCase()) {
                return proposerIcaA;
              }
              return proposerIcaB;
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerObjectAddressCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error('origin signer unavailable');
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          if (chainName === 'anvil3') {
            return {
              then: 1,
              getAddress: async () => {
                originSignerObjectAddressCalls += 1;
                return ethersConstants.AddressZero;
              },
            };
          }
          return null;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      const proposerSubmitterTypes = batches.map(
        (batch) => (batch.config.submitter as any).proposerSubmitter.type,
      );
      expect(proposerSubmitterTypes).to.deep.equal([
        TxSubmitterType.JSON_RPC,
        TxSubmitterType.JSON_RPC,
      ]);
      expect(originSignerObjectAddressCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches zero signer-object getAddress fallback across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcb';
    const timelockOwnerB = '0xcccccccccccccccccccccccccccccccccccccccc';
    const proposerIcaA = '0xcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcd';
    const proposerIcaB = '0xcececececececececececececececececececece';
    const destinationRouterAddress =
      '0x5353535353535353535353535353535353535353';
    const originRouterAddress = '0x5454545454545454545454545454545454545454';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: filter.address }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .callsFake(
        (_address: string) =>
          ({
            getMinDelay: async () => 0,
            hasRole: async () => false,
            interface: {
              getEventTopic: (name: string) => name,
              parseLog: (log: any) => ({
                args: {
                  account:
                    log.data?.toLowerCase() === timelockOwnerA.toLowerCase()
                      ? proposerIcaA
                      : proposerIcaB,
                },
              }),
            },
          }) as any,
      );

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async (
              owner: string,
            ) => {
              if (owner.toLowerCase() === SIGNER.toLowerCase()) {
                return proposerIcaA;
              }
              return proposerIcaB;
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerObjectAddressCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error('origin signer unavailable');
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          if (chainName === 'anvil3') {
            return {
              getAddress: async () => {
                originSignerObjectAddressCalls += 1;
                return ethersConstants.AddressZero;
              },
            };
          }
          return null;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      const proposerSubmitterTypes = batches.map(
        (batch) => (batch.config.submitter as any).proposerSubmitter.type,
      );
      expect(proposerSubmitterTypes).to.deep.equal([
        TxSubmitterType.JSON_RPC,
        TxSubmitterType.JSON_RPC,
      ]);
      expect(originSignerObjectAddressCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async zero signer-object getAddress fallback across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcf';
    const timelockOwnerB = '0xd0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0';
    const proposerIcaA = '0xd1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1';
    const proposerIcaB = '0xd2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2';
    const destinationRouterAddress =
      '0x5353535353535353535353535353535353535353';
    const originRouterAddress = '0x5454545454545454545454545454545454545454';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: filter.address }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .callsFake(
        (_address: string) =>
          ({
            getMinDelay: async () => 0,
            hasRole: async () => false,
            interface: {
              getEventTopic: (name: string) => name,
              parseLog: (log: any) => ({
                args: {
                  account:
                    log.data?.toLowerCase() === timelockOwnerA.toLowerCase()
                      ? proposerIcaA
                      : proposerIcaB,
                },
              }),
            },
          }) as any,
      );

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async (
              owner: string,
            ) => {
              if (owner.toLowerCase() === SIGNER.toLowerCase()) {
                return proposerIcaA;
              }
              return proposerIcaB;
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerObjectAddressCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error('origin signer unavailable');
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          if (chainName === 'anvil3') {
            return {
              getAddress: async () => {
                originSignerObjectAddressCalls += 1;
                return ethersConstants.AddressZero;
              },
            };
          }
          return null;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      const proposerSubmitterTypes = batches.map(
        (batch) => (batch.config.submitter as any).proposerSubmitter.type,
      );
      expect(proposerSubmitterTypes).to.deep.equal([
        TxSubmitterType.JSON_RPC,
        TxSubmitterType.JSON_RPC,
      ]);
      expect(originSignerObjectAddressCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches non-function-then signer-object getAddress throw fallback across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x8787878787878787878787878787878787878787';
    const timelockOwnerB = '0x8888888888888888888888888888888888888888';
    const proposerIcaA = '0x8989898989898989898989898989898989898989';
    const proposerIcaB = '0x9090909090909090909090909090909090909090';
    const destinationRouterAddress =
      '0x5353535353535353535353535353535353535353';
    const originRouterAddress = '0x5454545454545454545454545454545454545454';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: filter.address }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .callsFake(
        (_address: string) =>
          ({
            getMinDelay: async () => 0,
            hasRole: async () => false,
            interface: {
              getEventTopic: (name: string) => name,
              parseLog: (log: any) => ({
                args: {
                  account:
                    log.data?.toLowerCase() === timelockOwnerA.toLowerCase()
                      ? proposerIcaA
                      : proposerIcaB,
                },
              }),
            },
          }) as any,
      );

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async (
              owner: string,
            ) => {
              if (owner.toLowerCase() === SIGNER.toLowerCase()) {
                return proposerIcaA;
              }
              return proposerIcaB;
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerObjectAddressCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error('origin signer unavailable');
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          if (chainName === 'anvil3') {
            return {
              then: 1,
              getAddress: () => {
                originSignerObjectAddressCalls += 1;
                throw new Error('signer object address failed');
              },
            };
          }
          return null;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      const proposerSubmitterTypes = batches.map(
        (batch) => (batch.config.submitter as any).proposerSubmitter.type,
      );
      expect(proposerSubmitterTypes).to.deep.equal([
        TxSubmitterType.JSON_RPC,
        TxSubmitterType.JSON_RPC,
      ]);
      expect(originSignerObjectAddressCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(6);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches signer-object getAddress getter throw fallback across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xafafafafafafafafafafafafafafafafafafafaf';
    const timelockOwnerB = '0xb0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0';
    const proposerIcaA = '0xb1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1';
    const proposerIcaB = '0xb2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2';
    const destinationRouterAddress =
      '0x5353535353535353535353535353535353535353';
    const originRouterAddress = '0x5454545454545454545454545454545454545454';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: filter.address }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .callsFake(
        (_address: string) =>
          ({
            getMinDelay: async () => 0,
            hasRole: async () => false,
            interface: {
              getEventTopic: (name: string) => name,
              parseLog: (log: any) => ({
                args: {
                  account:
                    log.data?.toLowerCase() === timelockOwnerA.toLowerCase()
                      ? proposerIcaA
                      : proposerIcaB,
                },
              }),
            },
          }) as any,
      );

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async (
              owner: string,
            ) => {
              if (owner.toLowerCase() === SIGNER.toLowerCase()) {
                return proposerIcaA;
              }
              return proposerIcaB;
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerGetAddressGetterCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error('origin signer unavailable');
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          if (chainName === 'anvil3') {
            return {
              get getAddress() {
                originSignerGetAddressGetterCalls += 1;
                throw new Error('signer object getAddress getter failed');
              },
            };
          }
          return null;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      const proposerSubmitterTypes = batches.map(
        (batch) => (batch.config.submitter as any).proposerSubmitter.type,
      );
      expect(proposerSubmitterTypes).to.deep.equal([
        TxSubmitterType.JSON_RPC,
        TxSubmitterType.JSON_RPC,
      ]);
      expect(originSignerGetAddressGetterCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async signer-object getAddress getter throw fallback across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xb3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3';
    const timelockOwnerB = '0xb4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4';
    const proposerIcaA = '0xb5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5';
    const proposerIcaB = '0xb6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6';
    const destinationRouterAddress =
      '0x5353535353535353535353535353535353535353';
    const originRouterAddress = '0x5454545454545454545454545454545454545454';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: filter.address }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .callsFake(
        (_address: string) =>
          ({
            getMinDelay: async () => 0,
            hasRole: async () => false,
            interface: {
              getEventTopic: (name: string) => name,
              parseLog: (log: any) => ({
                args: {
                  account:
                    log.data?.toLowerCase() === timelockOwnerA.toLowerCase()
                      ? proposerIcaA
                      : proposerIcaB,
                },
              }),
            },
          }) as any,
      );

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async (
              owner: string,
            ) => {
              if (owner.toLowerCase() === SIGNER.toLowerCase()) {
                return proposerIcaA;
              }
              return proposerIcaB;
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerGetAddressGetterCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error('origin signer unavailable');
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          if (chainName === 'anvil3') {
            return {
              get getAddress() {
                originSignerGetAddressGetterCalls += 1;
                throw new Error('signer object getAddress getter failed');
              },
            };
          }
          return null;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      const proposerSubmitterTypes = batches.map(
        (batch) => (batch.config.submitter as any).proposerSubmitter.type,
      );
      expect(proposerSubmitterTypes).to.deep.equal([
        TxSubmitterType.JSON_RPC,
        TxSubmitterType.JSON_RPC,
      ]);
      expect(originSignerGetAddressGetterCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches non-function-then signer-object getAddress getter throw fallback across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d';
    const timelockOwnerB = '0x8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e';
    const proposerIcaA = '0x8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f';
    const proposerIcaB = '0x9191919191919191919191919191919191919191';
    const destinationRouterAddress =
      '0x5353535353535353535353535353535353535353';
    const originRouterAddress = '0x5454545454545454545454545454545454545454';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: filter.address }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .callsFake(
        (_address: string) =>
          ({
            getMinDelay: async () => 0,
            hasRole: async () => false,
            interface: {
              getEventTopic: (name: string) => name,
              parseLog: (log: any) => ({
                args: {
                  account:
                    log.data?.toLowerCase() === timelockOwnerA.toLowerCase()
                      ? proposerIcaA
                      : proposerIcaB,
                },
              }),
            },
          }) as any,
      );

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async (
              owner: string,
            ) => {
              if (owner.toLowerCase() === SIGNER.toLowerCase()) {
                return proposerIcaA;
              }
              return proposerIcaB;
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerGetAddressGetterCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error('origin signer unavailable');
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          if (chainName === 'anvil3') {
            return {
              then: 1,
              get getAddress() {
                originSignerGetAddressGetterCalls += 1;
                throw new Error('signer object getAddress getter failed');
              },
            };
          }
          return null;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      const proposerSubmitterTypes = batches.map(
        (batch) => (batch.config.submitter as any).proposerSubmitter.type,
      );
      expect(proposerSubmitterTypes).to.deep.equal([
        TxSubmitterType.JSON_RPC,
        TxSubmitterType.JSON_RPC,
      ]);
      expect(originSignerGetAddressGetterCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async non-function-then signer-object getAddress getter throw fallback across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x9292929292929292929292929292929292929292';
    const timelockOwnerB = '0x9393939393939393939393939393939393939393';
    const proposerIcaA = '0x9494949494949494949494949494949494949494';
    const proposerIcaB = '0x9595959595959595959595959595959595959595';
    const destinationRouterAddress =
      '0x5353535353535353535353535353535353535353';
    const originRouterAddress = '0x5454545454545454545454545454545454545454';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: filter.address }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .callsFake(
        (_address: string) =>
          ({
            getMinDelay: async () => 0,
            hasRole: async () => false,
            interface: {
              getEventTopic: (name: string) => name,
              parseLog: (log: any) => ({
                args: {
                  account:
                    log.data?.toLowerCase() === timelockOwnerA.toLowerCase()
                      ? proposerIcaA
                      : proposerIcaB,
                },
              }),
            },
          }) as any,
      );

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async (
              owner: string,
            ) => {
              if (owner.toLowerCase() === SIGNER.toLowerCase()) {
                return proposerIcaA;
              }
              return proposerIcaB;
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerGetAddressGetterCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error('origin signer unavailable');
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          if (chainName === 'anvil3') {
            return {
              then: 1,
              get getAddress() {
                originSignerGetAddressGetterCalls += 1;
                throw new Error('signer object getAddress getter failed');
              },
            };
          }
          return null;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      const proposerSubmitterTypes = batches.map(
        (batch) => (batch.config.submitter as any).proposerSubmitter.type,
      );
      expect(proposerSubmitterTypes).to.deep.equal([
        TxSubmitterType.JSON_RPC,
        TxSubmitterType.JSON_RPC,
      ]);
      expect(originSignerGetAddressGetterCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(6);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches signer-address short-circuit over signer-object getter throws across timelock ICA inferences', async () => {
    const timelockOwner = '0x9696969696969696969696969696969696969696';
    const proposerIca = '0x9898989898989898989898989898989898989898';
    const destinationRouterAddress =
      '0x5353535353535353535353535353535353535353';
    const originRouterAddress = '0x5454545454545454545454545454545454545454';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => timelockOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          filter.address === timelockOwner &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async (
              owner: string,
            ) =>
              owner.toLowerCase() === SIGNER.toLowerCase()
                ? proposerIca
                : ethersConstants.AddressZero,
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerProbeCalls = 0;
    let originSignerGetAddressGetterCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN || chainName === 'anvil3') {
            return SIGNER;
          }
          throw new Error('unknown signer lookup');
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return {
            get getAddress() {
              originSignerGetAddressGetterCalls += 1;
              throw new Error('signer object getAddress getter failed');
            },
          };
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any, TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.INTERCHAIN_ACCOUNT);
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.owner,
      ).to.equal(SIGNER);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerGetAddressGetterCalls).to.equal(0);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(3);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches signer-address short-circuit over async signer-object getter throws across timelock ICA inferences', async () => {
    const timelockOwner = '0x9999999999999999999999999999999999999999';
    const proposerIca = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa';
    const destinationRouterAddress =
      '0x5353535353535353535353535353535353535353';
    const originRouterAddress = '0x5454545454545454545454545454545454545454';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => timelockOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          filter.address === timelockOwner &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async (
              owner: string,
            ) =>
              owner.toLowerCase() === SIGNER.toLowerCase()
                ? proposerIca
                : ethersConstants.AddressZero,
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerProbeCalls = 0;
    let originSignerGetAddressGetterCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN || chainName === 'anvil3') {
            return SIGNER;
          }
          throw new Error('unknown signer lookup');
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return {
            get getAddress() {
              originSignerGetAddressGetterCalls += 1;
              throw new Error('signer object getAddress getter failed');
            },
          };
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any, TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.INTERCHAIN_ACCOUNT);
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.owner,
      ).to.equal(SIGNER);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerGetAddressGetterCalls).to.equal(0);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(3);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches signer-address short-circuit over signer-object getAddress throw across timelock ICA inferences', async () => {
    const timelockOwner = '0xe7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7';
    const proposerIca = '0xe8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8';
    const destinationRouterAddress =
      '0x5353535353535353535353535353535353535353';
    const originRouterAddress = '0x5454545454545454545454545454545454545454';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => timelockOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          filter.address === timelockOwner &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async (
              owner: string,
            ) =>
              owner.toLowerCase() === SIGNER.toLowerCase()
                ? proposerIca
                : ethersConstants.AddressZero,
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerProbeCalls = 0;
    let originSignerGetAddressCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN || chainName === 'anvil3') {
            return SIGNER;
          }
          throw new Error('unknown signer lookup');
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return {
            getAddress: () => {
              originSignerGetAddressCalls += 1;
              throw new Error('signer object getAddress failed');
            },
          };
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any, TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerGetAddressCalls).to.equal(0);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(2);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches signer-address short-circuit over async signer-object getAddress throw across timelock ICA inferences', async () => {
    const timelockOwner = '0xe9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9';
    const proposerIca = '0xeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaea';
    const destinationRouterAddress =
      '0x5353535353535353535353535353535353535353';
    const originRouterAddress = '0x5454545454545454545454545454545454545454';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => timelockOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          filter.address === timelockOwner &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async (
              owner: string,
            ) =>
              owner.toLowerCase() === SIGNER.toLowerCase()
                ? proposerIca
                : ethersConstants.AddressZero,
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerProbeCalls = 0;
    let originSignerGetAddressCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN || chainName === 'anvil3') {
            return SIGNER;
          }
          throw new Error('unknown signer lookup');
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return {
            getAddress: async () => {
              originSignerGetAddressCalls += 1;
              throw new Error('signer object getAddress failed');
            },
          };
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any, TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerGetAddressCalls).to.equal(0);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(2);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches signer-address short-circuit over non-function-then signer-object getter throws across timelock ICA inferences', async () => {
    const timelockOwner = '0xe3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3';
    const proposerIca = '0xe4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4';
    const destinationRouterAddress =
      '0x5353535353535353535353535353535353535353';
    const originRouterAddress = '0x5454545454545454545454545454545454545454';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => timelockOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          filter.address === timelockOwner &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async (
              owner: string,
            ) =>
              owner.toLowerCase() === SIGNER.toLowerCase()
                ? proposerIca
                : ethersConstants.AddressZero,
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerProbeCalls = 0;
    let originSignerGetAddressGetterCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN || chainName === 'anvil3') {
            return SIGNER;
          }
          throw new Error('unknown signer lookup');
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return {
            then: 1,
            get getAddress() {
              originSignerGetAddressGetterCalls += 1;
              throw new Error('signer object getAddress getter failed');
            },
          };
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any, TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerGetAddressGetterCalls).to.equal(0);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(2);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches signer-address short-circuit over async non-function-then signer-object getter throws across timelock ICA inferences', async () => {
    const timelockOwner = '0xe5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5';
    const proposerIca = '0xe6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6';
    const destinationRouterAddress =
      '0x5353535353535353535353535353535353535353';
    const originRouterAddress = '0x5454545454545454545454545454545454545454';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => timelockOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          filter.address === timelockOwner &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async (
              owner: string,
            ) =>
              owner.toLowerCase() === SIGNER.toLowerCase()
                ? proposerIca
                : ethersConstants.AddressZero,
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerProbeCalls = 0;
    let originSignerGetAddressGetterCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN || chainName === 'anvil3') {
            return SIGNER;
          }
          throw new Error('unknown signer lookup');
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return {
            then: 1,
            get getAddress() {
              originSignerGetAddressGetterCalls += 1;
              throw new Error('signer object getAddress getter failed');
            },
          };
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any, TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerGetAddressGetterCalls).to.equal(0);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(2);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches signer-address short-circuit over non-function-then signer-object getAddress throw across timelock ICA inferences', async () => {
    const timelockOwner = '0xebebebebebebebebebebebebebebebebebebebeb';
    const proposerIca = '0xecececececececececececececececececececec';
    const destinationRouterAddress =
      '0x5353535353535353535353535353535353535353';
    const originRouterAddress = '0x5454545454545454545454545454545454545454';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => timelockOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          filter.address === timelockOwner &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async (
              owner: string,
            ) =>
              owner.toLowerCase() === SIGNER.toLowerCase()
                ? proposerIca
                : ethersConstants.AddressZero,
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerProbeCalls = 0;
    let originSignerGetAddressCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN || chainName === 'anvil3') {
            return SIGNER;
          }
          throw new Error('unknown signer lookup');
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return {
            then: 1,
            getAddress: () => {
              originSignerGetAddressCalls += 1;
              throw new Error('signer object getAddress failed');
            },
          };
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any, TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerGetAddressCalls).to.equal(0);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(2);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches signer-address short-circuit over async non-function-then signer-object getAddress throw across timelock ICA inferences', async () => {
    const timelockOwner = '0xedededededededededededededededededededed';
    const proposerIca = '0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee';
    const destinationRouterAddress =
      '0x5353535353535353535353535353535353535353';
    const originRouterAddress = '0x5454545454545454545454545454545454545454';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => timelockOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          filter.address === timelockOwner &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async (
              owner: string,
            ) =>
              owner.toLowerCase() === SIGNER.toLowerCase()
                ? proposerIca
                : ethersConstants.AddressZero,
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerProbeCalls = 0;
    let originSignerGetAddressCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN || chainName === 'anvil3') {
            return SIGNER;
          }
          throw new Error('unknown signer lookup');
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return {
            then: 1,
            getAddress: async () => {
              originSignerGetAddressCalls += 1;
              throw new Error('signer object getAddress failed');
            },
          };
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any, TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerGetAddressCalls).to.equal(0);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(2);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches signer-object getAddress throw fallback across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb';
    const timelockOwnerB = '0xbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbc';
    const proposerIcaA = '0xbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbd';
    const proposerIcaB = '0xbebebebebebebebebebebebebebebebebebebebe';
    const destinationRouterAddress =
      '0x5353535353535353535353535353535353535353';
    const originRouterAddress = '0x5454545454545454545454545454545454545454';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: filter.address }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .callsFake(
        (_address: string) =>
          ({
            getMinDelay: async () => 0,
            hasRole: async () => false,
            interface: {
              getEventTopic: (name: string) => name,
              parseLog: (log: any) => ({
                args: {
                  account:
                    log.data?.toLowerCase() === timelockOwnerA.toLowerCase()
                      ? proposerIcaA
                      : proposerIcaB,
                },
              }),
            },
          }) as any,
      );

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async (
              owner: string,
            ) =>
              owner.toLowerCase() === SIGNER.toLowerCase()
                ? proposerIcaA
                : proposerIcaB,
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerProbeCalls = 0;
    let originSignerGetAddressCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error('origin signer unavailable');
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return {
            getAddress: () => {
              originSignerGetAddressCalls += 1;
              throw new Error('signer object getAddress failed');
            },
          };
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      const proposerSubmitterTypes = batches.map(
        (batch) => (batch.config.submitter as any).proposerSubmitter.type,
      );
      expect(proposerSubmitterTypes).to.deep.equal([
        TxSubmitterType.JSON_RPC,
        TxSubmitterType.JSON_RPC,
      ]);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerGetAddressCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async signer-object getAddress throw fallback across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbf';
    const timelockOwnerB = '0xc0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0';
    const proposerIcaA = '0xc1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1';
    const proposerIcaB = '0xc2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2';
    const destinationRouterAddress =
      '0x5353535353535353535353535353535353535353';
    const originRouterAddress = '0x5454545454545454545454545454545454545454';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: filter.address }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .callsFake(
        (_address: string) =>
          ({
            getMinDelay: async () => 0,
            hasRole: async () => false,
            interface: {
              getEventTopic: (name: string) => name,
              parseLog: (log: any) => ({
                args: {
                  account:
                    log.data?.toLowerCase() === timelockOwnerA.toLowerCase()
                      ? proposerIcaA
                      : proposerIcaB,
                },
              }),
            },
          }) as any,
      );

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async (
              owner: string,
            ) =>
              owner.toLowerCase() === SIGNER.toLowerCase()
                ? proposerIcaA
                : proposerIcaB,
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerProbeCalls = 0;
    let originSignerGetAddressCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error('origin signer unavailable');
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return {
            getAddress: async () => {
              originSignerGetAddressCalls += 1;
              throw new Error('signer object getAddress failed');
            },
          };
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      const proposerSubmitterTypes = batches.map(
        (batch) => (batch.config.submitter as any).proposerSubmitter.type,
      );
      expect(proposerSubmitterTypes).to.deep.equal([
        TxSubmitterType.JSON_RPC,
        TxSubmitterType.JSON_RPC,
      ]);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerGetAddressCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async non-function-then signer-object getAddress throw fallback across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xc7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7';
    const timelockOwnerB = '0xc8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8';
    const proposerIcaA = '0xc9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9';
    const proposerIcaB = '0xcacacacacacacacacacacacacacacacacacacaca';
    const destinationRouterAddress =
      '0x5353535353535353535353535353535353535353';
    const originRouterAddress = '0x5454545454545454545454545454545454545454';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: filter.address }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .callsFake(
        (_address: string) =>
          ({
            getMinDelay: async () => 0,
            hasRole: async () => false,
            interface: {
              getEventTopic: (name: string) => name,
              parseLog: (log: any) => ({
                args: {
                  account:
                    log.data?.toLowerCase() === timelockOwnerA.toLowerCase()
                      ? proposerIcaA
                      : proposerIcaB,
                },
              }),
            },
          }) as any,
      );

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async (
              owner: string,
            ) => {
              if (owner.toLowerCase() === SIGNER.toLowerCase()) {
                return proposerIcaA;
              }
              return proposerIcaB;
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerProbeCalls = 0;
    let originSignerGetAddressCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error('origin signer unavailable');
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return {
            then: 1,
            getAddress: async () => {
              originSignerGetAddressCalls += 1;
              throw new Error('signer object getAddress failed');
            },
          };
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      const proposerSubmitterTypes = batches.map(
        (batch) => (batch.config.submitter as any).proposerSubmitter.type,
      );
      expect(proposerSubmitterTypes).to.deep.equal([
        TxSubmitterType.JSON_RPC,
        TxSubmitterType.JSON_RPC,
      ]);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerGetAddressCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('falls back to jsonRpc when timelock signer object getAddress is zero', async () => {
    const timelockOwner = '0x5151515151515151515151515151515151515151';
    const proposerIca = '0x5252525252525252525252525252525252525252';
    const destinationRouterAddress =
      '0x5353535353535353535353535353535353535353';
    const originRouterAddress = '0x5454545454545454545454545454545454545454';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => timelockOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          filter.address === timelockOwner &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerObjectAddressCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error('origin signer unavailable');
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          if (chainName === 'anvil3') {
            return {
              getAddress: async () => {
                originSignerObjectAddressCalls += 1;
                return ethersConstants.AddressZero;
              },
            };
          }
          return null;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any, TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerObjectAddressCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(3);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('falls back to jsonRpc when non-function-then timelock signer object getAddress is zero', async () => {
    const timelockOwner = '0x5151515151515151515151515151515151515151';
    const proposerIca = '0x5252525252525252525252525252525252525252';
    const destinationRouterAddress =
      '0x5353535353535353535353535353535353535353';
    const originRouterAddress = '0x5454545454545454545454545454545454545454';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => timelockOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          filter.address === timelockOwner &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerObjectAddressCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error('origin signer unavailable');
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          if (chainName === 'anvil3') {
            return {
              then: 1,
              getAddress: () => {
                originSignerObjectAddressCalls += 1;
                return ethersConstants.AddressZero;
              },
            };
          }
          return null;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any, TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerObjectAddressCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(3);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('falls back to jsonRpc when async non-function-then timelock signer object getAddress is zero', async () => {
    const timelockOwner = '0x5151515151515151515151515151515151515151';
    const proposerIca = '0x5252525252525252525252525252525252525252';
    const destinationRouterAddress =
      '0x5353535353535353535353535353535353535353';
    const originRouterAddress = '0x5454545454545454545454545454545454545454';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => timelockOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          filter.address === timelockOwner &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerObjectAddressCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error('origin signer unavailable');
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          if (chainName === 'anvil3') {
            return {
              then: 1,
              getAddress: async () => {
                originSignerObjectAddressCalls += 1;
                return ethersConstants.AddressZero;
              },
            };
          }
          return null;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any, TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerObjectAddressCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(3);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('falls back to jsonRpc when timelock signer object getAddress throws', async () => {
    const timelockOwner = '0x5151515151515151515151515151515151515151';
    const proposerIca = '0x5252525252525252525252525252525252525252';
    const destinationRouterAddress =
      '0x5353535353535353535353535353535353535353';
    const originRouterAddress = '0x5454545454545454545454545454545454545454';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => timelockOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          filter.address === timelockOwner &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerObjectAddressCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error('origin signer unavailable');
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          if (chainName === 'anvil3') {
            return {
              getAddress: async () => {
                originSignerObjectAddressCalls += 1;
                throw new Error('signer object address failed');
              },
            };
          }
          return null;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any, TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerObjectAddressCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(3);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('falls back to jsonRpc when timelock signer object getAddress getter throws', async () => {
    const timelockOwner = '0x5151515151515151515151515151515151515151';
    const proposerIca = '0x5252525252525252525252525252525252525252';
    const destinationRouterAddress =
      '0x5353535353535353535353535353535353535353';
    const originRouterAddress = '0x5454545454545454545454545454545454545454';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => timelockOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          filter.address === timelockOwner &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerGetAddressGetterCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error('origin signer unavailable');
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          if (chainName === 'anvil3') {
            return {
              get getAddress() {
                originSignerGetAddressGetterCalls += 1;
                throw new Error('signer object getAddress getter failed');
              },
            };
          }
          return null;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any, TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerGetAddressGetterCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(3);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('falls back to jsonRpc when timelock ICA origin signer is zero address with tryGetSigner', async () => {
    const timelockOwner = '0x5151515151515151515151515151515151515151';
    const proposerIca = '0x5252525252525252525252525252525252525252';
    const destinationRouterAddress =
      '0x5353535353535353535353535353535353535353';
    const originRouterAddress = '0x5454545454545454545454545454545454545454';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => timelockOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          filter.address === timelockOwner &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerProbeCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          return ethersConstants.AddressZero;
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName !== CHAIN) {
            originSignerProbeCalls += 1;
          }
          return {};
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any, TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(3);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('falls back to jsonRpc when timelock ICA origin signer is malformed with tryGetSigner', async () => {
    const timelockOwner = '0x5151515151515151515151515151515151515151';
    const proposerIca = '0x5252525252525252525252525252525252525252';
    const destinationRouterAddress =
      '0x5353535353535353535353535353535353535353';
    const originRouterAddress = '0x5454545454545454545454545454545454545454';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => timelockOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          filter.address === timelockOwner &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    let originSignerProbeCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          return 'not-an-evm-address';
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName !== CHAIN) {
            originSignerProbeCalls += 1;
          }
          return {};
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any, TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(3);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches no-tryGetSigner origin signer lookup failures across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x8181818181818181818181818181818181818181';
    const timelockOwnerB = '0x8282828282828282828282828282828282828282';
    const proposerIca = '0x8383838383838383838383838383838383838383';
    const destinationRouterAddress =
      '0x8484848484848484848484848484848484848484';
    const originRouterAddress = '0x8585858585858585858585858585858585858585';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let signerAddressCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCalls += 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error('origin signer unavailable');
        },
        getProvider: () => provider,
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(signerAddressCalls).to.equal(2);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches successful origin signer lookup without tryGetSigner across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b';
    const timelockOwnerB = '0x8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c';
    const proposerIca = '0x8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d';
    const destinationRouterAddress =
      '0x8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e';
    const originRouterAddress = '0x8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const hasRoleStub = sinon
      .stub()
      .callsFake(async (_role: string, account: string) => {
        return account.toLowerCase() === proposerIca.toLowerCase();
      });

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: hasRoleStub,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    let originDerivationCalls = 0;
    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']:
              async () => {
                originDerivationCalls += 1;
                return proposerIca;
              },
          } as any;
        }

        throw new Error('unexpected router');
      });

    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN || chainName === 'anvil3') {
            return SIGNER;
          }
          throw new Error(`unknown signer lookup for ${chainName}`);
        },
        getProvider: (chainName: string) => {
          if (chainName === CHAIN || chainName === 'anvil3') {
            return provider;
          }
          throw new Error(`unexpected provider lookup for ${chainName}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.INTERCHAIN_ACCOUNT);
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.owner,
      ).to.equal(SIGNER);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.INTERCHAIN_ACCOUNT);
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.owner,
      ).to.equal(SIGNER);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(originDerivationCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches successful event-derived origin signer lookup without tryGetSigner across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x9090909090909090909090909090909090909090';
    const timelockOwnerB = '0x9191919191919191919191919191919191919191';
    const proposerIca = '0x9292929292929292929292929292929292929292';
    const destinationRouterAddress =
      '0x9393939393939393939393939393939393939393';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x0000000000000000000000009494949494949494949494949494949494949494';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN || chainName === 'anvil3') {
            return SIGNER;
          }
          throw new Error(`unknown signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.INTERCHAIN_ACCOUNT);
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.owner,
      ).to.equal(SIGNER);
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.chain,
      ).to.equal('anvil3');
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.internalSubmitter
          .type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.INTERCHAIN_ACCOUNT);
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.owner,
      ).to.equal(SIGNER);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived no-tryGetSigner origin signer lookup failures across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x9595959595959595959595959595959595959595';
    const timelockOwnerB = '0x9696969696969696969696969696969696969696';
    const proposerIca = '0x9797979797979797979797979797979797979797';
    const destinationRouterAddress =
      '0x9898989898989898989898989898989898989898';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x0000000000000000000000009999999999999999999999999999999999999999';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error(`origin signer unavailable for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived no-tryGetSigner zero-address origin signer lookups across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a';
    const timelockOwnerB = '0x9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b';
    const proposerIca = '0x9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c';
    const destinationRouterAddress =
      '0x9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x0000000000000000000000009e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          return ethersConstants.AddressZero;
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived no-tryGetSigner malformed origin signer lookups across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xa0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0';
    const timelockOwnerB = '0xa1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1';
    const proposerIca = '0xa2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2';
    const destinationRouterAddress =
      '0xa3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          return 'not-an-evm-address';
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived unavailable origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xa5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5';
    const timelockOwnerB = '0xa6a6a6a6a6a6a6a6a6a6a6a6a6a6a6a6a6a6a6a6';
    const proposerIca = '0xa7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a7';
    const destinationRouterAddress =
      '0xa8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return null;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(0);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async undefined origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa';
    const timelockOwnerB = '0xabababababababababababababababababababab';
    const proposerIca = '0xacacacacacacacacacacacacacacacacacacacac';
    const destinationRouterAddress =
      '0xadadadadadadadadadadadadadadadadadadadad';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000aeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeae';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return undefined;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(0);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived undefined origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xafafafafafafafafafafafafafafafafafafafaf';
    const timelockOwnerB = '0xb0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0';
    const proposerIca = '0xb1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1';
    const destinationRouterAddress =
      '0xb2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return undefined;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(0);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async false origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xb4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4';
    const timelockOwnerB = '0xb5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5';
    const proposerIca = '0xb6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6';
    const destinationRouterAddress =
      '0xb7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return false;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(0);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived false origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xb9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9';
    const timelockOwnerB = '0xbabababababababababababababababababababa';
    const proposerIca = '0xbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb';
    const destinationRouterAddress =
      '0xbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbc';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000bdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbd';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return false;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(0);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived numeric-zero origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xd2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2';
    const timelockOwnerB = '0xd3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3';
    const proposerIca = '0xd4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4';
    const destinationRouterAddress =
      '0xd5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return 0;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(0);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived negative-zero origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xd2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2';
    const timelockOwnerB = '0xd3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3';
    const proposerIca = '0xd4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4';
    const destinationRouterAddress =
      '0xd5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return -0;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(0);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived bigint-zero origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdc';
    const timelockOwnerB = '0xdddddddddddddddddddddddddddddddddddddddd';
    const proposerIca = '0xdededededededededededededededededededede';
    const destinationRouterAddress =
      '0xdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdf';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return 0n;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(0);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async numeric-zero origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xf5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5';
    const timelockOwnerB = '0xf6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6';
    const proposerIca = '0xf7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7';
    const destinationRouterAddress =
      '0xf8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return 0;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(0);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async negative-zero origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xf5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5';
    const timelockOwnerB = '0xf6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6';
    const proposerIca = '0xf7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7';
    const destinationRouterAddress =
      '0xf8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return -0;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(0);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived boxed-number-zero origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa';
    const timelockOwnerB = '0xabababababababababababababababababababab';
    const proposerIca = '0xacacacacacacacacacacacacacacacacacacacac';
    const destinationRouterAddress =
      '0xadadadadadadadadadadadadadadadadadadadad';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000aeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeae';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(0);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async boxed-number-zero origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xafafafafafafafafafafafafafafafafafafafaf';
    const timelockOwnerB = '0xb0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0';
    const proposerIca = '0xb1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1';
    const destinationRouterAddress =
      '0xb2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(0);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived boxed-number-one origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xc3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3';
    const timelockOwnerB = '0xc4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4';
    const proposerIca = '0xc5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5';
    const destinationRouterAddress =
      '0xc6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(1);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async boxed-number-one origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xc8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8';
    const timelockOwnerB = '0xc9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9';
    const proposerIca = '0xcacacacacacacacacacacacacacacacacacacaca';
    const destinationRouterAddress =
      '0xcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcb';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000cccccccccccccccccccccccccccccccccccccccc';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(1);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived boxed-boolean-false origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xb4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4';
    const timelockOwnerB = '0xb5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5';
    const proposerIca = '0xb6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6';
    const destinationRouterAddress =
      '0xb7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(false);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async boxed-boolean-false origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xb9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9';
    const timelockOwnerB = '0xbabababababababababababababababababababa';
    const proposerIca = '0xbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb';
    const destinationRouterAddress =
      '0xbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbc';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000bdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbd';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(false);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived boxed-boolean-true origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x8686868686868686868686868686868686868686';
    const timelockOwnerB = '0x8787878787878787878787878787878787878787';
    const proposerIca = '0x8888888888888888888888888888888888888888';
    const destinationRouterAddress =
      '0x8989898989898989898989898989898989898989';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x0000000000000000000000008a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(true);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async boxed-boolean-true origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b';
    const timelockOwnerB = '0x8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c';
    const proposerIca = '0x8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d';
    const destinationRouterAddress =
      '0x8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x0000000000000000000000008f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(true);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived boxed-empty-string origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xc0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0';
    const timelockOwnerB = '0xc1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1';
    const proposerIca = '0xc2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2';
    const destinationRouterAddress =
      '0xc3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object('');
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async boxed-empty-string origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xc5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5';
    const timelockOwnerB = '0xc6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6';
    const proposerIca = '0xc7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7';
    const destinationRouterAddress =
      '0xc8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object('');
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived boxed-bigint-zero origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f';
    const timelockOwnerB = '0x3030303030303030303030303030303030303030';
    const proposerIca = '0x3131313131313131313131313131313131313131';
    const destinationRouterAddress =
      '0x3232323232323232323232323232323232323232';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x0000000000000000000000003333333333333333333333333333333333333333';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(0n);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async boxed-bigint-zero origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x4545454545454545454545454545454545454545';
    const timelockOwnerB = '0x4646464646464646464646464646464646464646';
    const proposerIca = '0x4747474747474747474747474747474747474747';
    const destinationRouterAddress =
      '0x4848484848484848484848484848484848484848';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x0000000000000000000000004949494949494949494949494949494949494949';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(0n);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived boxed-negative-infinite-number origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a';
    const timelockOwnerB = '0x4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b';
    const proposerIca = '0x4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c';
    const destinationRouterAddress =
      '0x4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x0000000000000000000000004e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(Number.NEGATIVE_INFINITY);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async boxed-negative-infinite-number origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f';
    const timelockOwnerB = '0x5050505050505050505050505050505050505050';
    const proposerIca = '0x5151515151515151515151515151515151515151';
    const destinationRouterAddress =
      '0x5252525252525252525252525252525252525252';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x0000000000000000000000005353535353535353535353535353535353535353';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(Number.NEGATIVE_INFINITY);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived boxed-infinite-number origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e';
    const timelockOwnerB = '0x5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f';
    const proposerIca = '0x6060606060606060606060606060606060606060';
    const destinationRouterAddress =
      '0x6161616161616161616161616161616161616161';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x0000000000000000000000006262626262626262626262626262626262626262';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(Number.POSITIVE_INFINITY);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async boxed-infinite-number origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x6363636363636363636363636363636363636363';
    const timelockOwnerB = '0x6464646464646464646464646464646464646464';
    const proposerIca = '0x6565656565656565656565656565656565656565';
    const destinationRouterAddress =
      '0x6666666666666666666666666666666666666666';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x0000000000000000000000006767676767676767676767676767676767676767';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(Number.POSITIVE_INFINITY);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived boxed-nan origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x7272727272727272727272727272727272727272';
    const timelockOwnerB = '0x7373737373737373737373737373737373737373';
    const proposerIca = '0x7474747474747474747474747474747474747474';
    const destinationRouterAddress =
      '0x7575757575757575757575757575757575757575';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x0000000000000000000000007676767676767676767676767676767676767676';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(Number.NaN);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async boxed-nan origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x7777777777777777777777777777777777777777';
    const timelockOwnerB = '0x7878787878787878787878787878787878787878';
    const proposerIca = '0x7979797979797979797979797979797979797979';
    const destinationRouterAddress =
      '0x7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x0000000000000000000000007b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(Number.NaN);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async bigint-zero origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xfafafafafafafafafafafafafafafafafafafafa';
    const timelockOwnerB = '0xfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfb';
    const proposerIca = '0xfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfc';
    const destinationRouterAddress =
      '0xfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfd';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000fefefefefefefefefefefefefefefefefefefefe';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return 0n;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(0);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived nan origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xa1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1';
    const timelockOwnerB = '0xa2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2';
    const proposerIca = '0xa3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3';
    const destinationRouterAddress =
      '0xa4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Number.NaN;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(0);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async nan origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xb1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1';
    const timelockOwnerB = '0xb2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2';
    const proposerIca = '0xb3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3';
    const destinationRouterAddress =
      '0xb4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Number.NaN;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(0);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived infinite-number origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xb6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6';
    const timelockOwnerB = '0xb7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7';
    const proposerIca = '0xb8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8';
    const destinationRouterAddress =
      '0xb9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000babababababababababababababababababababa';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Number.POSITIVE_INFINITY;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async infinite-number origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb';
    const timelockOwnerB = '0xbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbc';
    const proposerIca = '0xbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbd';
    const destinationRouterAddress =
      '0xbebebebebebebebebebebebebebebebebebebebe';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000bfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbf';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Number.POSITIVE_INFINITY;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived negative-infinite-number origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xf0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0';
    const timelockOwnerB = '0xf1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1';
    const proposerIca = '0xf2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2';
    const destinationRouterAddress =
      '0xf3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Number.NEGATIVE_INFINITY;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async negative-infinite-number origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xf5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5';
    const timelockOwnerB = '0xf6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6';
    const proposerIca = '0xf7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7';
    const destinationRouterAddress =
      '0xf8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Number.NEGATIVE_INFINITY;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived true origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xc0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0';
    const timelockOwnerB = '0xc1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1';
    const proposerIca = '0xc2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2';
    const destinationRouterAddress =
      '0xc3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return true;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async true origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xc5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5';
    const timelockOwnerB = '0xc6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6';
    const proposerIca = '0xc7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7';
    const destinationRouterAddress =
      '0xc8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return true;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived non-empty-string origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xe0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0';
    const timelockOwnerB = '0xe1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1';
    const proposerIca = '0xe2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2';
    const destinationRouterAddress =
      '0xe3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return 'available';
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async non-empty-string origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xe5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5';
    const timelockOwnerB = '0xe6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6';
    const proposerIca = '0xe7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7';
    const destinationRouterAddress =
      '0xe8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return 'available';
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived symbol origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaea';
    const timelockOwnerB = '0xebebebebebebebebebebebebebebebebebebebeb';
    const proposerIca = '0xecececececececececececececececececececec';
    const destinationRouterAddress =
      '0xedededededededededededededededededededed';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Symbol('available');
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async symbol origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xefefefefefefefefefefefefefefefefefefefef';
    const timelockOwnerB = '0xf0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0';
    const proposerIca = '0xf1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1';
    const destinationRouterAddress =
      '0xf2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Symbol('available');
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived boxed-symbol origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xafafafafafafafafafafafafafafafafafafafaf';
    const timelockOwnerB = '0xb0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0';
    const proposerIca = '0xb1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1';
    const destinationRouterAddress =
      '0xb2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(Symbol('available'));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async boxed-symbol origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xb4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4';
    const timelockOwnerB = '0xb5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5';
    const proposerIca = '0xb6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6';
    const destinationRouterAddress =
      '0xb7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(Symbol('available'));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived bigint-one origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x0101010101010101010101010101010101010101';
    const timelockOwnerB = '0x0202020202020202020202020202020202020202';
    const proposerIca = '0x0303030303030303030303030303030303030303';
    const destinationRouterAddress =
      '0x0404040404040404040404040404040404040404';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x0000000000000000000000000505050505050505050505050505050505050505';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return 1n;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived boxed-bigint-one origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a';
    const timelockOwnerB = '0x9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b';
    const proposerIca = '0x9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c';
    const destinationRouterAddress =
      '0x9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x0000000000000000000000009e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(1n);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async boxed-bigint-one origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xa5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5';
    const timelockOwnerB = '0xa6a6a6a6a6a6a6a6a6a6a6a6a6a6a6a6a6a6a6a6';
    const proposerIca = '0xa7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a7';
    const destinationRouterAddress =
      '0xa8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(1n);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async bigint-one origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x0606060606060606060606060606060606060606';
    const timelockOwnerB = '0x0707070707070707070707070707070707070707';
    const proposerIca = '0x0808080808080808080808080808080808080808';
    const destinationRouterAddress =
      '0x0909090909090909090909090909090909090909';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x0000000000000000000000000a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return 1n;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived empty-string origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xe1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1';
    const timelockOwnerB = '0xe2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2';
    const proposerIca = '0xe3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3';
    const destinationRouterAddress =
      '0xe4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return '';
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(0);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async empty-string origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xebebebebebebebebebebebebebebebebebebebeb';
    const timelockOwnerB = '0xecececececececececececececececececececec';
    const proposerIca = '0xedededededededededededededededededededed';
    const destinationRouterAddress =
      '0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000efefefefefefefefefefefefefefefefefefefef';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return '';
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(0);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async null origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xbebebebebebebebebebebebebebebebebebebebe';
    const timelockOwnerB = '0xbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbf';
    const proposerIca = '0xc0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0';
    const destinationRouterAddress =
      '0xc1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return null;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(0);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived signer-address fallback when tryGetSigner getter throws across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xc3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3';
    const timelockOwnerB = '0xc4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4';
    const proposerIca = '0xc5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5';
    const destinationRouterAddress =
      '0xc6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originTryGetSignerGetterCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN || chainName === 'anvil3') {
            return SIGNER;
          }
          throw new Error(`unknown signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        get tryGetSigner() {
          originTryGetSignerGetterCalls += 1;
          throw new Error('tryGetSigner getter failed');
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.INTERCHAIN_ACCOUNT);
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.owner,
      ).to.equal(SIGNER);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.INTERCHAIN_ACCOUNT);
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.owner,
      ).to.equal(SIGNER);
      expect(originTryGetSignerGetterCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived malformed signer-address fallback when tryGetSigner getter throws across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xc8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8';
    const timelockOwnerB = '0xc9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9';
    const proposerIca = '0xcacacacacacacacacacacacacacacacacacacaca';
    const destinationRouterAddress =
      '0xcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcb';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000cccccccccccccccccccccccccccccccccccccccc';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originTryGetSignerGetterCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          return 'not-an-evm-address';
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        get tryGetSigner() {
          originTryGetSignerGetterCalls += 1;
          throw new Error('tryGetSigner getter failed');
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originTryGetSignerGetterCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived zero signer-address fallback when tryGetSigner getter throws across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcd';
    const timelockOwnerB = '0xcececececececececececececececececececece';
    const proposerIca = '0xcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcf';
    const destinationRouterAddress =
      '0xd0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originTryGetSignerGetterCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          return ethersConstants.AddressZero;
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        get tryGetSigner() {
          originTryGetSignerGetterCalls += 1;
          throw new Error('tryGetSigner getter failed');
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originTryGetSignerGetterCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived throwing signer-address fallback when tryGetSigner getter throws across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xd2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2';
    const timelockOwnerB = '0xd3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3';
    const proposerIca = '0xd4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4';
    const destinationRouterAddress =
      '0xd5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originTryGetSignerGetterCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error(`origin signer unavailable for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        get tryGetSigner() {
          originTryGetSignerGetterCalls += 1;
          throw new Error('tryGetSigner getter failed');
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originTryGetSignerGetterCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived signer-address fallback when origin signer probe throws across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xd7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7';
    const timelockOwnerB = '0xd8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8';
    const proposerIca = '0xd9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9';
    const destinationRouterAddress =
      '0xdadadadadadadadadadadadadadadadadadadada';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000dbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdb';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN || chainName === 'anvil3') {
            return SIGNER;
          }
          throw new Error(`unknown signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          throw new Error(`origin signer probe failed for ${chainName}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.INTERCHAIN_ACCOUNT);
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.owner,
      ).to.equal(SIGNER);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.INTERCHAIN_ACCOUNT);
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.owner,
      ).to.equal(SIGNER);
      expect(originSignerProbeCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived malformed signer-address fallback when origin signer probe throws across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdc';
    const timelockOwnerB = '0xdddddddddddddddddddddddddddddddddddddddd';
    const proposerIca = '0xdededededededededededededededededededede';
    const destinationRouterAddress =
      '0xdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdf';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          return 'not-an-evm-address';
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          throw new Error(`origin signer probe failed for ${chainName}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived zero signer-address fallback when origin signer probe throws across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xe1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1';
    const timelockOwnerB = '0xe2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2';
    const proposerIca = '0xe3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3';
    const destinationRouterAddress =
      '0xe4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          return ethersConstants.AddressZero;
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          throw new Error(`origin signer probe failed for ${chainName}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived throwing signer-address fallback when origin signer probe throws across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xe6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6';
    const timelockOwnerB = '0xe7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7';
    const proposerIca = '0xe8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8';
    const destinationRouterAddress =
      '0xe9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000eaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaea';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error(`origin signer unavailable for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          throw new Error(`origin signer probe failed for ${chainName}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived signer-address fallback when tryGetSigner is non-function across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xebebebebebebebebebebebebebebebebebebebeb';
    const timelockOwnerB = '0xecececececececececececececececececececec';
    const proposerIca = '0xedededededededededededededededededededed';
    const destinationRouterAddress =
      '0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000efefefefefefefefefefefefefefefefefefefef';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN || chainName === 'anvil3') {
            return SIGNER;
          }
          throw new Error(`unknown signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: {},
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.INTERCHAIN_ACCOUNT);
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.owner,
      ).to.equal(SIGNER);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.INTERCHAIN_ACCOUNT);
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.owner,
      ).to.equal(SIGNER);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived malformed signer-address fallback when tryGetSigner is non-function across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xf0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0';
    const timelockOwnerB = '0xf1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1';
    const proposerIca = '0xf2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2';
    const destinationRouterAddress =
      '0xf3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          return 'not-an-evm-address';
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: {},
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived zero signer-address fallback when tryGetSigner is non-function across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xf5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5';
    const timelockOwnerB = '0xf6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6';
    const proposerIca = '0xf7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7';
    const destinationRouterAddress =
      '0xf8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          return ethersConstants.AddressZero;
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: {},
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived throwing signer-address fallback when tryGetSigner is non-function across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa0';
    const timelockOwnerB = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa1';
    const proposerIca = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa2';
    const destinationRouterAddress =
      '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error(`origin signer unavailable for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: {},
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived successful bad-thenable signer probe fallback across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab0';
    const timelockOwnerB = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab1';
    const proposerIca = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab2';
    const destinationRouterAddress =
      '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab3';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab4';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN || chainName === 'anvil3') {
            return SIGNER;
          }
          throw new Error(`unknown signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return {
            then: {},
          };
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.INTERCHAIN_ACCOUNT);
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.owner,
      ).to.equal(SIGNER);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.INTERCHAIN_ACCOUNT);
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.owner,
      ).to.equal(SIGNER);
      expect(originSignerProbeCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived malformed async-reject signer probe fallback across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab5';
    const timelockOwnerB = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab6';
    const proposerIca = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab7';
    const destinationRouterAddress =
      '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab8';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab9';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          return 'not-an-evm-address';
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          throw new Error(`origin signer async probe failed for ${chainName}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived zero-address async-reject signer probe fallback across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaac0';
    const timelockOwnerB = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaac1';
    const proposerIca = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaac2';
    const destinationRouterAddress =
      '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaac3';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaac4';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          return ethersConstants.AddressZero;
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          throw new Error(`origin signer async probe failed for ${chainName}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived throwing async-reject signer probe fallback across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaac5';
    const timelockOwnerB = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaac6';
    const proposerIca = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaac7';
    const destinationRouterAddress =
      '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaac8';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaac9';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error(`origin signer unavailable for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          throw new Error(`origin signer async probe failed for ${chainName}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived successful async-reject signer probe fallback across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaca';
    const timelockOwnerB = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaacb';
    const proposerIca = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaacc';
    const destinationRouterAddress =
      '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaacd';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaace';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN || chainName === 'anvil3') {
            return SIGNER;
          }
          throw new Error(`unknown signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          throw new Error(`origin signer async probe failed for ${chainName}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.INTERCHAIN_ACCOUNT);
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.owner,
      ).to.equal(SIGNER);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.INTERCHAIN_ACCOUNT);
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.owner,
      ).to.equal(SIGNER);
      expect(originSignerProbeCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived malformed bad-thenable signer probe fallback across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaacf';
    const timelockOwnerB = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaad0';
    const proposerIca = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaad1';
    const destinationRouterAddress =
      '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaad2';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaad3';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          return 'not-an-evm-address';
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return {
            then: {},
          };
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived zero-address bad-thenable signer probe fallback across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaad4';
    const timelockOwnerB = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaad5';
    const proposerIca = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaad6';
    const destinationRouterAddress =
      '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaad7';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaad8';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          return ethersConstants.AddressZero;
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return {
            then: {},
          };
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived throwing bad-thenable signer probe fallback across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaad9';
    const timelockOwnerB = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaada';
    const proposerIca = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaadb';
    const destinationRouterAddress =
      '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaadc';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaadd';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error(`origin signer unavailable for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return {
            then: {},
          };
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived signer-object getAddress fallback across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaade';
    const timelockOwnerB = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaadf';
    const proposerIca = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaae0';
    const destinationRouterAddress =
      '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaae1';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaae2';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerObjectAddressCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN || chainName === 'anvil3') {
            return SIGNER;
          }
          throw new Error(`unknown signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          return {
            getAddress: async () => {
              originSignerObjectAddressCalls += 1;
              return SIGNER;
            },
          };
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.INTERCHAIN_ACCOUNT);
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.owner,
      ).to.equal(SIGNER);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.INTERCHAIN_ACCOUNT);
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.owner,
      ).to.equal(SIGNER);
      expect(originSignerObjectAddressCalls).to.equal(0);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived signer-object getAddress fallback when origin signer lookup fails across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab2d';
    const timelockOwnerB = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab2e';
    const proposerIca = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab2f';
    const destinationRouterAddress =
      '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab30';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab31';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerObjectAddressCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error(`origin signer unavailable for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          return {
            getAddress: async () => {
              originSignerObjectAddressCalls += 1;
              return SIGNER;
            },
          };
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.INTERCHAIN_ACCOUNT);
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.owner,
      ).to.equal(SIGNER);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.INTERCHAIN_ACCOUNT);
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.owner,
      ).to.equal(SIGNER);
      expect(originSignerObjectAddressCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async signer-object getAddress fallback when origin signer lookup fails across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab32';
    const timelockOwnerB = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab33';
    const proposerIca = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab34';
    const destinationRouterAddress =
      '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab35';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab36';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerObjectAddressCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error(`origin signer unavailable for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          return {
            getAddress: async () => {
              originSignerObjectAddressCalls += 1;
              return SIGNER;
            },
          };
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.INTERCHAIN_ACCOUNT);
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.owner,
      ).to.equal(SIGNER);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.INTERCHAIN_ACCOUNT);
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.owner,
      ).to.equal(SIGNER);
      expect(originSignerObjectAddressCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived non-function-then signer-object getAddress fallback when origin signer lookup fails across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab8c';
    const timelockOwnerB = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab8d';
    const proposerIca = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab8e';
    const destinationRouterAddress =
      '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab8f';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab90';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerObjectAddressCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error(`origin signer unavailable for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          return {
            then: 1,
            getAddress: async () => {
              originSignerObjectAddressCalls += 1;
              return SIGNER;
            },
          };
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.INTERCHAIN_ACCOUNT);
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.owner,
      ).to.equal(SIGNER);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.INTERCHAIN_ACCOUNT);
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.owner,
      ).to.equal(SIGNER);
      expect(originSignerObjectAddressCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async non-function-then signer-object getAddress fallback when origin signer lookup fails across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab91';
    const timelockOwnerB = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab92';
    const proposerIca = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab93';
    const destinationRouterAddress =
      '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab94';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab95';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerObjectAddressCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error(`origin signer unavailable for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          return {
            then: 1,
            getAddress: async () => {
              originSignerObjectAddressCalls += 1;
              return SIGNER;
            },
          };
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.INTERCHAIN_ACCOUNT);
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.owner,
      ).to.equal(SIGNER);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.INTERCHAIN_ACCOUNT);
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.owner,
      ).to.equal(SIGNER);
      expect(originSignerObjectAddressCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived signer-object getAddress fallback when origin signer lookup is malformed across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab96';
    const timelockOwnerB = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab97';
    const proposerIca = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab98';
    const destinationRouterAddress =
      '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab99';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab9a';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerObjectAddressCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          return 'not-an-evm-address';
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          return {
            getAddress: async () => {
              originSignerObjectAddressCalls += 1;
              return SIGNER;
            },
          };
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.INTERCHAIN_ACCOUNT);
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.owner,
      ).to.equal(SIGNER);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.INTERCHAIN_ACCOUNT);
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.owner,
      ).to.equal(SIGNER);
      expect(originSignerObjectAddressCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async signer-object getAddress fallback when origin signer lookup is malformed across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab9b';
    const timelockOwnerB = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab9c';
    const proposerIca = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab9d';
    const destinationRouterAddress =
      '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab9e';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab9f';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerObjectAddressCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          return 'not-an-evm-address';
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          return {
            getAddress: async () => {
              originSignerObjectAddressCalls += 1;
              return SIGNER;
            },
          };
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.INTERCHAIN_ACCOUNT);
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.owner,
      ).to.equal(SIGNER);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.INTERCHAIN_ACCOUNT);
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.owner,
      ).to.equal(SIGNER);
      expect(originSignerObjectAddressCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived non-function-then signer-object getAddress fallback when origin signer lookup is malformed across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaba0';
    const timelockOwnerB = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaba1';
    const proposerIca = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaba2';
    const destinationRouterAddress =
      '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaba3';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaba4';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerObjectAddressCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          return 'not-an-evm-address';
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          return {
            then: 1,
            getAddress: async () => {
              originSignerObjectAddressCalls += 1;
              return SIGNER;
            },
          };
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.INTERCHAIN_ACCOUNT);
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.owner,
      ).to.equal(SIGNER);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.INTERCHAIN_ACCOUNT);
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.owner,
      ).to.equal(SIGNER);
      expect(originSignerObjectAddressCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async non-function-then signer-object getAddress fallback when origin signer lookup is malformed across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaba5';
    const timelockOwnerB = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaba6';
    const proposerIca = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaba7';
    const destinationRouterAddress =
      '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaba8';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaba9';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerObjectAddressCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          return 'not-an-evm-address';
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          return {
            then: 1,
            getAddress: async () => {
              originSignerObjectAddressCalls += 1;
              return SIGNER;
            },
          };
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.INTERCHAIN_ACCOUNT);
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.owner,
      ).to.equal(SIGNER);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.INTERCHAIN_ACCOUNT);
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.owner,
      ).to.equal(SIGNER);
      expect(originSignerObjectAddressCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived zero signer-object getAddress fallback when origin signer lookup is malformed across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabaa';
    const timelockOwnerB = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabab';
    const proposerIca = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabac';
    const destinationRouterAddress =
      '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabad';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabae';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerObjectAddressCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          return 'not-an-evm-address';
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          return {
            getAddress: async () => {
              originSignerObjectAddressCalls += 1;
              return ethersConstants.AddressZero;
            },
          };
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerObjectAddressCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived zero non-function-then signer-object getAddress fallback when origin signer lookup is malformed across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabaf';
    const timelockOwnerB = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabb0';
    const proposerIca = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabb1';
    const destinationRouterAddress =
      '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabb2';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabb3';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerObjectAddressCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          return 'not-an-evm-address';
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          return {
            then: 1,
            getAddress: async () => {
              originSignerObjectAddressCalls += 1;
              return ethersConstants.AddressZero;
            },
          };
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerObjectAddressCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived throwing signer-object getAddress fallback when origin signer lookup is malformed across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabb4';
    const timelockOwnerB = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabb5';
    const proposerIca = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabb6';
    const destinationRouterAddress =
      '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabb7';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabb8';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerObjectAddressCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          return 'not-an-evm-address';
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          return {
            getAddress: async () => {
              originSignerObjectAddressCalls += 1;
              throw new Error('signer object getAddress failed');
            },
          };
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerObjectAddressCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived throwing non-function-then signer-object getAddress fallback when origin signer lookup is malformed across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabb9';
    const timelockOwnerB = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabba';
    const proposerIca = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabbb';
    const destinationRouterAddress =
      '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabbc';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabbd';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerObjectAddressCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          return 'not-an-evm-address';
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          return {
            then: 1,
            getAddress: async () => {
              originSignerObjectAddressCalls += 1;
              throw new Error('signer object getAddress failed');
            },
          };
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerObjectAddressCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async throwing signer-object getAddress fallback when origin signer lookup is malformed across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabbe';
    const timelockOwnerB = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabbf';
    const proposerIca = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabc0';
    const destinationRouterAddress =
      '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabc1';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabc2';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerObjectAddressCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          return 'not-an-evm-address';
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          return {
            getAddress: async () => {
              originSignerObjectAddressCalls += 1;
              throw new Error('signer object getAddress failed');
            },
          };
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerObjectAddressCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async throwing non-function-then signer-object getAddress fallback when origin signer lookup is malformed across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabc3';
    const timelockOwnerB = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabc4';
    const proposerIca = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabc5';
    const destinationRouterAddress =
      '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabc6';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabc7';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerObjectAddressCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          return 'not-an-evm-address';
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          return {
            then: 1,
            getAddress: async () => {
              originSignerObjectAddressCalls += 1;
              throw new Error('signer object getAddress failed');
            },
          };
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerObjectAddressCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async zero signer-object getAddress fallback when origin signer lookup is malformed across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabc8';
    const timelockOwnerB = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabc9';
    const proposerIca = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabca';
    const destinationRouterAddress =
      '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabcb';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabcc';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerObjectAddressCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          return 'not-an-evm-address';
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          return {
            getAddress: async () => {
              originSignerObjectAddressCalls += 1;
              return ethersConstants.AddressZero;
            },
          };
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerObjectAddressCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async zero non-function-then signer-object getAddress fallback when origin signer lookup is malformed across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabcd';
    const timelockOwnerB = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabce';
    const proposerIca = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabcf';
    const destinationRouterAddress =
      '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabd0';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabd1';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerObjectAddressCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          return 'not-an-evm-address';
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          return {
            then: 1,
            getAddress: async () => {
              originSignerObjectAddressCalls += 1;
              return ethersConstants.AddressZero;
            },
          };
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerObjectAddressCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived signer-object getAddress getter throw fallback when origin signer lookup is malformed across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabd2';
    const timelockOwnerB = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabd3';
    const proposerIca = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabd4';
    const destinationRouterAddress =
      '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabd5';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabd6';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerObjectGetterCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          return 'not-an-evm-address';
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          return {
            get getAddress() {
              originSignerObjectGetterCalls += 1;
              throw new Error('signer object getAddress getter failed');
            },
          };
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerObjectGetterCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived non-function-then signer-object getAddress getter throw fallback when origin signer lookup is malformed across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabd7';
    const timelockOwnerB = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabd8';
    const proposerIca = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabd9';
    const destinationRouterAddress =
      '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabda';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabdb';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerObjectGetterCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          return 'not-an-evm-address';
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          return {
            then: 1,
            get getAddress() {
              originSignerObjectGetterCalls += 1;
              throw new Error('signer object getAddress getter failed');
            },
          };
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerObjectGetterCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async signer-object getAddress getter throw fallback when origin signer lookup is malformed across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabdc';
    const timelockOwnerB = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabdd';
    const proposerIca = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabde';
    const destinationRouterAddress =
      '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabdf';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabe0';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerObjectGetterCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          return 'not-an-evm-address';
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          return {
            get getAddress() {
              originSignerObjectGetterCalls += 1;
              throw new Error('signer object getAddress getter failed');
            },
          };
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerObjectGetterCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async non-function-then signer-object getAddress getter throw fallback when origin signer lookup is malformed across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabe1';
    const timelockOwnerB = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabe2';
    const proposerIca = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabe3';
    const destinationRouterAddress =
      '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabe4';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabe5';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerObjectGetterCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          return 'not-an-evm-address';
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          return {
            then: 1,
            get getAddress() {
              originSignerObjectGetterCalls += 1;
              throw new Error('signer object getAddress getter failed');
            },
          };
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerObjectGetterCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived signer-object without getAddress fallback across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab55';
    const timelockOwnerB = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab56';
    const proposerIca = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab57';
    const destinationRouterAddress =
      '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab58';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab59';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error(`origin signer unavailable for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return {};
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async signer-object without getAddress fallback across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab5a';
    const timelockOwnerB = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab5b';
    const proposerIca = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab5c';
    const destinationRouterAddress =
      '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab5d';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab5e';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error(`origin signer unavailable for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return {};
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived non-function-then signer-object without getAddress fallback across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab5f';
    const timelockOwnerB = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab60';
    const proposerIca = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab61';
    const destinationRouterAddress =
      '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab62';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab63';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error(`origin signer unavailable for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return {
            then: 1,
          };
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async non-function-then signer-object without getAddress fallback across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab64';
    const timelockOwnerB = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab65';
    const proposerIca = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab66';
    const destinationRouterAddress =
      '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab67';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab68';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error(`origin signer unavailable for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return {
            then: 1,
          };
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived signer-object without getAddress fallback when origin signer lookup is malformed across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabf0';
    const timelockOwnerB = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabf1';
    const proposerIca = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabf2';
    const destinationRouterAddress =
      '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabf3';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabf4';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          return 'not-an-evm-address';
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return {};
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async signer-object without getAddress fallback when origin signer lookup is malformed across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabf5';
    const timelockOwnerB = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabf6';
    const proposerIca = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabf7';
    const destinationRouterAddress =
      '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabf8';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabf9';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          return 'not-an-evm-address';
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return {};
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived non-function-then signer-object without getAddress fallback when origin signer lookup is malformed across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabfa';
    const timelockOwnerB = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabfb';
    const proposerIca = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabfc';
    const destinationRouterAddress =
      '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabfd';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabfe';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          return 'not-an-evm-address';
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return {
            then: 1,
          };
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async non-function-then signer-object without getAddress fallback when origin signer lookup is malformed across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabff';
    const timelockOwnerB = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaac00';
    const proposerIca = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaac01';
    const destinationRouterAddress =
      '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaac02';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaac03';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          return 'not-an-evm-address';
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return {
            then: 1,
          };
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived primitive signer probe fallback when origin signer lookup is malformed across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaac04';
    const timelockOwnerB = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaac05';
    const proposerIca = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaac06';
    const destinationRouterAddress =
      '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaac07';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaac08';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          return 'not-an-evm-address';
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return 1;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async primitive signer probe fallback when origin signer lookup is malformed across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaac09';
    const timelockOwnerB = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaac0a';
    const proposerIca = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaac0b';
    const destinationRouterAddress =
      '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaac0c';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaac0d';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          return 'not-an-evm-address';
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return 1;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived primitive signer probe fallback when origin signer lookup fails across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaac0e';
    const timelockOwnerB = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaac0f';
    const proposerIca = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaac10';
    const destinationRouterAddress =
      '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaac11';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaac12';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error(`origin signer unavailable for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return 1;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async primitive signer probe fallback when origin signer lookup fails across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaac13';
    const timelockOwnerB = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaac14';
    const proposerIca = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaac15';
    const destinationRouterAddress =
      '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaac16';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaac17';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error(`origin signer unavailable for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return 1;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived primitive signer probe zero-address fallback across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaac22';
    const timelockOwnerB = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaac23';
    const proposerIca = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaac24';
    const destinationRouterAddress =
      '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaac25';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaac26';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          return ethersConstants.AddressZero;
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return 1;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async primitive signer probe zero-address fallback across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaac27';
    const timelockOwnerB = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaac28';
    const proposerIca = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaac29';
    const destinationRouterAddress =
      '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaac2a';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaac2b';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          return ethersConstants.AddressZero;
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return 1;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived primitive signer-address short-circuit across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaac18';
    const timelockOwnerB = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaac19';
    const proposerIca = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaac1a';
    const destinationRouterAddress =
      '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaac1b';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaac1c';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN || chainName === 'anvil3') {
            return SIGNER;
          }
          throw new Error(`unknown signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return 1;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.INTERCHAIN_ACCOUNT);
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.owner,
      ).to.equal(SIGNER);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.INTERCHAIN_ACCOUNT);
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.owner,
      ).to.equal(SIGNER);
      expect(originSignerProbeCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(chainNameCalls).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async primitive signer-address short-circuit across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaac1d';
    const timelockOwnerB = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaac1e';
    const proposerIca = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaac1f';
    const destinationRouterAddress =
      '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaac20';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaac21';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN || chainName === 'anvil3') {
            return SIGNER;
          }
          throw new Error(`unknown signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return 1;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.INTERCHAIN_ACCOUNT);
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.owner,
      ).to.equal(SIGNER);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.INTERCHAIN_ACCOUNT);
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.owner,
      ).to.equal(SIGNER);
      expect(originSignerProbeCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(chainNameCalls).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived signer-address short-circuit over non-function-then signer-object getter throws across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab69';
    const timelockOwnerB = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab6a';
    const proposerIca = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab6b';
    const destinationRouterAddress =
      '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab6c';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab6d';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerGetAddressGetterCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN || chainName === 'anvil3') {
            return SIGNER;
          }
          throw new Error(`unknown signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return {
            then: 1,
            get getAddress() {
              originSignerGetAddressGetterCalls += 1;
              throw new Error('signer object getAddress getter failed');
            },
          };
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.INTERCHAIN_ACCOUNT);
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.owner,
      ).to.equal(SIGNER);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.INTERCHAIN_ACCOUNT);
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.owner,
      ).to.equal(SIGNER);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerGetAddressGetterCalls).to.equal(0);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived signer-address short-circuit over async non-function-then signer-object getter throws across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab6e';
    const timelockOwnerB = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab6f';
    const proposerIca = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab70';
    const destinationRouterAddress =
      '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab71';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab72';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerGetAddressGetterCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN || chainName === 'anvil3') {
            return SIGNER;
          }
          throw new Error(`unknown signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return {
            then: 1,
            get getAddress() {
              originSignerGetAddressGetterCalls += 1;
              throw new Error('signer object getAddress getter failed');
            },
          };
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.INTERCHAIN_ACCOUNT);
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.owner,
      ).to.equal(SIGNER);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.INTERCHAIN_ACCOUNT);
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.owner,
      ).to.equal(SIGNER);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerGetAddressGetterCalls).to.equal(0);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived signer-address short-circuit over signer-object getter throws across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab73';
    const timelockOwnerB = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab74';
    const proposerIca = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab75';
    const destinationRouterAddress =
      '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab76';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab77';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerGetAddressGetterCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN || chainName === 'anvil3') {
            return SIGNER;
          }
          throw new Error(`unknown signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return {
            get getAddress() {
              originSignerGetAddressGetterCalls += 1;
              throw new Error('signer object getAddress getter failed');
            },
          };
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.INTERCHAIN_ACCOUNT);
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.owner,
      ).to.equal(SIGNER);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.INTERCHAIN_ACCOUNT);
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.owner,
      ).to.equal(SIGNER);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerGetAddressGetterCalls).to.equal(0);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived signer-address short-circuit over async signer-object getter throws across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab78';
    const timelockOwnerB = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab79';
    const proposerIca = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab7a';
    const destinationRouterAddress =
      '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab7b';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab7c';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerGetAddressGetterCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN || chainName === 'anvil3') {
            return SIGNER;
          }
          throw new Error(`unknown signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return {
            get getAddress() {
              originSignerGetAddressGetterCalls += 1;
              throw new Error('signer object getAddress getter failed');
            },
          };
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.INTERCHAIN_ACCOUNT);
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.owner,
      ).to.equal(SIGNER);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.INTERCHAIN_ACCOUNT);
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.owner,
      ).to.equal(SIGNER);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerGetAddressGetterCalls).to.equal(0);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived signer-object getAddress getter throw fallback across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab23';
    const timelockOwnerB = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab24';
    const proposerIca = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab25';
    const destinationRouterAddress =
      '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab26';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab27';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerGetAddressGetterCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error(`origin signer unavailable for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          return {
            get getAddress() {
              originSignerGetAddressGetterCalls += 1;
              throw new Error('signer object getAddress getter failed');
            },
          };
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerGetAddressGetterCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async signer-object getAddress getter throw fallback across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab28';
    const timelockOwnerB = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab29';
    const proposerIca = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab2a';
    const destinationRouterAddress =
      '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab2b';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab2c';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerGetAddressGetterCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error(`origin signer unavailable for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          return {
            get getAddress() {
              originSignerGetAddressGetterCalls += 1;
              throw new Error('signer object getAddress getter failed');
            },
          };
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerGetAddressGetterCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived non-function-then signer-object getAddress fallback across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab00';
    const timelockOwnerB = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab01';
    const proposerIca = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab02';
    const destinationRouterAddress =
      '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab03';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab04';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerObjectAddressCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error(`origin signer unavailable for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          return {
            then: 1,
            getAddress: async () => {
              originSignerObjectAddressCalls += 1;
              return SIGNER;
            },
          };
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.INTERCHAIN_ACCOUNT);
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.owner,
      ).to.equal(SIGNER);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.INTERCHAIN_ACCOUNT);
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.owner,
      ).to.equal(SIGNER);
      expect(originSignerObjectAddressCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async non-function-then signer-object getAddress fallback across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab05';
    const timelockOwnerB = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab06';
    const proposerIca = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab07';
    const destinationRouterAddress =
      '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab08';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab09';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerObjectAddressCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error(`origin signer unavailable for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          return {
            then: 1,
            getAddress: async () => {
              originSignerObjectAddressCalls += 1;
              return SIGNER;
            },
          };
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.INTERCHAIN_ACCOUNT);
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.owner,
      ).to.equal(SIGNER);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.INTERCHAIN_ACCOUNT);
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.owner,
      ).to.equal(SIGNER);
      expect(originSignerObjectAddressCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived non-function-then signer-object getAddress getter throw fallback across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab19';
    const timelockOwnerB = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab1a';
    const proposerIca = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab1b';
    const destinationRouterAddress =
      '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab1c';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab1d';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerGetAddressGetterCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error(`origin signer unavailable for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          return {
            then: 1,
            get getAddress() {
              originSignerGetAddressGetterCalls += 1;
              throw new Error('signer object getAddress getter failed');
            },
          };
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerGetAddressGetterCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async non-function-then signer-object getAddress getter throw fallback across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab1e';
    const timelockOwnerB = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab1f';
    const proposerIca = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab20';
    const destinationRouterAddress =
      '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab21';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab22';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerGetAddressGetterCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error(`origin signer unavailable for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          return {
            then: 1,
            get getAddress() {
              originSignerGetAddressGetterCalls += 1;
              throw new Error('signer object getAddress getter failed');
            },
          };
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerGetAddressGetterCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived malformed non-function-then signer-object getAddress fallback across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab0a';
    const timelockOwnerB = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab0b';
    const proposerIca = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab0c';
    const destinationRouterAddress =
      '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab0d';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab0e';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerObjectAddressCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error(`origin signer unavailable for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          return {
            then: 1,
            getAddress: async () => {
              originSignerObjectAddressCalls += 1;
              return 'not-an-evm-address';
            },
          };
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerObjectAddressCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async malformed non-function-then signer-object getAddress fallback across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab37';
    const timelockOwnerB = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab38';
    const proposerIca = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab39';
    const destinationRouterAddress =
      '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab3a';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab3b';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerObjectAddressCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error(`origin signer unavailable for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          return {
            then: 1,
            getAddress: async () => {
              originSignerObjectAddressCalls += 1;
              return 'not-an-evm-address';
            },
          };
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerObjectAddressCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async zero non-function-then signer-object getAddress fallback across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab41';
    const timelockOwnerB = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab42';
    const proposerIca = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab43';
    const destinationRouterAddress =
      '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab44';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab45';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerObjectAddressCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error(`origin signer unavailable for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          return {
            then: 1,
            getAddress: async () => {
              originSignerObjectAddressCalls += 1;
              return ethersConstants.AddressZero;
            },
          };
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerObjectAddressCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async throwing non-function-then signer-object getAddress fallback across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab46';
    const timelockOwnerB = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab47';
    const proposerIca = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab48';
    const destinationRouterAddress =
      '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab49';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab4a';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerObjectAddressCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error(`origin signer unavailable for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          return {
            then: 1,
            getAddress: async () => {
              originSignerObjectAddressCalls += 1;
              throw new Error(
                `origin signer object address failure for ${chainName}`,
              );
            },
          };
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerObjectAddressCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived zero non-function-then signer-object getAddress fallback across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab0f';
    const timelockOwnerB = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab10';
    const proposerIca = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab11';
    const destinationRouterAddress =
      '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab12';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab13';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerObjectAddressCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error(`origin signer unavailable for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          return {
            then: 1,
            getAddress: async () => {
              originSignerObjectAddressCalls += 1;
              return ethersConstants.AddressZero;
            },
          };
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerObjectAddressCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived throwing non-function-then signer-object getAddress fallback across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab14';
    const timelockOwnerB = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab15';
    const proposerIca = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab16';
    const destinationRouterAddress =
      '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab17';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab18';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerObjectAddressCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error(`origin signer unavailable for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          return {
            then: 1,
            getAddress: async () => {
              originSignerObjectAddressCalls += 1;
              throw new Error(
                `origin signer object address failure for ${chainName}`,
              );
            },
          };
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerObjectAddressCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived malformed signer-object getAddress fallback across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaae3';
    const timelockOwnerB = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaae4';
    const proposerIca = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaae5';
    const destinationRouterAddress =
      '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaae6';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaae7';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerObjectAddressCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error(`origin signer unavailable for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          return {
            getAddress: async () => {
              originSignerObjectAddressCalls += 1;
              return 'not-an-evm-address';
            },
          };
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerObjectAddressCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async malformed signer-object getAddress fallback across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab3c';
    const timelockOwnerB = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab3d';
    const proposerIca = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab3e';
    const destinationRouterAddress =
      '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab3f';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab40';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerObjectAddressCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error(`origin signer unavailable for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          return {
            getAddress: async () => {
              originSignerObjectAddressCalls += 1;
              return 'not-an-evm-address';
            },
          };
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerObjectAddressCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async zero signer-object getAddress fallback across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab4b';
    const timelockOwnerB = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab4c';
    const proposerIca = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab4d';
    const destinationRouterAddress =
      '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab4e';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab4f';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerObjectAddressCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error(`origin signer unavailable for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          return {
            getAddress: async () => {
              originSignerObjectAddressCalls += 1;
              return ethersConstants.AddressZero;
            },
          };
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerObjectAddressCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async throwing signer-object getAddress fallback across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab50';
    const timelockOwnerB = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab51';
    const proposerIca = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab52';
    const destinationRouterAddress =
      '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab53';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab54';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerObjectAddressCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error(`origin signer unavailable for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          return {
            getAddress: async () => {
              originSignerObjectAddressCalls += 1;
              throw new Error(
                `origin signer object address failure for ${chainName}`,
              );
            },
          };
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerObjectAddressCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived zero signer-object getAddress fallback across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaae8';
    const timelockOwnerB = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaae9';
    const proposerIca = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaea';
    const destinationRouterAddress =
      '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaeb';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaec';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerObjectAddressCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error(`origin signer unavailable for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          return {
            getAddress: async () => {
              originSignerObjectAddressCalls += 1;
              return ethersConstants.AddressZero;
            },
          };
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerObjectAddressCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived throwing signer-object getAddress fallback across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaed';
    const timelockOwnerB = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaee';
    const proposerIca = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaef';
    const destinationRouterAddress =
      '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaf0';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaf1';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerObjectAddressCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error(`origin signer unavailable for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          return {
            getAddress: async () => {
              originSignerObjectAddressCalls += 1;
              throw new Error(
                `origin signer object address failure for ${chainName}`,
              );
            },
          };
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerObjectAddressCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived signer-address short-circuit over signer-object getAddress throw across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab78';
    const timelockOwnerB = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab79';
    const proposerIca = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab7a';
    const destinationRouterAddress =
      '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab7b';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab7c';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerGetAddressCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN || chainName === 'anvil3') {
            return SIGNER;
          }
          throw new Error(`unknown signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return {
            getAddress: () => {
              originSignerGetAddressCalls += 1;
              throw new Error('signer object getAddress failed');
            },
          };
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.INTERCHAIN_ACCOUNT);
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.owner,
      ).to.equal(SIGNER);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.INTERCHAIN_ACCOUNT);
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.owner,
      ).to.equal(SIGNER);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerGetAddressCalls).to.equal(0);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived signer-address short-circuit over async signer-object getAddress throw across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab7d';
    const timelockOwnerB = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab7e';
    const proposerIca = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab7f';
    const destinationRouterAddress =
      '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab80';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab81';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerGetAddressCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN || chainName === 'anvil3') {
            return SIGNER;
          }
          throw new Error(`unknown signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return {
            getAddress: async () => {
              originSignerGetAddressCalls += 1;
              throw new Error('signer object getAddress failed');
            },
          };
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.INTERCHAIN_ACCOUNT);
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.owner,
      ).to.equal(SIGNER);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.INTERCHAIN_ACCOUNT);
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.owner,
      ).to.equal(SIGNER);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerGetAddressCalls).to.equal(0);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived signer-address short-circuit over non-function-then signer-object getAddress throw across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab82';
    const timelockOwnerB = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab83';
    const proposerIca = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab84';
    const destinationRouterAddress =
      '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab85';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab86';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerGetAddressCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN || chainName === 'anvil3') {
            return SIGNER;
          }
          throw new Error(`unknown signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return {
            then: 1,
            getAddress: () => {
              originSignerGetAddressCalls += 1;
              throw new Error('signer object getAddress failed');
            },
          };
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.INTERCHAIN_ACCOUNT);
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.owner,
      ).to.equal(SIGNER);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.INTERCHAIN_ACCOUNT);
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.owner,
      ).to.equal(SIGNER);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerGetAddressCalls).to.equal(0);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived signer-address short-circuit over async non-function-then signer-object getAddress throw across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab87';
    const timelockOwnerB = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab88';
    const proposerIca = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab89';
    const destinationRouterAddress =
      '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab8a';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab8b';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerGetAddressCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN || chainName === 'anvil3') {
            return SIGNER;
          }
          throw new Error(`unknown signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return {
            then: 1,
            getAddress: async () => {
              originSignerGetAddressCalls += 1;
              throw new Error('signer object getAddress failed');
            },
          };
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.INTERCHAIN_ACCOUNT);
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.owner,
      ).to.equal(SIGNER);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.INTERCHAIN_ACCOUNT);
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.owner,
      ).to.equal(SIGNER);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerGetAddressCalls).to.equal(0);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches unavailable origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x8686868686868686868686868686868686868686';
    const timelockOwnerB = '0x8787878787878787878787878787878787878787';
    const proposerIca = '0x8888888888888888888888888888888888888888';
    const destinationRouterAddress =
      '0x8989898989898989898989898989898989898989';
    const originRouterAddress = '0x8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return null;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(0);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches undefined origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f';
    const timelockOwnerB = '0x7070707070707070707070707070707070707070';
    const proposerIca = '0x7171717171717171717171717171717171717171';
    const destinationRouterAddress =
      '0x7272727272727272727272727272727272727272';
    const originRouterAddress = '0x7373737373737373737373737373737373737373';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return undefined;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(0);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches false origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x7474747474747474747474747474747474747474';
    const timelockOwnerB = '0x7575757575757575757575757575757575757575';
    const proposerIca = '0x7676767676767676767676767676767676767676';
    const destinationRouterAddress =
      '0x7777777777777777777777777777777777777777';
    const originRouterAddress = '0x7878787878787878787878787878787878787878';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return false;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(0);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches numeric-zero origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcd';
    const timelockOwnerB = '0xcececececececececececececececececececece';
    const proposerIca = '0xcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcf';
    const destinationRouterAddress =
      '0xd0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0';
    const originRouterAddress = '0xd1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return 0;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(0);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches negative-zero origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcd';
    const timelockOwnerB = '0xcececececececececececececececececececece';
    const proposerIca = '0xcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcf';
    const destinationRouterAddress =
      '0xd0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0';
    const originRouterAddress = '0xd1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return -0;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(0);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches boxed-number-zero origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x1111111111111111111111111111111111111111';
    const timelockOwnerB = '0x1212121212121212121212121212121212121212';
    const proposerIca = '0x1313131313131313131313131313131313131313';
    const destinationRouterAddress =
      '0x1414141414141414141414141414141414141414';
    const originRouterAddress = '0x1515151515151515151515151515151515151515';

    const ownerByTarget: Record<string, string> = {
      '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa': timelockOwnerA,
      '0xbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(0);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' } as any,
          { ...TX, to: '0xbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async boxed-number-zero origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x1616161616161616161616161616161616161616';
    const timelockOwnerB = '0x1717171717171717171717171717171717171717';
    const proposerIca = '0x1818181818181818181818181818181818181818';
    const destinationRouterAddress =
      '0x1919191919191919191919191919191919191919';
    const originRouterAddress = '0x1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a';

    const ownerByTarget: Record<string, string> = {
      '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa': timelockOwnerA,
      '0xbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(0);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' } as any,
          { ...TX, to: '0xbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches boxed-number-one origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcd';
    const timelockOwnerB = '0xcececececececececececececececececececece';
    const proposerIca = '0xcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcf';
    const destinationRouterAddress =
      '0xd0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0';
    const originRouterAddress = '0xd1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1';

    const ownerByTarget: Record<string, string> = {
      '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa': timelockOwnerA,
      '0xbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(1);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' } as any,
          { ...TX, to: '0xbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async boxed-number-one origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xd2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2';
    const timelockOwnerB = '0xd3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3';
    const proposerIca = '0xd4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4';
    const destinationRouterAddress =
      '0xd5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5';
    const originRouterAddress = '0xd6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6';

    const ownerByTarget: Record<string, string> = {
      '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa': timelockOwnerA,
      '0xbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(1);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' } as any,
          { ...TX, to: '0xbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches boxed-boolean-false origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b';
    const timelockOwnerB = '0x1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c';
    const proposerIca = '0x1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d';
    const destinationRouterAddress =
      '0x1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e';
    const originRouterAddress = '0x1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f';

    const ownerByTarget: Record<string, string> = {
      '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa': timelockOwnerA,
      '0xbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(false);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' } as any,
          { ...TX, to: '0xbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async boxed-boolean-false origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x2020202020202020202020202020202020202020';
    const timelockOwnerB = '0x2121212121212121212121212121212121212121';
    const proposerIca = '0x2222222222222222222222222222222222222222';
    const destinationRouterAddress =
      '0x2323232323232323232323232323232323232323';
    const originRouterAddress = '0x2424242424242424242424242424242424242424';

    const ownerByTarget: Record<string, string> = {
      '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa': timelockOwnerA,
      '0xbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(false);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' } as any,
          { ...TX, to: '0xbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches boxed-boolean-true origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x9090909090909090909090909090909090909090';
    const timelockOwnerB = '0x9191919191919191919191919191919191919191';
    const proposerIca = '0x9292929292929292929292929292929292929292';
    const destinationRouterAddress =
      '0x9393939393939393939393939393939393939393';
    const originRouterAddress = '0x9494949494949494949494949494949494949494';

    const ownerByTarget: Record<string, string> = {
      '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa': timelockOwnerA,
      '0xbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(true);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' } as any,
          { ...TX, to: '0xbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async boxed-boolean-true origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x9595959595959595959595959595959595959595';
    const timelockOwnerB = '0x9696969696969696969696969696969696969696';
    const proposerIca = '0x9797979797979797979797979797979797979797';
    const destinationRouterAddress =
      '0x9898989898989898989898989898989898989898';
    const originRouterAddress = '0x9999999999999999999999999999999999999999';

    const ownerByTarget: Record<string, string> = {
      '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa': timelockOwnerA,
      '0xbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(true);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' } as any,
          { ...TX, to: '0xbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches boxed-empty-string origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x2525252525252525252525252525252525252525';
    const timelockOwnerB = '0x2626262626262626262626262626262626262626';
    const proposerIca = '0x2727272727272727272727272727272727272727';
    const destinationRouterAddress =
      '0x2828282828282828282828282828282828282828';
    const originRouterAddress = '0x2929292929292929292929292929292929292929';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object('');
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async boxed-empty-string origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a';
    const timelockOwnerB = '0x2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b';
    const proposerIca = '0x2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c';
    const destinationRouterAddress =
      '0x2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d';
    const originRouterAddress = '0x2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object('');
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches boxed-bigint-zero origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x3434343434343434343434343434343434343434';
    const timelockOwnerB = '0x3535353535353535353535353535353535353535';
    const proposerIca = '0x3636363636363636363636363636363636363636';
    const destinationRouterAddress =
      '0x3737373737373737373737373737373737373737';
    const originRouterAddress = '0x3838383838383838383838383838383838383838';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(0n);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async boxed-bigint-zero origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a';
    const timelockOwnerB = '0x3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b';
    const proposerIca = '0x3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c';
    const destinationRouterAddress =
      '0x3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d';
    const originRouterAddress = '0x3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(0n);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches boxed-negative-infinite-number origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x5454545454545454545454545454545454545454';
    const timelockOwnerB = '0x5555555555555555555555555555555555555555';
    const proposerIca = '0x5656565656565656565656565656565656565656';
    const destinationRouterAddress =
      '0x5757575757575757575757575757575757575757';
    const originRouterAddress = '0x5858585858585858585858585858585858585858';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(Number.NEGATIVE_INFINITY);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async boxed-negative-infinite-number origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x5959595959595959595959595959595959595959';
    const timelockOwnerB = '0x5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a';
    const proposerIca = '0x5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b';
    const destinationRouterAddress =
      '0x5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c';
    const originRouterAddress = '0x5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(Number.NEGATIVE_INFINITY);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches boxed-infinite-number origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x6868686868686868686868686868686868686868';
    const timelockOwnerB = '0x6969696969696969696969696969696969696969';
    const proposerIca = '0x6a6a6a6a6a6a6a6a6a6a6a6a6a6a6a6a6a6a6a6a';
    const destinationRouterAddress =
      '0x6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b';
    const originRouterAddress = '0x6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(Number.POSITIVE_INFINITY);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async boxed-infinite-number origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d';
    const timelockOwnerB = '0x6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e';
    const proposerIca = '0x6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f';
    const destinationRouterAddress =
      '0x7070707070707070707070707070707070707070';
    const originRouterAddress = '0x7171717171717171717171717171717171717171';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(Number.POSITIVE_INFINITY);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches boxed-nan origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c';
    const timelockOwnerB = '0x7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d';
    const proposerIca = '0x7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e';
    const destinationRouterAddress =
      '0x7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f';
    const originRouterAddress = '0x8080808080808080808080808080808080808080';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(Number.NaN);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async boxed-nan origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x8181818181818181818181818181818181818181';
    const timelockOwnerB = '0x8282828282828282828282828282828282828282';
    const proposerIca = '0x8383838383838383838383838383838383838383';
    const destinationRouterAddress =
      '0x8484848484848484848484848484848484848484';
    const originRouterAddress = '0x8585858585858585858585858585858585858585';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(Number.NaN);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches bigint-zero origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xd7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7';
    const timelockOwnerB = '0xd8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8';
    const proposerIca = '0xd9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9';
    const destinationRouterAddress =
      '0xdadadadadadadadadadadadadadadadadadadada';
    const originRouterAddress = '0xdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdb';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return 0n;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(0);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches nan origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xc1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1';
    const timelockOwnerB = '0xc2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2';
    const proposerIca = '0xc3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3';
    const destinationRouterAddress =
      '0xc4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4';
    const originRouterAddress = '0xc5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Number.NaN;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(0);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches infinite-number origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xc6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6';
    const timelockOwnerB = '0xc7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7';
    const proposerIca = '0xc8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8';
    const destinationRouterAddress =
      '0xc9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9';
    const originRouterAddress = '0xcacacacacacacacacacacacacacacacacacacaca';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Number.POSITIVE_INFINITY;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async infinite-number origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcb';
    const timelockOwnerB = '0xcccccccccccccccccccccccccccccccccccccccc';
    const proposerIca = '0xcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcd';
    const destinationRouterAddress =
      '0xcececececececececececececececececececece';
    const originRouterAddress = '0xcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcf';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Number.POSITIVE_INFINITY;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches negative-infinite-number origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xe6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6';
    const timelockOwnerB = '0xe7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7';
    const proposerIca = '0xe8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8';
    const destinationRouterAddress =
      '0xe9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9';
    const originRouterAddress = '0xeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaea';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Number.NEGATIVE_INFINITY;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async negative-infinite-number origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xebebebebebebebebebebebebebebebebebebebeb';
    const timelockOwnerB = '0xecececececececececececececececececececec';
    const proposerIca = '0xedededededededededededededededededededed';
    const destinationRouterAddress =
      '0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee';
    const originRouterAddress = '0xefefefefefefefefefefefefefefefefefefefef';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Number.NEGATIVE_INFINITY;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches true origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xd6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6';
    const timelockOwnerB = '0xd7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7';
    const proposerIca = '0xd8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8';
    const destinationRouterAddress =
      '0xd9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9';
    const originRouterAddress = '0xdadadadadadadadadadadadadadadadadadadada';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return true;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async true origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdb';
    const timelockOwnerB = '0xdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdc';
    const proposerIca = '0xdddddddddddddddddddddddddddddddddddddddd';
    const destinationRouterAddress =
      '0xdededededededededededededededededededede';
    const originRouterAddress = '0xdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdf';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return true;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches non-empty-string origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xebebebebebebebebebebebebebebebebebebebeb';
    const timelockOwnerB = '0xecececececececececececececececececececec';
    const proposerIca = '0xedededededededededededededededededededed';
    const destinationRouterAddress =
      '0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee';
    const originRouterAddress = '0xefefefefefefefefefefefefefefefefefefefef';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return 'available';
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async non-empty-string origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xf0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0';
    const timelockOwnerB = '0xf1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1';
    const proposerIca = '0xf2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2';
    const destinationRouterAddress =
      '0xf3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3';
    const originRouterAddress = '0xf4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return 'available';
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches symbol origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xf5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5';
    const timelockOwnerB = '0xf6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6';
    const proposerIca = '0xf7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7';
    const destinationRouterAddress =
      '0xf8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8';
    const originRouterAddress = '0xf9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Symbol('available');
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async symbol origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xfafafafafafafafafafafafafafafafafafafafa';
    const timelockOwnerB = '0xfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfb';
    const proposerIca = '0xfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfc';
    const destinationRouterAddress =
      '0xfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfd';
    const originRouterAddress = '0xfefefefefefefefefefefefefefefefefefefefe';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Symbol('available');
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches boxed-symbol origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xb9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9';
    const timelockOwnerB = '0xbabababababababababababababababababababa';
    const proposerIca = '0xbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb';
    const destinationRouterAddress =
      '0xbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbc';
    const originRouterAddress = '0xbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbd';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(Symbol('available'));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async boxed-symbol origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xbebebebebebebebebebebebebebebebebebebebe';
    const timelockOwnerB = '0xbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbf';
    const proposerIca = '0xc0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0';
    const destinationRouterAddress =
      '0xc1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1';
    const originRouterAddress = '0xc2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(Symbol('available'));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches bigint-one origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b';
    const timelockOwnerB = '0x0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c';
    const proposerIca = '0x0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d';
    const destinationRouterAddress =
      '0x0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e';
    const originRouterAddress = '0x0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return 1n;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches boxed-bigint-one origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xa0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0';
    const timelockOwnerB = '0xa1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1';
    const proposerIca = '0xa2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2';
    const destinationRouterAddress =
      '0xa3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3';
    const originRouterAddress = '0xa4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(1n);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async boxed-bigint-one origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa';
    const timelockOwnerB = '0xabababababababababababababababababababab';
    const proposerIca = '0xacacacacacacacacacacacacacacacacacacacac';
    const destinationRouterAddress =
      '0xadadadadadadadadadadadadadadadadadadadad';
    const originRouterAddress = '0xaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeae';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(1n);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async bigint-one origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x1010101010101010101010101010101010101010';
    const timelockOwnerB = '0x1111111111111111111111111111111111111112';
    const proposerIca = '0x1212121212121212121212121212121212121212';
    const destinationRouterAddress =
      '0x1313131313131313131313131313131313131313';
    const originRouterAddress = '0x1414141414141414141414141414141414141414';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return 1n;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches empty-string origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xe6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6';
    const timelockOwnerB = '0xe7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7';
    const proposerIca = '0xe8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8';
    const destinationRouterAddress =
      '0xe9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9';
    const originRouterAddress = '0xeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaea';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return '';
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(0);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('treats async numeric-zero tryGetSigner origin probes as unavailable across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x0101010101010101010101010101010101010101';
    const timelockOwnerB = '0x0202020202020202020202020202020202020202';
    const proposerIca = '0x0303030303030303030303030303030303030303';
    const destinationRouterAddress =
      '0x0404040404040404040404040404040404040404';
    const originRouterAddress = '0x0505050505050505050505050505050505050505';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return 0;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(0);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('treats async negative-zero tryGetSigner origin probes as unavailable across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x0101010101010101010101010101010101010101';
    const timelockOwnerB = '0x0202020202020202020202020202020202020202';
    const proposerIca = '0x0303030303030303030303030303030303030303';
    const destinationRouterAddress =
      '0x0404040404040404040404040404040404040404';
    const originRouterAddress = '0x0505050505050505050505050505050505050505';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return -0;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(0);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('treats async bigint-zero tryGetSigner origin probes as unavailable across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x0606060606060606060606060606060606060606';
    const timelockOwnerB = '0x0707070707070707070707070707070707070707';
    const proposerIca = '0x0808080808080808080808080808080808080808';
    const destinationRouterAddress =
      '0x0909090909090909090909090909090909090909';
    const originRouterAddress = '0x0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return 0n;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(0);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('treats async nan tryGetSigner origin probes as unavailable across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xd1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1';
    const timelockOwnerB = '0xd2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2';
    const proposerIca = '0xd3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3';
    const destinationRouterAddress =
      '0xd4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4';
    const originRouterAddress = '0xd5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Number.NaN;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(0);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('treats async empty-string tryGetSigner origin probes as unavailable across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xf0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0';
    const timelockOwnerB = '0xf1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1';
    const proposerIca = '0xf2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2';
    const destinationRouterAddress =
      '0xf3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3';
    const originRouterAddress = '0xf4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return '';
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(0);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('treats async null tryGetSigner origin probes as unavailable across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a';
    const timelockOwnerB = '0x8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b';
    const proposerIca = '0x8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c';
    const destinationRouterAddress =
      '0x8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d';
    const originRouterAddress = '0x8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return null;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(0);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('treats async undefined tryGetSigner origin probes as unavailable across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a';
    const timelockOwnerB = '0x7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b';
    const proposerIca = '0x7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c';
    const destinationRouterAddress =
      '0x7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d';
    const originRouterAddress = '0x7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return undefined;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(0);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('treats async false tryGetSigner origin probes as unavailable across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f';
    const timelockOwnerB = '0x8080808080808080808080808080808080808080';
    const proposerIca = '0x8181818181818181818181818181818181818181';
    const destinationRouterAddress =
      '0x8282828282828282828282828282828282828282';
    const originRouterAddress = '0x8383838383838383838383838383838383838383';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return false;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(0);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches invalid origin signer-address probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x9696969696969696969696969696969696969696';
    const timelockOwnerB = '0x9797979797979797979797979797979797979797';
    const proposerIcaA = '0x9898989898989898989898989898989898989898';
    const proposerIcaB = '0x9999999999999999999999999999999999999999';
    const destinationRouterAddress =
      '0x9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a';
    const originRouterAddress = '0x9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: filter.address }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .callsFake(
        (address: string) =>
          ({
            getMinDelay: async () => 0,
            hasRole: async () => false,
            interface: {
              getEventTopic: (name: string) => name,
              parseLog: (log: any) => ({
                args: {
                  account:
                    log.data?.toLowerCase() === timelockOwnerA.toLowerCase()
                      ? proposerIcaA
                      : proposerIcaB,
                },
              }),
            },
          }) as any,
      );

    let originDerivationCalls = 0;
    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']:
              async () => {
                originDerivationCalls += 1;
                return proposerIcaA;
              },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    let providerCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          return 'not-an-evm-address';
        },
        getProvider: (chainName: string) => {
          providerCalls += 1;
          if (chainName === CHAIN) {
            return provider;
          }
          throw new Error(`unexpected provider lookup for ${chainName}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName !== CHAIN) {
            originSignerProbeCalls += 1;
          }
          return {};
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(originDerivationCalls).to.equal(0);
      expect(provider.getLogs.callCount).to.equal(6);
      expect(providerCalls).to.equal(1);
      expect(timelockStub.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches throwing origin signer-address probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x8181818181818181818181818181818181818181';
    const timelockOwnerB = '0x8282828282828282828282828282828282828282';
    const proposerIcaA = '0x8383838383838383838383838383838383838383';
    const proposerIcaB = '0x8484848484848484848484848484848484848484';
    const destinationRouterAddress =
      '0x8585858585858585858585858585858585858585';
    const originRouterAddress = '0x8686868686868686868686868686868686868686';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: filter.address }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .callsFake(
        (address: string) =>
          ({
            getMinDelay: async () => 0,
            hasRole: async () => false,
            interface: {
              getEventTopic: (name: string) => name,
              parseLog: (log: any) => ({
                args: {
                  account:
                    log.data?.toLowerCase() === timelockOwnerA.toLowerCase()
                      ? proposerIcaA
                      : proposerIcaB,
                },
              }),
            },
          }) as any,
      );

    let originDerivationCalls = 0;
    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']:
              async () => {
                originDerivationCalls += 1;
                return proposerIcaA;
              },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    let providerCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN) {
            return SIGNER;
          }
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: (chainName: string) => {
          providerCalls += 1;
          if (chainName === CHAIN) {
            return provider;
          }
          throw new Error(`unexpected provider lookup for ${chainName}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName !== CHAIN) {
            originSignerProbeCalls += 1;
          }
          return {};
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(originDerivationCalls).to.equal(0);
      expect(providerCalls).to.equal(1);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('avoids origin signer address lookup when timelock ICA origin signer is unavailable', async () => {
    const timelockOwner = '0x1010101010101010101010101010101010101010';
    const proposerIca = '0x2020202020202020202020202020202020202020';
    const destinationRouterAddress =
      '0x3030303030303030303030303030303030303030';
    const originRouterAddress = '0x4040404040404040404040404040404040404040';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => timelockOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          filter.address === timelockOwner &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => (chainName === CHAIN ? {} : null),
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerAddressLookups).to.equal(0);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('falls back to jsonRpc when timelock ICA origin signer probe throws', async () => {
    const timelockOwner = '0x7171717171717171717171717171717171717171';
    const proposerIca = '0x7272727272727272727272727272727272727272';
    const destinationRouterAddress =
      '0x7373737373737373737373737373737373737373';
    const originRouterAddress = '0x7474747474747474747474747474747474747474';

    const ownableStub = sinon.stub(Ownable__factory, 'connect').returns({
      owner: async () => timelockOwner,
    } as any);
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          filter.address === timelockOwner &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerAddressLookups = 0;
    let originSignerProbeCalls = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          throw new Error(`origin signer probe failed for ${chainName}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [TX as any, TX as any],
        context,
      });

      expect(batches).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerAddressLookups).to.equal(1);
      expect(originSignerProbeCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(3);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches throwing origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x7575757575757575757575757575757575757575';
    const timelockOwnerB = '0x7676767676767676767676767676767676767676';
    const proposerIca = '0x7777777777777777777777777777777777777777';
    const destinationRouterAddress =
      '0x7878787878787878787878787878787878787878';
    const originRouterAddress = '0x7979797979797979797979797979797979797979';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          throw new Error(`origin signer probe failed for ${chainName}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches malformed signer-address fallback when origin signer probe throws across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x6565656565656565656565656565656565656565';
    const timelockOwnerB = '0x6666666666666666666666666666666666666666';
    const proposerIcaA = '0x6767676767676767676767676767676767676767';
    const proposerIcaB = '0x6868686868686868686868686868686868686868';
    const destinationRouterAddress =
      '0x6969696969696969696969696969696969696969';
    const originRouterAddress = '0x7070707070707070707070707070707070707070';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: filter.address }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .callsFake(
        (address: string) =>
          ({
            getMinDelay: async () => 0,
            hasRole: async () => false,
            interface: {
              getEventTopic: (name: string) => name,
              parseLog: (log: any) => ({
                args: {
                  account:
                    log.data?.toLowerCase() === timelockOwnerA.toLowerCase()
                      ? proposerIcaA
                      : proposerIcaB,
                },
              }),
            },
          }) as any,
      );

    let originDerivationCalls = 0;
    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']:
              async () => {
                originDerivationCalls += 1;
                return proposerIcaA;
              },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          return 'not-an-evm-address';
        },
        getProvider: (chainName: string) => {
          if (chainName === CHAIN) {
            return provider;
          }
          throw new Error(`unexpected provider lookup for ${chainName}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          throw new Error(`origin signer probe failed for ${chainName}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(originDerivationCalls).to.equal(0);
      expect(provider.getLogs.callCount).to.equal(6);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches malformed signer-address fallback when tryGetSigner getter throws across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x9696969696969696969696969696969696969696';
    const timelockOwnerB = '0x9797979797979797979797979797979797979797';
    const proposerIcaA = '0x9898989898989898989898989898989898989898';
    const proposerIcaB = '0x9999999999999999999999999999999999999999';
    const destinationRouterAddress =
      '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa';
    const originRouterAddress = '0xbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: filter.address }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .callsFake(
        (_address: string) =>
          ({
            getMinDelay: async () => 0,
            hasRole: async () => false,
            interface: {
              getEventTopic: (name: string) => name,
              parseLog: (log: any) => ({
                args: {
                  account:
                    log.data?.toLowerCase() === timelockOwnerA.toLowerCase()
                      ? proposerIcaA
                      : proposerIcaB,
                },
              }),
            },
          }) as any,
      );

    let originDerivationCalls = 0;
    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']:
              async () => {
                originDerivationCalls += 1;
                return proposerIcaA;
              },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originTryGetSignerGetterCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          return 'not-an-evm-address';
        },
        getProvider: (chainName: string) => {
          if (chainName === CHAIN) {
            return provider;
          }
          throw new Error(`unexpected provider lookup for ${chainName}`);
        },
        get tryGetSigner() {
          originTryGetSignerGetterCalls += 1;
          throw new Error('tryGetSigner getter failed');
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originTryGetSignerGetterCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(originDerivationCalls).to.equal(0);
      expect(provider.getLogs.callCount).to.equal(6);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches zero signer-address fallback when tryGetSigner getter throws across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xacacacacacacacacacacacacacacacacacacacac';
    const timelockOwnerB = '0xadadadadadadadadadadadadadadadadadadadad';
    const proposerIcaA = '0xaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeae';
    const proposerIcaB = '0xafafafafafafafafafafafafafafafafafafafaf';
    const destinationRouterAddress =
      '0xb0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0';
    const originRouterAddress = '0xb1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: filter.address }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .callsFake(
        (_address: string) =>
          ({
            getMinDelay: async () => 0,
            hasRole: async () => false,
            interface: {
              getEventTopic: (name: string) => name,
              parseLog: (log: any) => ({
                args: {
                  account:
                    log.data?.toLowerCase() === timelockOwnerA.toLowerCase()
                      ? proposerIcaA
                      : proposerIcaB,
                },
              }),
            },
          }) as any,
      );

    let originDerivationCalls = 0;
    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']:
              async () => {
                originDerivationCalls += 1;
                return proposerIcaA;
              },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originTryGetSignerGetterCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          return ethersConstants.AddressZero;
        },
        getProvider: (chainName: string) => {
          if (chainName === CHAIN) {
            return provider;
          }
          throw new Error(`unexpected provider lookup for ${chainName}`);
        },
        get tryGetSigner() {
          originTryGetSignerGetterCalls += 1;
          throw new Error('tryGetSigner getter failed');
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originTryGetSignerGetterCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(originDerivationCalls).to.equal(0);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches throwing signer-address fallback when tryGetSigner getter throws across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xb6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6';
    const timelockOwnerB = '0xb7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7';
    const proposerIcaA = '0xb8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8';
    const proposerIcaB = '0xb9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9';
    const destinationRouterAddress =
      '0xbabababababababababababababababababababa';
    const originRouterAddress = '0xbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: filter.address }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .callsFake(
        (_address: string) =>
          ({
            getMinDelay: async () => 0,
            hasRole: async () => false,
            interface: {
              getEventTopic: (name: string) => name,
              parseLog: (log: any) => ({
                args: {
                  account:
                    log.data?.toLowerCase() === timelockOwnerA.toLowerCase()
                      ? proposerIcaA
                      : proposerIcaB,
                },
              }),
            },
          }) as any,
      );

    let originDerivationCalls = 0;
    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']:
              async () => {
                originDerivationCalls += 1;
                return proposerIcaA;
              },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originTryGetSignerGetterCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: (chainName: string) => {
          if (chainName === CHAIN) {
            return provider;
          }
          throw new Error(`unexpected provider lookup for ${chainName}`);
        },
        get tryGetSigner() {
          originTryGetSignerGetterCalls += 1;
          throw new Error('tryGetSigner getter failed');
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originTryGetSignerGetterCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(originDerivationCalls).to.equal(0);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches successful signer-address fallback when tryGetSigner getter throws across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xf9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9';
    const timelockOwnerB = '0xfafafafafafafafafafafafafafafafafafafafa';
    const proposerIca = '0xfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfb';
    const destinationRouterAddress =
      '0xfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfc';
    const originRouterAddress = '0xfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfd';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: filter.address }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .callsFake(
        (address: string) =>
          ({
            getMinDelay: async () => 0,
            hasRole: async (_role: string, account: string) =>
              account.toLowerCase() === proposerIca.toLowerCase(),
            interface: {
              getEventTopic: (name: string) => name,
              parseLog: (_log: any) => ({
                args: {
                  account: proposerIca,
                },
              }),
            },
          }) as any,
      );

    let originDerivationCalls = 0;
    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']:
              async () => {
                originDerivationCalls += 1;
                return proposerIca;
              },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originTryGetSignerGetterCalls = 0;
    const signerAddressCallsByChain: Record<string, number> = {};
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          signerAddressCallsByChain[chainName] =
            (signerAddressCallsByChain[chainName] ?? 0) + 1;
          if (chainName === CHAIN || chainName === 'anvil3') {
            return SIGNER;
          }
          throw new Error(`unknown signer lookup for ${chainName}`);
        },
        getProvider: (chainName: string) => {
          if (chainName === CHAIN || chainName === 'anvil3') {
            return provider;
          }
          throw new Error(`unexpected provider lookup for ${chainName}`);
        },
        get tryGetSigner() {
          originTryGetSignerGetterCalls += 1;
          throw new Error('tryGetSigner getter failed');
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.INTERCHAIN_ACCOUNT);
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.owner,
      ).to.equal(SIGNER);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.INTERCHAIN_ACCOUNT);
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.owner,
      ).to.equal(SIGNER);
      expect(originTryGetSignerGetterCalls).to.equal(1);
      expect(signerAddressCallsByChain[CHAIN]).to.equal(1);
      expect(signerAddressCallsByChain.anvil3).to.equal(1);
      expect(originDerivationCalls).to.equal(3);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches zero signer-address fallback when origin signer probe throws across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x7171717171717171717171717171717171717171';
    const timelockOwnerB = '0x7272727272727272727272727272727272727272';
    const proposerIcaA = '0x7373737373737373737373737373737373737373';
    const proposerIcaB = '0x7474747474747474747474747474747474747474';
    const destinationRouterAddress =
      '0x7575757575757575757575757575757575757575';
    const originRouterAddress = '0x7676767676767676767676767676767676767676';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: filter.address }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .callsFake(
        (address: string) =>
          ({
            getMinDelay: async () => 0,
            hasRole: async () => false,
            interface: {
              getEventTopic: (name: string) => name,
              parseLog: (log: any) => ({
                args: {
                  account:
                    log.data?.toLowerCase() === timelockOwnerA.toLowerCase()
                      ? proposerIcaA
                      : proposerIcaB,
                },
              }),
            },
          }) as any,
      );

    let originDerivationCalls = 0;
    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']:
              async () => {
                originDerivationCalls += 1;
                return proposerIcaA;
              },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          return ethersConstants.AddressZero;
        },
        getProvider: (chainName: string) => {
          if (chainName === CHAIN) {
            return provider;
          }
          throw new Error(`unexpected provider lookup for ${chainName}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          throw new Error(`origin signer probe failed for ${chainName}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(originDerivationCalls).to.equal(0);
      expect(provider.getLogs.callCount).to.equal(6);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches successful signer-address fallback when origin signer probe throws across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x8181818181818181818181818181818181818181';
    const timelockOwnerB = '0x8282828282828282828282828282828282828282';
    const proposerIca = '0x8383838383838383838383838383838383838383';
    const destinationRouterAddress =
      '0x8484848484848484848484848484848484848484';
    const originRouterAddress = '0x8585858585858585858585858585858585858585';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: filter.address }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .callsFake(
        (address: string) =>
          ({
            getMinDelay: async () => 0,
            hasRole: async () => false,
            interface: {
              getEventTopic: (name: string) => name,
              parseLog: (_log: any) => ({
                args: {
                  account: proposerIca,
                },
              }),
            },
          }) as any,
      );

    let originDerivationCalls = 0;
    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']:
              async () => {
                originDerivationCalls += 1;
                return proposerIca;
              },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN || chainName === 'anvil3') {
            if (chainName === 'anvil3') {
              originSignerAddressLookups += 1;
            }
            return SIGNER;
          }
          throw new Error(`unknown signer lookup for ${chainName}`);
        },
        getProvider: (chainName: string) => {
          if (chainName === CHAIN || chainName === 'anvil3') {
            return provider;
          }
          throw new Error(`unexpected provider lookup for ${chainName}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          throw new Error(`origin signer probe failed for ${chainName}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.INTERCHAIN_ACCOUNT);
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.owner,
      ).to.equal(SIGNER);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.INTERCHAIN_ACCOUNT);
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.owner,
      ).to.equal(SIGNER);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(originDerivationCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches successful async-reject signer probe fallback across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x8686868686868686868686868686868686868686';
    const timelockOwnerB = '0x8787878787878787878787878787878787878787';
    const proposerIca = '0x8888888888888888888888888888888888888888';
    const destinationRouterAddress =
      '0x8989898989898989898989898989898989898989';
    const originRouterAddress = '0x8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: filter.address }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .callsFake(
        (address: string) =>
          ({
            getMinDelay: async () => 0,
            hasRole: async () => false,
            interface: {
              getEventTopic: (name: string) => name,
              parseLog: (_log: any) => ({
                args: {
                  account: proposerIca,
                },
              }),
            },
          }) as any,
      );

    let originDerivationCalls = 0;
    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']:
              async () => {
                originDerivationCalls += 1;
                return proposerIca;
              },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN || chainName === 'anvil3') {
            if (chainName === 'anvil3') {
              originSignerAddressLookups += 1;
            }
            return SIGNER;
          }
          throw new Error(`unknown signer lookup for ${chainName}`);
        },
        getProvider: (chainName: string) => {
          if (chainName === CHAIN || chainName === 'anvil3') {
            return provider;
          }
          throw new Error(`unexpected provider lookup for ${chainName}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          throw new Error(`origin signer probe failed for ${chainName}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.INTERCHAIN_ACCOUNT);
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.owner,
      ).to.equal(SIGNER);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.INTERCHAIN_ACCOUNT);
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.owner,
      ).to.equal(SIGNER);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(originDerivationCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches malformed async-reject signer probe fallback across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f';
    const timelockOwnerB = '0x9090909090909090909090909090909090909090';
    const proposerIcaA = '0x9191919191919191919191919191919191919191';
    const proposerIcaB = '0x9292929292929292929292929292929292929292';
    const destinationRouterAddress =
      '0x9393939393939393939393939393939393939393';
    const originRouterAddress = '0x9494949494949494949494949494949494949494';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: filter.address }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .callsFake(
        (address: string) =>
          ({
            getMinDelay: async () => 0,
            hasRole: async () => false,
            interface: {
              getEventTopic: (name: string) => name,
              parseLog: (log: any) => ({
                args: {
                  account:
                    log.data?.toLowerCase() === timelockOwnerA.toLowerCase()
                      ? proposerIcaA
                      : proposerIcaB,
                },
              }),
            },
          }) as any,
      );

    let originDerivationCalls = 0;
    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']:
              async () => {
                originDerivationCalls += 1;
                return proposerIcaA;
              },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          return 'not-an-evm-address';
        },
        getProvider: (chainName: string) => {
          if (chainName === CHAIN) {
            return provider;
          }
          throw new Error(`unexpected provider lookup for ${chainName}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          throw new Error(`origin signer probe failed for ${chainName}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(originDerivationCalls).to.equal(0);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches zero-address async-reject signer probe fallback across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x9595959595959595959595959595959595959595';
    const timelockOwnerB = '0x9696969696969696969696969696969696969696';
    const proposerIcaA = '0x9797979797979797979797979797979797979797';
    const proposerIcaB = '0x9898989898989898989898989898989898989898';
    const destinationRouterAddress =
      '0x9999999999999999999999999999999999999999';
    const originRouterAddress = '0xa0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: filter.address }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .callsFake(
        (address: string) =>
          ({
            getMinDelay: async () => 0,
            hasRole: async () => false,
            interface: {
              getEventTopic: (name: string) => name,
              parseLog: (log: any) => ({
                args: {
                  account:
                    log.data?.toLowerCase() === timelockOwnerA.toLowerCase()
                      ? proposerIcaA
                      : proposerIcaB,
                },
              }),
            },
          }) as any,
      );

    let originDerivationCalls = 0;
    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']:
              async () => {
                originDerivationCalls += 1;
                return proposerIcaA;
              },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          return ethersConstants.AddressZero;
        },
        getProvider: (chainName: string) => {
          if (chainName === CHAIN) {
            return provider;
          }
          throw new Error(`unexpected provider lookup for ${chainName}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          throw new Error(`origin signer probe failed for ${chainName}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(originDerivationCalls).to.equal(0);
      expect(provider.getLogs.callCount).to.equal(6);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches throwing async-reject signer probe fallback across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xa1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1';
    const timelockOwnerB = '0xa2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2';
    const proposerIcaA = '0xa3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3';
    const proposerIcaB = '0xa4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4';
    const destinationRouterAddress =
      '0xa5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5';
    const originRouterAddress = '0xa6a6a6a6a6a6a6a6a6a6a6a6a6a6a6a6a6a6a6a6';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: filter.address }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .callsFake(
        (address: string) =>
          ({
            getMinDelay: async () => 0,
            hasRole: async () => false,
            interface: {
              getEventTopic: (name: string) => name,
              parseLog: (log: any) => ({
                args: {
                  account:
                    log.data?.toLowerCase() === timelockOwnerA.toLowerCase()
                      ? proposerIcaA
                      : proposerIcaB,
                },
              }),
            },
          }) as any,
      );

    let originDerivationCalls = 0;
    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']:
              async () => {
                originDerivationCalls += 1;
                return proposerIcaA;
              },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: (chainName: string) => {
          if (chainName === CHAIN) {
            return provider;
          }
          throw new Error(`unexpected provider lookup for ${chainName}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          throw new Error(`origin signer probe failed for ${chainName}`);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(originDerivationCalls).to.equal(0);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived boxed-non-empty-string origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xf1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1';
    const timelockOwnerB = '0xf2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2';
    const proposerIca = '0xf3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3';
    const destinationRouterAddress =
      '0xf4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object('available');
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async boxed-non-empty-string origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xf6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6';
    const timelockOwnerB = '0xf7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7';
    const proposerIca = '0xf8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8';
    const destinationRouterAddress =
      '0xf9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000fafafafafafafafafafafafafafafafafafafafa';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object('available');
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches boxed-non-empty-string origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfb';
    const timelockOwnerB = '0xfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfc';
    const proposerIca = '0xfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfd';
    const destinationRouterAddress =
      '0xfefefefefefefefefefefefefefefefefefefefe';
    const originRouterAddress = '0xffffffffffffffffffffffffffffffffffffffff';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object('available');
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async boxed-non-empty-string origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xabababababababababababababababababababab';
    const timelockOwnerB = '0xacacacacacacacacacacacacacacacacacacacac';
    const proposerIca = '0xadadadadadadadadadadadadadadadadadadadad';
    const destinationRouterAddress =
      '0xaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeae';
    const originRouterAddress = '0xafafafafafafafafafafafafafafafafafafafaf';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object('available');
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived boxed-negative-bigint-one origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xb0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0';
    const timelockOwnerB = '0xb1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1';
    const proposerIca = '0xb2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2';
    const destinationRouterAddress =
      '0xb3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(-1n);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async boxed-negative-bigint-one origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xb5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5';
    const timelockOwnerB = '0xb6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6';
    const proposerIca = '0xb7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7';
    const destinationRouterAddress =
      '0xb8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(-1n);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches boxed-negative-bigint-one origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xbabababababababababababababababababababa';
    const timelockOwnerB = '0xbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb';
    const proposerIca = '0xbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbc';
    const destinationRouterAddress =
      '0xbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbd';
    const originRouterAddress = '0xbebebebebebebebebebebebebebebebebebebebe';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(-1n);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async boxed-negative-bigint-one origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xc0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0';
    const timelockOwnerB = '0xc1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1';
    const proposerIca = '0xc2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2';
    const destinationRouterAddress =
      '0xc3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3';
    const originRouterAddress = '0xc4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(-1n);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived boxed-negative-number-one origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xc5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5';
    const timelockOwnerB = '0xc6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6';
    const proposerIca = '0xc7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7';
    const destinationRouterAddress =
      '0xc8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(-1);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async boxed-negative-number-one origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xcacacacacacacacacacacacacacacacacacacaca';
    const timelockOwnerB = '0xcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcb';
    const proposerIca = '0xcccccccccccccccccccccccccccccccccccccccc';
    const destinationRouterAddress =
      '0xcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcd';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000cececececececececececececececececececece';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(-1);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches boxed-negative-number-one origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcf';
    const timelockOwnerB = '0xd0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0';
    const proposerIca = '0xd1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1';
    const destinationRouterAddress =
      '0xd2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2';
    const originRouterAddress = '0xd3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(-1);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async boxed-negative-number-one origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xd4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4';
    const timelockOwnerB = '0xd5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5';
    const proposerIca = '0xd6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6';
    const destinationRouterAddress =
      '0xd7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7';
    const originRouterAddress = '0xd8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(-1);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived boxed-negative-zero origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xd9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9';
    const timelockOwnerB = '0xdadadadadadadadadadadadadadadadadadadada';
    const proposerIca = '0xdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdb';
    const destinationRouterAddress =
      '0xdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdc';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000dddddddddddddddddddddddddddddddddddddddd';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(-0);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async boxed-negative-zero origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xdededededededededededededededededededede';
    const timelockOwnerB = '0xdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdf';
    const proposerIca = '0xe0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0';
    const destinationRouterAddress =
      '0xe1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(-0);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches boxed-negative-zero origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xe3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3';
    const timelockOwnerB = '0xe4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4';
    const proposerIca = '0xe5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5';
    const destinationRouterAddress =
      '0xe6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6';
    const originRouterAddress = '0xe7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(-0);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async boxed-negative-zero origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xe8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8';
    const timelockOwnerB = '0xe9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9';
    const proposerIca = '0xeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaea';
    const destinationRouterAddress =
      '0xebebebebebebebebebebebebebebebebebebebeb';
    const originRouterAddress = '0xecececececececececececececececececececec';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(-0);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived boxed-fractional-number origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xedededededededededededededededededededed';
    const timelockOwnerB = '0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee';
    const proposerIca = '0xefefefefefefefefefefefefefefefefefefefef';
    const destinationRouterAddress =
      '0xf0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(0.5);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async boxed-fractional-number origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xf2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2';
    const timelockOwnerB = '0xf3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3';
    const proposerIca = '0xf4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4';
    const destinationRouterAddress =
      '0xf5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(0.5);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches boxed-fractional-number origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xf7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7';
    const timelockOwnerB = '0xf8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8';
    const proposerIca = '0xf9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9';
    const destinationRouterAddress =
      '0xfafafafafafafafafafafafafafafafafafafafa';
    const originRouterAddress = '0xfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfb';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(0.5);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async boxed-fractional-number origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfc';
    const timelockOwnerB = '0xfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfd';
    const proposerIca = '0xfefefefefefefefefefefefefefefefefefefefe';
    const destinationRouterAddress =
      '0xffffffffffffffffffffffffffffffffffffffff';
    const originRouterAddress = '0xabababababababababababababababababababab';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(0.5);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived boxed-unsafe-integer-number origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xacacacacacacacacacacacacacacacacacacacac';
    const timelockOwnerB = '0xadadadadadadadadadadadadadadadadadadadad';
    const proposerIca = '0xaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeae';
    const destinationRouterAddress =
      '0xafafafafafafafafafafafafafafafafafafafaf';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(Number.MAX_SAFE_INTEGER + 1);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async boxed-unsafe-integer-number origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xb1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1';
    const timelockOwnerB = '0xb2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2';
    const proposerIca = '0xb3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3';
    const destinationRouterAddress =
      '0xb4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(Number.MAX_SAFE_INTEGER + 1);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches boxed-unsafe-integer-number origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xb6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6';
    const timelockOwnerB = '0xb7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7';
    const proposerIca = '0xb8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8';
    const destinationRouterAddress =
      '0xb9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9';
    const originRouterAddress = '0xbabababababababababababababababababababa';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(Number.MAX_SAFE_INTEGER + 1);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async boxed-unsafe-integer-number origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb';
    const timelockOwnerB = '0xbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbc';
    const proposerIca = '0xbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbd';
    const destinationRouterAddress =
      '0xbebebebebebebebebebebebebebebebebebebebe';
    const originRouterAddress = '0xbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbf';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(Number.MAX_SAFE_INTEGER + 1);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived boxed-whitespace-string origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xc0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0';
    const timelockOwnerB = '0xc1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1';
    const proposerIca = '0xc2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2';
    const destinationRouterAddress =
      '0xc3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object('   ');
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async boxed-whitespace-string origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xc5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5';
    const timelockOwnerB = '0xc6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6';
    const proposerIca = '0xc7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7';
    const destinationRouterAddress =
      '0xc8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object('   ');
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches boxed-whitespace-string origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xcacacacacacacacacacacacacacacacacacacaca';
    const timelockOwnerB = '0xcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcb';
    const proposerIca = '0xcccccccccccccccccccccccccccccccccccccccc';
    const destinationRouterAddress =
      '0xcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcd';
    const originRouterAddress = '0xcececececececececececececececececececece';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object('   ');
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async boxed-whitespace-string origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcf';
    const timelockOwnerB = '0xd0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0';
    const proposerIca = '0xd1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1';
    const destinationRouterAddress =
      '0xd2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2';
    const originRouterAddress = '0xd3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object('   ');
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived null-prototype object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xd4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4';
    const timelockOwnerB = '0xd5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5';
    const proposerIca = '0xd6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6';
    const destinationRouterAddress =
      '0xd7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object.create(null);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async null-prototype object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xd9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9';
    const timelockOwnerB = '0xdadadadadadadadadadadadadadadadadadadada';
    const proposerIca = '0xdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdb';
    const destinationRouterAddress =
      '0xdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdc';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000dddddddddddddddddddddddddddddddddddddddd';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object.create(null);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches null-prototype object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xdededededededededededededededededededede';
    const timelockOwnerB = '0xdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdf';
    const proposerIca = '0xe0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0';
    const destinationRouterAddress =
      '0xe1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1';
    const originRouterAddress = '0xe2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object.create(null);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async null-prototype object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xe3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3';
    const timelockOwnerB = '0xe4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4';
    const proposerIca = '0xe5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5';
    const destinationRouterAddress =
      '0xe6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6';
    const originRouterAddress = '0xe7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object.create(null);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived array-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xe8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8';
    const timelockOwnerB = '0xe9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9';
    const proposerIca = '0xeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaea';
    const destinationRouterAddress =
      '0xebebebebebebebebebebebebebebebebebebebeb';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000ecececececececececececececececececececec';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object([]);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async array-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xedededededededededededededededededededed';
    const timelockOwnerB = '0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee';
    const proposerIca = '0xefefefefefefefefefefefefefefefefefefefef';
    const destinationRouterAddress =
      '0xf0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object([]);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches array-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xf2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2';
    const timelockOwnerB = '0xf3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3';
    const proposerIca = '0xf4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4';
    const destinationRouterAddress =
      '0xf5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5';
    const originRouterAddress = '0xf6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object([]);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async array-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xf7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7';
    const timelockOwnerB = '0xf8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8';
    const proposerIca = '0xf9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9';
    const destinationRouterAddress =
      '0xfafafafafafafafafafafafafafafafafafafafa';
    const originRouterAddress = '0xfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfb';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object([]);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived date-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfc';
    const timelockOwnerB = '0xfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfd';
    const proposerIca = '0xfefefefefefefefefefefefefefefefefefefefe';
    const destinationRouterAddress =
      '0xffffffffffffffffffffffffffffffffffffffff';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000abababababababababababababababababababab';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Date(0));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async date-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xacacacacacacacacacacacacacacacacacacacac';
    const timelockOwnerB = '0xadadadadadadadadadadadadadadadadadadadad';
    const proposerIca = '0xaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeae';
    const destinationRouterAddress =
      '0xafafafafafafafafafafafafafafafafafafafaf';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Date(0));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches date-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xb1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1';
    const timelockOwnerB = '0xb2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2';
    const proposerIca = '0xb3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3';
    const destinationRouterAddress =
      '0xb4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4';
    const originRouterAddress = '0xb5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Date(0));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async date-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xb6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6';
    const timelockOwnerB = '0xb7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7';
    const proposerIca = '0xb8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8';
    const destinationRouterAddress =
      '0xb9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9';
    const originRouterAddress = '0xbabababababababababababababababababababa';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Date(0));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived regexp-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xcacacacacacacacacacacacacacacacacacacaca';
    const timelockOwnerB = '0xcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcb';
    const proposerIca = '0xcccccccccccccccccccccccccccccccccccccccc';
    const destinationRouterAddress =
      '0xcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcd';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000cececececececececececececececececececece';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(/available/);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async regexp-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcf';
    const timelockOwnerB = '0xd0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0';
    const proposerIca = '0xd1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1';
    const destinationRouterAddress =
      '0xd2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(/available/);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches regexp-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xd4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4';
    const timelockOwnerB = '0xd5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5';
    const proposerIca = '0xd6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6';
    const destinationRouterAddress =
      '0xd7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7';
    const originRouterAddress = '0xd8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(/available/);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async regexp-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xd9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9';
    const timelockOwnerB = '0xdadadadadadadadadadadadadadadadadadadada';
    const proposerIca = '0xdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdb';
    const destinationRouterAddress =
      '0xdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdc';
    const originRouterAddress = '0xdddddddddddddddddddddddddddddddddddddddd';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(/available/);
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived map-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xdededededededededededededededededededede';
    const timelockOwnerB = '0xdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdf';
    const proposerIca = '0xe0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0';
    const destinationRouterAddress =
      '0xe1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Map([['available', true]]));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async map-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xe3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3';
    const timelockOwnerB = '0xe4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4';
    const proposerIca = '0xe5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5';
    const destinationRouterAddress =
      '0xe6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Map([['available', true]]));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches map-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xe8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8';
    const timelockOwnerB = '0xe9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9';
    const proposerIca = '0xeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaea';
    const destinationRouterAddress =
      '0xebebebebebebebebebebebebebebebebebebebeb';
    const originRouterAddress = '0xecececececececececececececececececececec';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Map([['available', true]]));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async map-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xedededededededededededededededededededed';
    const timelockOwnerB = '0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee';
    const proposerIca = '0xefefefefefefefefefefefefefefefefefefefef';
    const destinationRouterAddress =
      '0xf0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0';
    const originRouterAddress = '0xf1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Map([['available', true]]));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived set-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xf2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2';
    const timelockOwnerB = '0xf3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3';
    const proposerIca = '0xf4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4';
    const destinationRouterAddress =
      '0xf5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Set(['available']));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async set-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xf7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7';
    const timelockOwnerB = '0xf8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8';
    const proposerIca = '0xf9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9';
    const destinationRouterAddress =
      '0xfafafafafafafafafafafafafafafafafafafafa';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000fbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfb';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Set(['available']));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches set-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfc';
    const timelockOwnerB = '0xfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfd';
    const proposerIca = '0xfefefefefefefefefefefefefefefefefefefefe';
    const destinationRouterAddress =
      '0xffffffffffffffffffffffffffffffffffffffff';
    const originRouterAddress = '0xabababababababababababababababababababab';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Set(['available']));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async set-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xacacacacacacacacacacacacacacacacacacacac';
    const timelockOwnerB = '0xadadadadadadadadadadadadadadadadadadadad';
    const proposerIca = '0xaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeae';
    const destinationRouterAddress =
      '0xafafafafafafafafafafafafafafafafafafafaf';
    const originRouterAddress = '0xb0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Set(['available']));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived weakmap-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xb1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1';
    const timelockOwnerB = '0xb2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2';
    const proposerIca = '0xb3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3';
    const destinationRouterAddress =
      '0xb4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new WeakMap([[{}, true]]));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async weakmap-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xb6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6';
    const timelockOwnerB = '0xb7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7';
    const proposerIca = '0xb8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8';
    const destinationRouterAddress =
      '0xb9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000babababababababababababababababababababa';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new WeakMap([[{}, true]]));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches weakmap-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb';
    const timelockOwnerB = '0xbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbc';
    const proposerIca = '0xbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbd';
    const destinationRouterAddress =
      '0xbebebebebebebebebebebebebebebebebebebebe';
    const originRouterAddress = '0xbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbf';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new WeakMap([[{}, true]]));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async weakmap-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xc0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0';
    const timelockOwnerB = '0xc1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1';
    const proposerIca = '0xc2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2';
    const destinationRouterAddress =
      '0xc3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3';
    const originRouterAddress = '0xc4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new WeakMap([[{}, true]]));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived weakset-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xc5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5';
    const timelockOwnerB = '0xc6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6';
    const proposerIca = '0xc7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7';
    const destinationRouterAddress =
      '0xc8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new WeakSet([{}]));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async weakset-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xcacacacacacacacacacacacacacacacacacacaca';
    const timelockOwnerB = '0xcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcb';
    const proposerIca = '0xcccccccccccccccccccccccccccccccccccccccc';
    const destinationRouterAddress =
      '0xcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcd';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000cececececececececececececececececececece';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new WeakSet([{}]));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches weakset-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xc5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5';
    const timelockOwnerB = '0xc6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6';
    const proposerIca = '0xc7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7';
    const destinationRouterAddress =
      '0xc8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8';
    const originRouterAddress = '0xc9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new WeakSet([{}]));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async weakset-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xcacacacacacacacacacacacacacacacacacacaca';
    const timelockOwnerB = '0xcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcb';
    const proposerIca = '0xcccccccccccccccccccccccccccccccccccccccc';
    const destinationRouterAddress =
      '0xcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcd';
    const originRouterAddress = '0xcececececececececececececececececececece';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new WeakSet([{}]));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived uint8array-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcf';
    const timelockOwnerB = '0xd0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0';
    const proposerIca = '0xd1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1';
    const destinationRouterAddress =
      '0xd2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Uint8Array([1]));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async uint8array-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xd4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4';
    const timelockOwnerB = '0xd5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5';
    const proposerIca = '0xd6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6';
    const destinationRouterAddress =
      '0xd7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Uint8Array([1]));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches uint8array-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xd9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9';
    const timelockOwnerB = '0xdadadadadadadadadadadadadadadadadadadada';
    const proposerIca = '0xdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdb';
    const destinationRouterAddress =
      '0xdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdc';
    const originRouterAddress = '0xdddddddddddddddddddddddddddddddddddddddd';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Uint8Array([1]));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async uint8array-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xdededededededededededededededededededede';
    const timelockOwnerB = '0xdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdf';
    const proposerIca = '0xe0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0';
    const destinationRouterAddress =
      '0xe1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1';
    const originRouterAddress = '0xe2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Uint8Array([1]));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived arraybuffer-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcf';
    const timelockOwnerB = '0xd0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0';
    const proposerIca = '0xd1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1';
    const destinationRouterAddress =
      '0xd2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new ArrayBuffer(1));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async arraybuffer-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xd4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4';
    const timelockOwnerB = '0xd5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5';
    const proposerIca = '0xd6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6';
    const destinationRouterAddress =
      '0xd7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new ArrayBuffer(1));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches arraybuffer-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xd9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9';
    const timelockOwnerB = '0xdadadadadadadadadadadadadadadadadadadada';
    const proposerIca = '0xdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdb';
    const destinationRouterAddress =
      '0xdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdc';
    const originRouterAddress = '0xdddddddddddddddddddddddddddddddddddddddd';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new ArrayBuffer(1));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async arraybuffer-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xdededededededededededededededededededede';
    const timelockOwnerB = '0xdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdf';
    const proposerIca = '0xe0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0';
    const destinationRouterAddress =
      '0xe1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1';
    const originRouterAddress = '0xe2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new ArrayBuffer(1));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived dataview-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcf';
    const timelockOwnerB = '0xd0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0';
    const proposerIca = '0xd1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1';
    const destinationRouterAddress =
      '0xd2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new DataView(new ArrayBuffer(1)));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async dataview-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xd4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4';
    const timelockOwnerB = '0xd5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5';
    const proposerIca = '0xd6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6';
    const destinationRouterAddress =
      '0xd7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new DataView(new ArrayBuffer(1)));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches dataview-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xd9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9';
    const timelockOwnerB = '0xdadadadadadadadadadadadadadadadadadadada';
    const proposerIca = '0xdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdb';
    const destinationRouterAddress =
      '0xdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdc';
    const originRouterAddress = '0xdddddddddddddddddddddddddddddddddddddddd';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new DataView(new ArrayBuffer(1)));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async dataview-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xdededededededededededededededededededede';
    const timelockOwnerB = '0xdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdf';
    const proposerIca = '0xe0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0';
    const destinationRouterAddress =
      '0xe1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1';
    const originRouterAddress = '0xe2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new DataView(new ArrayBuffer(1)));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived error-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcf';
    const timelockOwnerB = '0xd0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0';
    const proposerIca = '0xd1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1';
    const destinationRouterAddress =
      '0xd2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Error('available'));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async error-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xd4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4';
    const timelockOwnerB = '0xd5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5';
    const proposerIca = '0xd6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6';
    const destinationRouterAddress =
      '0xd7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Error('available'));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches error-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xd9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9';
    const timelockOwnerB = '0xdadadadadadadadadadadadadadadadadadadada';
    const proposerIca = '0xdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdb';
    const destinationRouterAddress =
      '0xdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdc';
    const originRouterAddress = '0xdddddddddddddddddddddddddddddddddddddddd';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Error('available'));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async error-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xdededededededededededededededededededede';
    const timelockOwnerB = '0xdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdf';
    const proposerIca = '0xe0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0';
    const destinationRouterAddress =
      '0xe1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1';
    const originRouterAddress = '0xe2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Error('available'));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived function-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcf';
    const timelockOwnerB = '0xd0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0';
    const proposerIca = '0xd1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1';
    const destinationRouterAddress =
      '0xd2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(function availableSignerProbe() {});
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async function-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xd4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4';
    const timelockOwnerB = '0xd5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5';
    const proposerIca = '0xd6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6';
    const destinationRouterAddress =
      '0xd7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(function availableSignerProbe() {});
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches function-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xd9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9';
    const timelockOwnerB = '0xdadadadadadadadadadadadadadadadadadadada';
    const proposerIca = '0xdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdb';
    const destinationRouterAddress =
      '0xdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdc';
    const originRouterAddress = '0xdddddddddddddddddddddddddddddddddddddddd';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(function availableSignerProbe() {});
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async function-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xdededededededededededededededededededede';
    const timelockOwnerB = '0xdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdf';
    const proposerIca = '0xe0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0';
    const destinationRouterAddress =
      '0xe1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1';
    const originRouterAddress = '0xe2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(function availableSignerProbe() {});
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived url-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcf';
    const timelockOwnerB = '0xd0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0';
    const proposerIca = '0xd1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1';
    const destinationRouterAddress =
      '0xd2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new URL('https://hyperlane.xyz'));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async url-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xd4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4';
    const timelockOwnerB = '0xd5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5';
    const proposerIca = '0xd6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6';
    const destinationRouterAddress =
      '0xd7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new URL('https://hyperlane.xyz'));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches url-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xd9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9';
    const timelockOwnerB = '0xdadadadadadadadadadadadadadadadadadadada';
    const proposerIca = '0xdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdb';
    const destinationRouterAddress =
      '0xdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdc';
    const originRouterAddress = '0xdddddddddddddddddddddddddddddddddddddddd';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new URL('https://hyperlane.xyz'));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async url-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xdededededededededededededededededededede';
    const timelockOwnerB = '0xdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdf';
    const proposerIca = '0xe0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0';
    const destinationRouterAddress =
      '0xe1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1';
    const originRouterAddress = '0xe2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new URL('https://hyperlane.xyz'));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived promise-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcf';
    const timelockOwnerB = '0xd0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0';
    const proposerIca = '0xd1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1';
    const destinationRouterAddress =
      '0xd2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(Promise.resolve('available'));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async promise-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xd4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4';
    const timelockOwnerB = '0xd5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5';
    const proposerIca = '0xd6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6';
    const destinationRouterAddress =
      '0xd7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(Promise.resolve('available'));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches promise-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xd9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9';
    const timelockOwnerB = '0xdadadadadadadadadadadadadadadadadadadada';
    const proposerIca = '0xdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdb';
    const destinationRouterAddress =
      '0xdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdc';
    const originRouterAddress = '0xdddddddddddddddddddddddddddddddddddddddd';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(Promise.resolve('available'));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async promise-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xdededededededededededededededededededede';
    const timelockOwnerB = '0xdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdf';
    const proposerIca = '0xe0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0';
    const destinationRouterAddress =
      '0xe1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1';
    const originRouterAddress = '0xe2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(Promise.resolve('available'));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived bigint64array-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcf';
    const timelockOwnerB = '0xd0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0';
    const proposerIca = '0xd1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1';
    const destinationRouterAddress =
      '0xd2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new BigInt64Array([1n]));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async bigint64array-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xd4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4';
    const timelockOwnerB = '0xd5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5';
    const proposerIca = '0xd6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6';
    const destinationRouterAddress =
      '0xd7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new BigInt64Array([1n]));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches bigint64array-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xd9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9';
    const timelockOwnerB = '0xdadadadadadadadadadadadadadadadadadadada';
    const proposerIca = '0xdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdb';
    const destinationRouterAddress =
      '0xdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdc';
    const originRouterAddress = '0xdddddddddddddddddddddddddddddddddddddddd';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new BigInt64Array([1n]));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async bigint64array-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xdededededededededededededededededededede';
    const timelockOwnerB = '0xdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdf';
    const proposerIca = '0xe0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0';
    const destinationRouterAddress =
      '0xe1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1';
    const originRouterAddress = '0xe2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new BigInt64Array([1n]));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived biguint64array-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xe3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3';
    const timelockOwnerB = '0xe4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4';
    const proposerIca = '0xe5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5';
    const destinationRouterAddress =
      '0xe6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new BigUint64Array([1n]));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async biguint64array-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xe8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8';
    const timelockOwnerB = '0xe9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9';
    const proposerIca = '0xeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaea';
    const destinationRouterAddress =
      '0xebebebebebebebebebebebebebebebebebebebeb';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000ecececececececececececececececececececec';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new BigUint64Array([1n]));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches biguint64array-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xedededededededededededededededededededed';
    const timelockOwnerB = '0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee';
    const proposerIca = '0xefefefefefefefefefefefefefefefefefefefef';
    const destinationRouterAddress =
      '0xf0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0';
    const originRouterAddress = '0xf1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new BigUint64Array([1n]));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async biguint64array-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xf2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2';
    const timelockOwnerB = '0xf3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3';
    const proposerIca = '0xf4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4';
    const destinationRouterAddress =
      '0xf5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5';
    const originRouterAddress = '0xf6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new BigUint64Array([1n]));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived urlsearchparams-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xf7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7';
    const timelockOwnerB = '0xf8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8';
    const proposerIca = '0xf9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9';
    const destinationRouterAddress =
      '0xfafafafafafafafafafafafafafafafafafafafa';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000fbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfb';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new URLSearchParams('available=true'));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async urlsearchparams-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfc';
    const timelockOwnerB = '0xfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfd';
    const proposerIca = '0xfefefefefefefefefefefefefefefefefefefefe';
    const destinationRouterAddress =
      '0xffffffffffffffffffffffffffffffffffffffff';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000abababababababababababababababababababab';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new URLSearchParams('available=true'));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches urlsearchparams-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xacacacacacacacacacacacacacacacacacacacac';
    const timelockOwnerB = '0xadadadadadadadadadadadadadadadadadadadad';
    const proposerIca = '0xaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeae';
    const destinationRouterAddress =
      '0xafafafafafafafafafafafafafafafafafafafaf';
    const originRouterAddress = '0xb0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new URLSearchParams('available=true'));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async urlsearchparams-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xb1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1';
    const timelockOwnerB = '0xb2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2';
    const proposerIca = '0xb3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3';
    const destinationRouterAddress =
      '0xb4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4';
    const originRouterAddress = '0xb5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new URLSearchParams('available=true'));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived int8array-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xb6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6';
    const timelockOwnerB = '0xb7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7';
    const proposerIca = '0xb8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8';
    const destinationRouterAddress =
      '0xb9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000babababababababababababababababababababa';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Int8Array([1]));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async int8array-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb';
    const timelockOwnerB = '0xbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbc';
    const proposerIca = '0xbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbd';
    const destinationRouterAddress =
      '0xbebebebebebebebebebebebebebebebebebebebe';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000bfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbf';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Int8Array([1]));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches int8array-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xc0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0';
    const timelockOwnerB = '0xc1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1';
    const proposerIca = '0xc2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2';
    const destinationRouterAddress =
      '0xc3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3';
    const originRouterAddress = '0xc4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Int8Array([1]));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async int8array-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xc5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5';
    const timelockOwnerB = '0xc6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6';
    const proposerIca = '0xc7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7';
    const destinationRouterAddress =
      '0xc8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8';
    const originRouterAddress = '0xc9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Int8Array([1]));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived int16array-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xcacacacacacacacacacacacacacacacacacacaca';
    const timelockOwnerB = '0xcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcb';
    const proposerIca = '0xcccccccccccccccccccccccccccccccccccccccc';
    const destinationRouterAddress =
      '0xcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcd';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000cececececececececececececececececececece';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Int16Array([1]));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async int16array-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcf';
    const timelockOwnerB = '0xd0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0';
    const proposerIca = '0xd1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1';
    const destinationRouterAddress =
      '0xd2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Int16Array([1]));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches int16array-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xd4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4';
    const timelockOwnerB = '0xd5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5';
    const proposerIca = '0xd6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6';
    const destinationRouterAddress =
      '0xd7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7';
    const originRouterAddress = '0xd8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Int16Array([1]));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async int16array-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xd9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9';
    const timelockOwnerB = '0xdadadadadadadadadadadadadadadadadadadada';
    const proposerIca = '0xdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdb';
    const destinationRouterAddress =
      '0xdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdc';
    const originRouterAddress = '0xdddddddddddddddddddddddddddddddddddddddd';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Int16Array([1]));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived float32array-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xdededededededededededededededededededede';
    const timelockOwnerB = '0xdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdf';
    const proposerIca = '0xe0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0';
    const destinationRouterAddress =
      '0xe1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Float32Array([1]));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async float32array-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xe3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3';
    const timelockOwnerB = '0xe4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4';
    const proposerIca = '0xe5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5';
    const destinationRouterAddress =
      '0xe6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Float32Array([1]));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches float32array-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xe8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8';
    const timelockOwnerB = '0xe9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9';
    const proposerIca = '0xeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaea';
    const destinationRouterAddress =
      '0xebebebebebebebebebebebebebebebebebebebeb';
    const originRouterAddress = '0xecececececececececececececececececececec';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Float32Array([1]));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async float32array-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xedededededededededededededededededededed';
    const timelockOwnerB = '0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee';
    const proposerIca = '0xefefefefefefefefefefefefefefefefefefefef';
    const destinationRouterAddress =
      '0xf0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0';
    const originRouterAddress = '0xf1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Float32Array([1]));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived float64array-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xf2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2';
    const timelockOwnerB = '0xf3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3';
    const proposerIca = '0xf4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4';
    const destinationRouterAddress =
      '0xf5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Float64Array([1]));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async float64array-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xf7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7';
    const timelockOwnerB = '0xf8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8';
    const proposerIca = '0xf9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9';
    const destinationRouterAddress =
      '0xfafafafafafafafafafafafafafafafafafafafa';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000fbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfb';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Float64Array([1]));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches float64array-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfc';
    const timelockOwnerB = '0xfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfd';
    const proposerIca = '0xfefefefefefefefefefefefefefefefefefefefe';
    const destinationRouterAddress =
      '0xffffffffffffffffffffffffffffffffffffffff';
    const originRouterAddress = '0xabababababababababababababababababababab';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Float64Array([1]));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async float64array-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xacacacacacacacacacacacacacacacacacacacac';
    const timelockOwnerB = '0xadadadadadadadadadadadadadadadadadadadad';
    const proposerIca = '0xaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeae';
    const destinationRouterAddress =
      '0xafafafafafafafafafafafafafafafafafafafaf';
    const originRouterAddress = '0xb0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Float64Array([1]));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived uint16array-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xb1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1';
    const timelockOwnerB = '0xb2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2';
    const proposerIca = '0xb3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3';
    const destinationRouterAddress =
      '0xb4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Uint16Array([1]));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async uint16array-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xb6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6';
    const timelockOwnerB = '0xb7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7';
    const proposerIca = '0xb8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8';
    const destinationRouterAddress =
      '0xb9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000babababababababababababababababababababa';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Uint16Array([1]));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches uint16array-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb';
    const timelockOwnerB = '0xbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbc';
    const proposerIca = '0xbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbd';
    const destinationRouterAddress =
      '0xbebebebebebebebebebebebebebebebebebebebe';
    const originRouterAddress = '0xbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbf';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Uint16Array([1]));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async uint16array-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xc1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1';
    const timelockOwnerB = '0xc2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2';
    const proposerIca = '0xc3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3';
    const destinationRouterAddress =
      '0xc4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4';
    const originRouterAddress = '0xc5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Uint16Array([1]));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived uint32array-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xc6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6';
    const timelockOwnerB = '0xc7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7';
    const proposerIca = '0xc8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8';
    const destinationRouterAddress =
      '0xc9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000cacacacacacacacacacacacacacacacacacacaca';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Uint32Array([1]));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async uint32array-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcb';
    const timelockOwnerB = '0xcccccccccccccccccccccccccccccccccccccccc';
    const proposerIca = '0xcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcd';
    const destinationRouterAddress =
      '0xcececececececececececececececececececece';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000cfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcf';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Uint32Array([1]));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches uint32array-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xd0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0';
    const timelockOwnerB = '0xd1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1';
    const proposerIca = '0xd2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2';
    const destinationRouterAddress =
      '0xd3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3';
    const originRouterAddress = '0xd4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Uint32Array([1]));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async uint32array-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xd5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5';
    const timelockOwnerB = '0xd6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6';
    const proposerIca = '0xd7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7';
    const destinationRouterAddress =
      '0xd8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8';
    const originRouterAddress = '0xd9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Uint32Array([1]));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived int32array-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xdadadadadadadadadadadadadadadadadadadada';
    const timelockOwnerB = '0xdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdb';
    const proposerIca = '0xdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdc';
    const destinationRouterAddress =
      '0xdddddddddddddddddddddddddddddddddddddddd';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000dededededededededededededededededededede';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Int32Array([1]));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async int32array-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdf';
    const timelockOwnerB = '0xe0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0';
    const proposerIca = '0xe1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1';
    const destinationRouterAddress =
      '0xe2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Int32Array([1]));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches int32array-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xe4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4';
    const timelockOwnerB = '0xe5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5';
    const proposerIca = '0xe6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6';
    const destinationRouterAddress =
      '0xe7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7';
    const originRouterAddress = '0xe8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Int32Array([1]));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async int32array-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xe9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9';
    const timelockOwnerB = '0xeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaea';
    const proposerIca = '0xebebebebebebebebebebebebebebebebebebebeb';
    const destinationRouterAddress =
      '0xecececececececececececececececececececec';
    const originRouterAddress = '0xedededededededededededededededededededed';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Int32Array([1]));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived uint8clampedarray-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee';
    const timelockOwnerB = '0xefefefefefefefefefefefefefefefefefefefef';
    const proposerIca = '0xf0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0';
    const destinationRouterAddress =
      '0xf1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Uint8ClampedArray([1]));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async uint8clampedarray-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xf3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3';
    const timelockOwnerB = '0xf4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4';
    const proposerIca = '0xf5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5';
    const destinationRouterAddress =
      '0xf6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Uint8ClampedArray([1]));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches uint8clampedarray-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xf8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8';
    const timelockOwnerB = '0xf9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9';
    const proposerIca = '0xfafafafafafafafafafafafafafafafafafafafa';
    const destinationRouterAddress =
      '0xfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfb';
    const originRouterAddress = '0xfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfc';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Uint8ClampedArray([1]));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async uint8clampedarray-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfd';
    const timelockOwnerB = '0xfefefefefefefefefefefefefefefefefefefefe';
    const proposerIca = '0xffffffffffffffffffffffffffffffffffffffff';
    const destinationRouterAddress =
      '0x0101010101010101010101010101010101010101';
    const originRouterAddress = '0x0202020202020202020202020202020202020202';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Uint8ClampedArray([1]));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived buffer-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x0303030303030303030303030303030303030303';
    const timelockOwnerB = '0x0404040404040404040404040404040404040404';
    const proposerIca = '0x0505050505050505050505050505050505050505';
    const destinationRouterAddress =
      '0x0606060606060606060606060606060606060606';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x0000000000000000000000000707070707070707070707070707070707070707';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(Buffer.from([1]));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async buffer-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x0808080808080808080808080808080808080808';
    const timelockOwnerB = '0x0909090909090909090909090909090909090909';
    const proposerIca = '0x0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a';
    const destinationRouterAddress =
      '0x0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x0000000000000000000000000c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(Buffer.from([1]));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches buffer-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d';
    const timelockOwnerB = '0x0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e';
    const proposerIca = '0x0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f';
    const destinationRouterAddress =
      '0x1010101010101010101010101010101010101010';
    const originRouterAddress = '0x1111111111111111111111111111111111111111';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(Buffer.from([1]));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async buffer-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x1212121212121212121212121212121212121212';
    const timelockOwnerB = '0x1313131313131313131313131313131313131313';
    const proposerIca = '0x1414141414141414141414141414141414141414';
    const destinationRouterAddress =
      '0x1515151515151515151515151515151515151515';
    const originRouterAddress = '0x1616161616161616161616161616161616161616';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(Buffer.from([1]));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived sharedarraybuffer-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x1717171717171717171717171717171717171717';
    const timelockOwnerB = '0x1818181818181818181818181818181818181818';
    const proposerIca = '0x1919191919191919191919191919191919191919';
    const destinationRouterAddress =
      '0x1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x0000000000000000000000001b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new SharedArrayBuffer(1));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async sharedarraybuffer-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c';
    const timelockOwnerB = '0x1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d';
    const proposerIca = '0x1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e';
    const destinationRouterAddress =
      '0x1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x0000000000000000000000002020202020202020202020202020202020202020';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new SharedArrayBuffer(1));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches sharedarraybuffer-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x2121212121212121212121212121212121212121';
    const timelockOwnerB = '0x2222222222222222222222222222222222222222';
    const proposerIca = '0x2323232323232323232323232323232323232323';
    const destinationRouterAddress =
      '0x2424242424242424242424242424242424242424';
    const originRouterAddress = '0x2525252525252525252525252525252525252525';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x3333333333333333333333333333333333333333': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new SharedArrayBuffer(1));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x3333333333333333333333333333333333333333' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async sharedarraybuffer-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x2626262626262626262626262626262626262626';
    const timelockOwnerB = '0x2727272727272727272727272727272727272727';
    const proposerIca = '0x2828282828282828282828282828282828282828';
    const destinationRouterAddress =
      '0x2929292929292929292929292929292929292929';
    const originRouterAddress = '0x2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x3333333333333333333333333333333333333333': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new SharedArrayBuffer(1));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x3333333333333333333333333333333333333333' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived weakref-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b';
    const timelockOwnerB = '0x2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c';
    const proposerIca = '0x2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d';
    const destinationRouterAddress =
      '0x2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x0000000000000000000000002f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new WeakRef({}));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async weakref-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x3030303030303030303030303030303030303030';
    const timelockOwnerB = '0x3131313131313131313131313131313131313131';
    const proposerIca = '0x3232323232323232323232323232323232323232';
    const destinationRouterAddress =
      '0x3333333333333333333333333333333333333333';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x0000000000000000000000003434343434343434343434343434343434343434';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new WeakRef({}));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches weakref-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x3535353535353535353535353535353535353535';
    const timelockOwnerB = '0x3636363636363636363636363636363636363636';
    const proposerIca = '0x3737373737373737373737373737373737373737';
    const destinationRouterAddress =
      '0x3838383838383838383838383838383838383838';
    const originRouterAddress = '0x3939393939393939393939393939393939393939';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x4444444444444444444444444444444444444444': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new WeakRef({}));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x4444444444444444444444444444444444444444' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async weakref-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a';
    const timelockOwnerB = '0x3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b';
    const proposerIca = '0x3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c';
    const destinationRouterAddress =
      '0x3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d';
    const originRouterAddress = '0x3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x4444444444444444444444444444444444444444': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new WeakRef({}));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x4444444444444444444444444444444444444444' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived finalizationregistry-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x4040404040404040404040404040404040404040';
    const timelockOwnerB = '0x4141414141414141414141414141414141414141';
    const proposerIca = '0x4242424242424242424242424242424242424242';
    const destinationRouterAddress =
      '0x4343434343434343434343434343434343434343';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x0000000000000000000000004444444444444444444444444444444444444444';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new FinalizationRegistry(() => undefined));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async finalizationregistry-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x4545454545454545454545454545454545454545';
    const timelockOwnerB = '0x4646464646464646464646464646464646464646';
    const proposerIca = '0x4747474747474747474747474747474747474747';
    const destinationRouterAddress =
      '0x4848484848484848484848484848484848484848';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x0000000000000000000000004949494949494949494949494949494949494949';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new FinalizationRegistry(() => undefined));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches finalizationregistry-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a';
    const timelockOwnerB = '0x4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b';
    const proposerIca = '0x4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c';
    const destinationRouterAddress =
      '0x4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d';
    const originRouterAddress = '0x4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x4444444444444444444444444444444444444444': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new FinalizationRegistry(() => undefined));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x4444444444444444444444444444444444444444' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async finalizationregistry-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f';
    const timelockOwnerB = '0x5050505050505050505050505050505050505050';
    const proposerIca = '0x5151515151515151515151515151515151515151';
    const destinationRouterAddress =
      '0x5252525252525252525252525252525252525252';
    const originRouterAddress = '0x5353535353535353535353535353535353535353';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x4444444444444444444444444444444444444444': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new FinalizationRegistry(() => undefined));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x4444444444444444444444444444444444444444' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived intl-locale-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x5454545454545454545454545454545454545454';
    const timelockOwnerB = '0x5555555555555555555555555555555555555555';
    const proposerIca = '0x5656565656565656565656565656565656565656';
    const destinationRouterAddress =
      '0x5757575757575757575757575757575757575757';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x0000000000000000000000005858585858585858585858585858585858585858';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Intl.Locale('en-US'));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async intl-locale-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x5959595959595959595959595959595959595959';
    const timelockOwnerB = '0x5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a';
    const proposerIca = '0x5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b';
    const destinationRouterAddress =
      '0x5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x0000000000000000000000005d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Intl.Locale('en-US'));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches intl-locale-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e';
    const timelockOwnerB = '0x5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f';
    const proposerIca = '0x6060606060606060606060606060606060606060';
    const destinationRouterAddress =
      '0x6161616161616161616161616161616161616161';
    const originRouterAddress = '0x6262626262626262626262626262626262626262';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x4444444444444444444444444444444444444444': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Intl.Locale('en-US'));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x4444444444444444444444444444444444444444' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async intl-locale-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x6363636363636363636363636363636363636363';
    const timelockOwnerB = '0x6464646464646464646464646464646464646464';
    const proposerIca = '0x6565656565656565656565656565656565656565';
    const destinationRouterAddress =
      '0x6666666666666666666666666666666666666666';
    const originRouterAddress = '0x6767676767676767676767676767676767676767';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x4444444444444444444444444444444444444444': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Intl.Locale('en-US'));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x4444444444444444444444444444444444444444' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived intl-numberformat-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x6868686868686868686868686868686868686868';
    const timelockOwnerB = '0x6969696969696969696969696969696969696969';
    const proposerIca = '0x6a6a6a6a6a6a6a6a6a6a6a6a6a6a6a6a6a6a6a6a';
    const destinationRouterAddress =
      '0x6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x0000000000000000000000006c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Intl.NumberFormat('en-US'));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async intl-numberformat-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d';
    const timelockOwnerB = '0x6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e';
    const proposerIca = '0x6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f';
    const destinationRouterAddress =
      '0x7070707070707070707070707070707070707070';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x0000000000000000000000007171717171717171717171717171717171717171';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Intl.NumberFormat('en-US'));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches intl-numberformat-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x7272727272727272727272727272727272727272';
    const timelockOwnerB = '0x7373737373737373737373737373737373737373';
    const proposerIca = '0x7474747474747474747474747474747474747474';
    const destinationRouterAddress =
      '0x7575757575757575757575757575757575757575';
    const originRouterAddress = '0x7676767676767676767676767676767676767676';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x4444444444444444444444444444444444444444': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Intl.NumberFormat('en-US'));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x4444444444444444444444444444444444444444' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async intl-numberformat-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x7777777777777777777777777777777777777777';
    const timelockOwnerB = '0x7878787878787878787878787878787878787878';
    const proposerIca = '0x7979797979797979797979797979797979797979';
    const destinationRouterAddress =
      '0x7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a';
    const originRouterAddress = '0x7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x4444444444444444444444444444444444444444': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Intl.NumberFormat('en-US'));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x4444444444444444444444444444444444444444' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived intl-datetimeformat-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c';
    const timelockOwnerB = '0x7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d';
    const proposerIca = '0x7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e';
    const destinationRouterAddress =
      '0x7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x0000000000000000000000008080808080808080808080808080808080808080';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Intl.DateTimeFormat('en-US'));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async intl-datetimeformat-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x8181818181818181818181818181818181818181';
    const timelockOwnerB = '0x8282828282828282828282828282828282828282';
    const proposerIca = '0x8383838383838383838383838383838383838383';
    const destinationRouterAddress =
      '0x8484848484848484848484848484848484848484';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x0000000000000000000000008585858585858585858585858585858585858585';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Intl.DateTimeFormat('en-US'));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches intl-datetimeformat-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x8686868686868686868686868686868686868686';
    const timelockOwnerB = '0x8787878787878787878787878787878787878787';
    const proposerIca = '0x8888888888888888888888888888888888888888';
    const destinationRouterAddress =
      '0x8989898989898989898989898989898989898989';
    const originRouterAddress = '0x8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x4444444444444444444444444444444444444444': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Intl.DateTimeFormat('en-US'));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x4444444444444444444444444444444444444444' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async intl-datetimeformat-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b';
    const timelockOwnerB = '0x8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c';
    const proposerIca = '0x8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d';
    const destinationRouterAddress =
      '0x8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e';
    const originRouterAddress = '0x8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x4444444444444444444444444444444444444444': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Intl.DateTimeFormat('en-US'));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x4444444444444444444444444444444444444444' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived intl-collator-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x9090909090909090909090909090909090909090';
    const timelockOwnerB = '0x9191919191919191919191919191919191919191';
    const proposerIca = '0x9292929292929292929292929292929292929292';
    const destinationRouterAddress =
      '0x9393939393939393939393939393939393939393';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x0000000000000000000000009494949494949494949494949494949494949494';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Intl.Collator('en-US'));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async intl-collator-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x9595959595959595959595959595959595959595';
    const timelockOwnerB = '0x9696969696969696969696969696969696969696';
    const proposerIca = '0x9797979797979797979797979797979797979797';
    const destinationRouterAddress =
      '0x9898989898989898989898989898989898989898';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x0000000000000000000000009999999999999999999999999999999999999999';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Intl.Collator('en-US'));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches intl-collator-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a';
    const timelockOwnerB = '0x9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b';
    const proposerIca = '0x9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c';
    const destinationRouterAddress =
      '0x9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d';
    const originRouterAddress = '0x9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x4444444444444444444444444444444444444444': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Intl.Collator('en-US'));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x4444444444444444444444444444444444444444' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async intl-collator-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f';
    const timelockOwnerB = '0xa0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0';
    const proposerIca = '0xa1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1';
    const destinationRouterAddress =
      '0xa2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2';
    const originRouterAddress = '0xa3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x4444444444444444444444444444444444444444': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Intl.Collator('en-US'));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x4444444444444444444444444444444444444444' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived intl-relativetimeformat-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xa4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4';
    const timelockOwnerB = '0xa5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5';
    const proposerIca = '0xa6a6a6a6a6a6a6a6a6a6a6a6a6a6a6a6a6a6a6a6';
    const destinationRouterAddress =
      '0xa7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a7';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Intl.RelativeTimeFormat('en-US'));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async intl-relativetimeformat-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xa9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9';
    const timelockOwnerB = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa';
    const proposerIca = '0xabababababababababababababababababababab';
    const destinationRouterAddress =
      '0xacacacacacacacacacacacacacacacacacacacac';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000adadadadadadadadadadadadadadadadadadadad';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Intl.RelativeTimeFormat('en-US'));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches intl-relativetimeformat-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeae';
    const timelockOwnerB = '0xafafafafafafafafafafafafafafafafafafafaf';
    const proposerIca = '0xb0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0';
    const destinationRouterAddress =
      '0xb1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1';
    const originRouterAddress = '0xb2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x4444444444444444444444444444444444444444': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Intl.RelativeTimeFormat('en-US'));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x4444444444444444444444444444444444444444' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async intl-relativetimeformat-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xb3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3';
    const timelockOwnerB = '0xb4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4';
    const proposerIca = '0xb5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5';
    const destinationRouterAddress =
      '0xb6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6';
    const originRouterAddress = '0xb7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x4444444444444444444444444444444444444444': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Intl.RelativeTimeFormat('en-US'));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x4444444444444444444444444444444444444444' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived intl-pluralrules-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xb8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8';
    const timelockOwnerB = '0xb9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9';
    const proposerIca = '0xbabababababababababababababababababababa';
    const destinationRouterAddress =
      '0xbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000bcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbc';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Intl.PluralRules('en-US'));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async intl-pluralrules-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbd';
    const timelockOwnerB = '0xbebebebebebebebebebebebebebebebebebebebe';
    const proposerIca = '0xbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbf';
    const destinationRouterAddress =
      '0xc0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Intl.PluralRules('en-US'));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches intl-pluralrules-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xc2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2';
    const timelockOwnerB = '0xc3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3';
    const proposerIca = '0xc4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4';
    const destinationRouterAddress =
      '0xc5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5';
    const originRouterAddress = '0xc6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x4444444444444444444444444444444444444444': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Intl.PluralRules('en-US'));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x4444444444444444444444444444444444444444' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async intl-pluralrules-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xc7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7';
    const timelockOwnerB = '0xc8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8';
    const proposerIca = '0xc9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9';
    const destinationRouterAddress =
      '0xcacacacacacacacacacacacacacacacacacacaca';
    const originRouterAddress = '0xcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcb';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x4444444444444444444444444444444444444444': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Intl.PluralRules('en-US'));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x4444444444444444444444444444444444444444' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived intl-listformat-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xcccccccccccccccccccccccccccccccccccccccc';
    const timelockOwnerB = '0xcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcd';
    const proposerIca = '0xcececececececececececececececececececece';
    const destinationRouterAddress =
      '0xcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcf';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Intl.ListFormat('en-US'));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async intl-listformat-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xd1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1';
    const timelockOwnerB = '0xd2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2';
    const proposerIca = '0xd3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3';
    const destinationRouterAddress =
      '0xd4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Intl.ListFormat('en-US'));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches intl-listformat-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xd6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6';
    const timelockOwnerB = '0xd7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7';
    const proposerIca = '0xd8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8';
    const destinationRouterAddress =
      '0xd9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9';
    const originRouterAddress = '0xdadadadadadadadadadadadadadadadadadadada';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x4444444444444444444444444444444444444444': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Intl.ListFormat('en-US'));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x4444444444444444444444444444444444444444' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async intl-listformat-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdb';
    const timelockOwnerB = '0xdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdc';
    const proposerIca = '0xdddddddddddddddddddddddddddddddddddddddd';
    const destinationRouterAddress =
      '0xdededededededededededededededededededede';
    const originRouterAddress = '0xdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdf';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x4444444444444444444444444444444444444444': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Intl.ListFormat('en-US'));
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x4444444444444444444444444444444444444444' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived intl-displaynames-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xe0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0';
    const timelockOwnerB = '0xe1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1';
    const proposerIca = '0xe2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2';
    const destinationRouterAddress =
      '0xe3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(
            new Intl.DisplayNames('en-US', {
              type: 'region',
            }),
          );
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async intl-displaynames-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xe5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5';
    const timelockOwnerB = '0xe6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6';
    const proposerIca = '0xe7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7';
    const destinationRouterAddress =
      '0xe8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(
            new Intl.DisplayNames('en-US', {
              type: 'region',
            }),
          );
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches intl-displaynames-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaea';
    const timelockOwnerB = '0xebebebebebebebebebebebebebebebebebebebeb';
    const proposerIca = '0xecececececececececececececececececececec';
    const destinationRouterAddress =
      '0xedededededededededededededededededededed';
    const originRouterAddress = '0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x4444444444444444444444444444444444444444': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(
            new Intl.DisplayNames('en-US', {
              type: 'region',
            }),
          );
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x4444444444444444444444444444444444444444' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async intl-displaynames-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xefefefefefefefefefefefefefefefefefefefef';
    const timelockOwnerB = '0xf0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0';
    const proposerIca = '0xf1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1';
    const destinationRouterAddress =
      '0xf2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2';
    const originRouterAddress = '0xf3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x4444444444444444444444444444444444444444': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(
            new Intl.DisplayNames('en-US', {
              type: 'region',
            }),
          );
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x4444444444444444444444444444444444444444' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived intl-segmenter-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xf4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4';
    const timelockOwnerB = '0xf5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5';
    const proposerIca = '0xf6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6';
    const destinationRouterAddress =
      '0xf7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(
            new Intl.Segmenter('en-US', {
              granularity: 'word',
            }),
          );
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async intl-segmenter-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xf9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9';
    const timelockOwnerB = '0xfafafafafafafafafafafafafafafafafafafafa';
    const proposerIca = '0xfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfb';
    const destinationRouterAddress =
      '0xfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfc';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000fdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfd';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(
            new Intl.Segmenter('en-US', {
              granularity: 'word',
            }),
          );
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches intl-segmenter-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xfefefefefefefefefefefefefefefefefefefefe';
    const timelockOwnerB = '0x0101010101010101010101010101010101010101';
    const proposerIca = '0x0202020202020202020202020202020202020202';
    const destinationRouterAddress =
      '0x0303030303030303030303030303030303030303';
    const originRouterAddress = '0x0404040404040404040404040404040404040404';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x4444444444444444444444444444444444444444': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(
            new Intl.Segmenter('en-US', {
              granularity: 'word',
            }),
          );
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x4444444444444444444444444444444444444444' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async intl-segmenter-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x0505050505050505050505050505050505050505';
    const timelockOwnerB = '0x0606060606060606060606060606060606060606';
    const proposerIca = '0x0707070707070707070707070707070707070707';
    const destinationRouterAddress =
      '0x0808080808080808080808080808080808080808';
    const originRouterAddress = '0x0909090909090909090909090909090909090909';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x4444444444444444444444444444444444444444': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(
            new Intl.Segmenter('en-US', {
              granularity: 'word',
            }),
          );
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x4444444444444444444444444444444444444444' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived generator-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a';
    const timelockOwnerB = '0x0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b';
    const proposerIca = '0x0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c';
    const destinationRouterAddress =
      '0x0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x0000000000000000000000000e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(
            (function* originSignerProbeGenerator() {
              yield 'origin';
            })(),
          );
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async generator-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f';
    const timelockOwnerB = '0x1010101010101010101010101010101010101010';
    const proposerIca = '0x1111111111111111111111111111111111111112';
    const destinationRouterAddress =
      '0x1212121212121212121212121212121212121212';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x0000000000000000000000001313131313131313131313131313131313131313';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(
            (function* originSignerProbeGenerator() {
              yield 'origin';
            })(),
          );
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches generator-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x1414141414141414141414141414141414141414';
    const timelockOwnerB = '0x1515151515151515151515151515151515151515';
    const proposerIca = '0x1616161616161616161616161616161616161616';
    const destinationRouterAddress =
      '0x1717171717171717171717171717171717171717';
    const originRouterAddress = '0x1818181818181818181818181818181818181818';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x4444444444444444444444444444444444444444': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(
            (function* originSignerProbeGenerator() {
              yield 'origin';
            })(),
          );
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x4444444444444444444444444444444444444444' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async generator-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x1919191919191919191919191919191919191919';
    const timelockOwnerB = '0x1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a';
    const proposerIca = '0x1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b';
    const destinationRouterAddress =
      '0x1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c';
    const originRouterAddress = '0x1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x4444444444444444444444444444444444444444': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(
            (function* originSignerProbeGenerator() {
              yield 'origin';
            })(),
          );
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x4444444444444444444444444444444444444444' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived asyncgenerator-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e';
    const timelockOwnerB = '0x1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f';
    const proposerIca = '0x2020202020202020202020202020202020202020';
    const destinationRouterAddress =
      '0x2121212121212121212121212121212121212121';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x0000000000000000000000002222222222222222222222222222222222222222';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(
            (async function* originSignerProbeAsyncGenerator() {
              yield 'origin';
            })(),
          );
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async asyncgenerator-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x2323232323232323232323232323232323232323';
    const timelockOwnerB = '0x2424242424242424242424242424242424242424';
    const proposerIca = '0x2525252525252525252525252525252525252525';
    const destinationRouterAddress =
      '0x2626262626262626262626262626262626262626';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x0000000000000000000000002727272727272727272727272727272727272727';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(
            (async function* originSignerProbeAsyncGenerator() {
              yield 'origin';
            })(),
          );
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches asyncgenerator-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x2828282828282828282828282828282828282828';
    const timelockOwnerB = '0x2929292929292929292929292929292929292929';
    const proposerIca = '0x2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a';
    const destinationRouterAddress =
      '0x2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b';
    const originRouterAddress = '0x2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x4444444444444444444444444444444444444444': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(
            (async function* originSignerProbeAsyncGenerator() {
              yield 'origin';
            })(),
          );
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x4444444444444444444444444444444444444444' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async asyncgenerator-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d';
    const timelockOwnerB = '0x2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e';
    const proposerIca = '0x2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f';
    const destinationRouterAddress =
      '0x3030303030303030303030303030303030303030';
    const originRouterAddress = '0x3131313131313131313131313131313131313131';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x4444444444444444444444444444444444444444': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(
            (async function* originSignerProbeAsyncGenerator() {
              yield 'origin';
            })(),
          );
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x4444444444444444444444444444444444444444' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived setiterator-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x3232323232323232323232323232323232323232';
    const timelockOwnerB = '0x3333333333333333333333333333333333333333';
    const proposerIca = '0x3434343434343434343434343434343434343434';
    const destinationRouterAddress =
      '0x3535353535353535353535353535353535353535';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x0000000000000000000000003636363636363636363636363636363636363636';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Set(['origin']).values());
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async setiterator-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x3737373737373737373737373737373737373737';
    const timelockOwnerB = '0x3838383838383838383838383838383838383838';
    const proposerIca = '0x3939393939393939393939393939393939393939';
    const destinationRouterAddress =
      '0x3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x0000000000000000000000003b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Set(['origin']).values());
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches setiterator-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c';
    const timelockOwnerB = '0x3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d';
    const proposerIca = '0x3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e';
    const destinationRouterAddress =
      '0x3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f';
    const originRouterAddress = '0x4040404040404040404040404040404040404040';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x4444444444444444444444444444444444444444': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Set(['origin']).values());
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x4444444444444444444444444444444444444444' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async setiterator-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x4141414141414141414141414141414141414141';
    const timelockOwnerB = '0x4242424242424242424242424242424242424242';
    const proposerIca = '0x4343434343434343434343434343434343434343';
    const destinationRouterAddress =
      '0x4444444444444444444444444444444444444445';
    const originRouterAddress = '0x4545454545454545454545454545454545454545';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x4444444444444444444444444444444444444444': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Set(['origin']).values());
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x4444444444444444444444444444444444444444' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived mapiterator-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x4646464646464646464646464646464646464646';
    const timelockOwnerB = '0x4747474747474747474747474747474747474747';
    const proposerIca = '0x4848484848484848484848484848484848484848';
    const destinationRouterAddress =
      '0x4949494949494949494949494949494949494949';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x0000000000000000000000004a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Map([['origin', 1]]).entries());
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async mapiterator-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b';
    const timelockOwnerB = '0x4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c';
    const proposerIca = '0x4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d';
    const destinationRouterAddress =
      '0x4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x0000000000000000000000004f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Map([['origin', 1]]).entries());
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches mapiterator-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x5050505050505050505050505050505050505050';
    const timelockOwnerB = '0x5151515151515151515151515151515151515151';
    const proposerIca = '0x5252525252525252525252525252525252525252';
    const destinationRouterAddress =
      '0x5353535353535353535353535353535353535353';
    const originRouterAddress = '0x5454545454545454545454545454545454545454';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x4444444444444444444444444444444444444444': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Map([['origin', 1]]).entries());
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x4444444444444444444444444444444444444444' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async mapiterator-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x5555555555555555555555555555555555555555';
    const timelockOwnerB = '0x5656565656565656565656565656565656565656';
    const proposerIca = '0x5757575757575757575757575757575757575757';
    const destinationRouterAddress =
      '0x5858585858585858585858585858585858585858';
    const originRouterAddress = '0x5959595959595959595959595959595959595959';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x4444444444444444444444444444444444444444': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Map([['origin', 1]]).entries());
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x4444444444444444444444444444444444444444' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived stringiterator-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a';
    const timelockOwnerB = '0x5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b';
    const proposerIca = '0x5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c';
    const destinationRouterAddress =
      '0x5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x0000000000000000000000005e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object('origin'[Symbol.iterator]());
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async stringiterator-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f';
    const timelockOwnerB = '0x6060606060606060606060606060606060606060';
    const proposerIca = '0x6161616161616161616161616161616161616161';
    const destinationRouterAddress =
      '0x6262626262626262626262626262626262626262';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x0000000000000000000000006363636363636363636363636363636363636363';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object('origin'[Symbol.iterator]());
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches stringiterator-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x6464646464646464646464646464646464646464';
    const timelockOwnerB = '0x6565656565656565656565656565656565656565';
    const proposerIca = '0x6666666666666666666666666666666666666666';
    const destinationRouterAddress =
      '0x6767676767676767676767676767676767676767';
    const originRouterAddress = '0x6868686868686868686868686868686868686868';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x4444444444444444444444444444444444444444': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object('origin'[Symbol.iterator]());
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x4444444444444444444444444444444444444444' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async stringiterator-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x6969696969696969696969696969696969696969';
    const timelockOwnerB = '0x6a6a6a6a6a6a6a6a6a6a6a6a6a6a6a6a6a6a6a6a';
    const proposerIca = '0x6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b';
    const destinationRouterAddress =
      '0x6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c';
    const originRouterAddress = '0x6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x4444444444444444444444444444444444444444': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object('origin'[Symbol.iterator]());
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x4444444444444444444444444444444444444444' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived arrayiterator-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e';
    const timelockOwnerB = '0x6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f';
    const proposerIca = '0x7070707070707070707070707070707070707070';
    const destinationRouterAddress =
      '0x7171717171717171717171717171717171717171';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x0000000000000000000000007272727272727272727272727272727272727272';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(['origin'][Symbol.iterator]());
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async arrayiterator-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x7373737373737373737373737373737373737373';
    const timelockOwnerB = '0x7474747474747474747474747474747474747474';
    const proposerIca = '0x7575757575757575757575757575757575757575';
    const destinationRouterAddress =
      '0x7676767676767676767676767676767676767676';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x0000000000000000000000007777777777777777777777777777777777777777';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(['origin'][Symbol.iterator]());
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches arrayiterator-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x7878787878787878787878787878787878787878';
    const timelockOwnerB = '0x7979797979797979797979797979797979797979';
    const proposerIca = '0x7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a';
    const destinationRouterAddress =
      '0x7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b';
    const originRouterAddress = '0x7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x4444444444444444444444444444444444444444': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(['origin'][Symbol.iterator]());
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x4444444444444444444444444444444444444444' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async arrayiterator-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d';
    const timelockOwnerB = '0x7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e';
    const proposerIca = '0x7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f';
    const destinationRouterAddress =
      '0x8080808080808080808080808080808080808080';
    const originRouterAddress = '0x8181818181818181818181818181818181818181';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x4444444444444444444444444444444444444444': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(['origin'][Symbol.iterator]());
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x4444444444444444444444444444444444444444' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived uint8array-iterator-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x8282828282828282828282828282828282828282';
    const timelockOwnerB = '0x8383838383838383838383838383838383838383';
    const proposerIca = '0x8484848484848484848484848484848484848484';
    const destinationRouterAddress =
      '0x8585858585858585858585858585858585858585';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x0000000000000000000000008686868686868686868686868686868686868686';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Uint8Array([1, 2])[Symbol.iterator]());
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async uint8array-iterator-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x8787878787878787878787878787878787878787';
    const timelockOwnerB = '0x8888888888888888888888888888888888888888';
    const proposerIca = '0x8989898989898989898989898989898989898989';
    const destinationRouterAddress =
      '0x8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x0000000000000000000000008b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Uint8Array([1, 2])[Symbol.iterator]());
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches uint8array-iterator-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c';
    const timelockOwnerB = '0x8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d';
    const proposerIca = '0x8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e';
    const destinationRouterAddress =
      '0x8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f';
    const originRouterAddress = '0x9090909090909090909090909090909090909090';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x4444444444444444444444444444444444444444': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Uint8Array([1, 2])[Symbol.iterator]());
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x4444444444444444444444444444444444444444' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async uint8array-iterator-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x9191919191919191919191919191919191919191';
    const timelockOwnerB = '0x9292929292929292929292929292929292929292';
    const proposerIca = '0x9393939393939393939393939393939393939393';
    const destinationRouterAddress =
      '0x9494949494949494949494949494949494949494';
    const originRouterAddress = '0x9595959595959595959595959595959595959595';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x4444444444444444444444444444444444444444': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Uint8Array([1, 2])[Symbol.iterator]());
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x4444444444444444444444444444444444444444' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived uint16array-iterator-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x9696969696969696969696969696969696969696';
    const timelockOwnerB = '0x9797979797979797979797979797979797979797';
    const proposerIca = '0x9898989898989898989898989898989898989898';
    const destinationRouterAddress =
      '0x9999999999999999999999999999999999999999';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x0000000000000000000000009a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Uint16Array([1, 2])[Symbol.iterator]());
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async uint16array-iterator-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b';
    const timelockOwnerB = '0x9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c';
    const proposerIca = '0x9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d';
    const destinationRouterAddress =
      '0x9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x0000000000000000000000009f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Uint16Array([1, 2])[Symbol.iterator]());
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches uint16array-iterator-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xa0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0';
    const timelockOwnerB = '0xa1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1';
    const proposerIca = '0xa2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2';
    const destinationRouterAddress =
      '0xa3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3';
    const originRouterAddress = '0xa4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x4444444444444444444444444444444444444444': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Uint16Array([1, 2])[Symbol.iterator]());
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x4444444444444444444444444444444444444444' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async uint16array-iterator-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xa5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5';
    const timelockOwnerB = '0xa6a6a6a6a6a6a6a6a6a6a6a6a6a6a6a6a6a6a6a6';
    const proposerIca = '0xa7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a7';
    const destinationRouterAddress =
      '0xa8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8';
    const originRouterAddress = '0xa9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x4444444444444444444444444444444444444444': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Uint16Array([1, 2])[Symbol.iterator]());
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x4444444444444444444444444444444444444444' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived uint32array-iterator-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa';
    const timelockOwnerB = '0xabababababababababababababababababababab';
    const proposerIca = '0xacacacacacacacacacacacacacacacacacacacac';
    const destinationRouterAddress =
      '0xadadadadadadadadadadadadadadadadadadadad';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000aeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeae';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Uint32Array([1, 2])[Symbol.iterator]());
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async uint32array-iterator-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xafafafafafafafafafafafafafafafafafafafaf';
    const timelockOwnerB = '0xb0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0';
    const proposerIca = '0xb1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1';
    const destinationRouterAddress =
      '0xb2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Uint32Array([1, 2])[Symbol.iterator]());
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches uint32array-iterator-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xb4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4';
    const timelockOwnerB = '0xb5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5';
    const proposerIca = '0xb6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6';
    const destinationRouterAddress =
      '0xb7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7';
    const originRouterAddress = '0xb8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x4444444444444444444444444444444444444444': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Uint32Array([1, 2])[Symbol.iterator]());
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x4444444444444444444444444444444444444444' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async uint32array-iterator-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xb9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9';
    const timelockOwnerB = '0xbabababababababababababababababababababa';
    const proposerIca = '0xbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb';
    const destinationRouterAddress =
      '0xbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbc';
    const originRouterAddress = '0xbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbd';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x4444444444444444444444444444444444444444': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Uint32Array([1, 2])[Symbol.iterator]());
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x4444444444444444444444444444444444444444' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived int8array-iterator-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xc0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0';
    const timelockOwnerB = '0xc1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1';
    const proposerIca = '0xc2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2';
    const destinationRouterAddress =
      '0xc3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Int8Array([1, 2])[Symbol.iterator]());
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async int8array-iterator-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xc5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5';
    const timelockOwnerB = '0xc6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6';
    const proposerIca = '0xc7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7';
    const destinationRouterAddress =
      '0xc8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Int8Array([1, 2])[Symbol.iterator]());
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches int8array-iterator-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xcacacacacacacacacacacacacacacacacacacaca';
    const timelockOwnerB = '0xcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcb';
    const proposerIca = '0xcccccccccccccccccccccccccccccccccccccccc';
    const destinationRouterAddress =
      '0xcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcd';
    const originRouterAddress = '0xcececececececececececececececececececece';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x4444444444444444444444444444444444444444': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Int8Array([1, 2])[Symbol.iterator]());
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x4444444444444444444444444444444444444444' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async int8array-iterator-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcf';
    const timelockOwnerB = '0xd0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0';
    const proposerIca = '0xd1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1';
    const destinationRouterAddress =
      '0xd2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2';
    const originRouterAddress = '0xd3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x4444444444444444444444444444444444444444': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Int8Array([1, 2])[Symbol.iterator]());
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x4444444444444444444444444444444444444444' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived int16array-iterator-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xd4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4';
    const timelockOwnerB = '0xd5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5';
    const proposerIca = '0xd6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6';
    const destinationRouterAddress =
      '0xd7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Int16Array([1, 2])[Symbol.iterator]());
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async int16array-iterator-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xd9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9';
    const timelockOwnerB = '0xdadadadadadadadadadadadadadadadadadadada';
    const proposerIca = '0xdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdb';
    const destinationRouterAddress =
      '0xdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdc';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000dddddddddddddddddddddddddddddddddddddddd';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Int16Array([1, 2])[Symbol.iterator]());
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches int16array-iterator-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xdededededededededededededededededededede';
    const timelockOwnerB = '0xdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdf';
    const proposerIca = '0xe0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0';
    const destinationRouterAddress =
      '0xe1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1';
    const originRouterAddress = '0xe2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x4444444444444444444444444444444444444444': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Int16Array([1, 2])[Symbol.iterator]());
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x4444444444444444444444444444444444444444' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async int16array-iterator-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xe3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3';
    const timelockOwnerB = '0xe4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4';
    const proposerIca = '0xe5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5';
    const destinationRouterAddress =
      '0xe6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6';
    const originRouterAddress = '0xe7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x4444444444444444444444444444444444444444': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Int16Array([1, 2])[Symbol.iterator]());
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x4444444444444444444444444444444444444444' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived int32array-iterator-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xe8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8';
    const timelockOwnerB = '0xe9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9';
    const proposerIca = '0xeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaea';
    const destinationRouterAddress =
      '0xebebebebebebebebebebebebebebebebebebebeb';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000ecececececececececececececececececececec';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Int32Array([1, 2])[Symbol.iterator]());
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async int32array-iterator-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xedededededededededededededededededededed';
    const timelockOwnerB = '0xefefefefefefefefefefefefefefefefefefefef';
    const proposerIca = '0xf0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0';
    const destinationRouterAddress =
      '0xf1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Int32Array([1, 2])[Symbol.iterator]());
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches int32array-iterator-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xf3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3';
    const timelockOwnerB = '0xf4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4';
    const proposerIca = '0xf5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5';
    const destinationRouterAddress =
      '0xf6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6';
    const originRouterAddress = '0xf7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x4444444444444444444444444444444444444444': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Int32Array([1, 2])[Symbol.iterator]());
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x4444444444444444444444444444444444444444' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async int32array-iterator-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xf8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8';
    const timelockOwnerB = '0xf9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9';
    const proposerIca = '0xfafafafafafafafafafafafafafafafafafafafa';
    const destinationRouterAddress =
      '0xfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfb';
    const originRouterAddress = '0xfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfc';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x4444444444444444444444444444444444444444': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Int32Array([1, 2])[Symbol.iterator]());
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x4444444444444444444444444444444444444444' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived float32array-iterator-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x0101010101010101010101010101010101010101';
    const timelockOwnerB = '0x0202020202020202020202020202020202020202';
    const proposerIca = '0x0303030303030303030303030303030303030303';
    const destinationRouterAddress =
      '0x0404040404040404040404040404040404040404';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x0000000000000000000000000505050505050505050505050505050505050505';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Float32Array([1, 2])[Symbol.iterator]());
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async float32array-iterator-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x0606060606060606060606060606060606060606';
    const timelockOwnerB = '0x0707070707070707070707070707070707070707';
    const proposerIca = '0x0808080808080808080808080808080808080808';
    const destinationRouterAddress =
      '0x0909090909090909090909090909090909090909';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x0000000000000000000000000a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Float32Array([1, 2])[Symbol.iterator]());
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches float32array-iterator-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b';
    const timelockOwnerB = '0x0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c';
    const proposerIca = '0x0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d';
    const destinationRouterAddress =
      '0x0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e';
    const originRouterAddress = '0x0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x4444444444444444444444444444444444444444': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Float32Array([1, 2])[Symbol.iterator]());
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x4444444444444444444444444444444444444444' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async float32array-iterator-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x1010101010101010101010101010101010101010';
    const timelockOwnerB = '0x1111111111111111111111111111111111111112';
    const proposerIca = '0x1212121212121212121212121212121212121212';
    const destinationRouterAddress =
      '0x1313131313131313131313131313131313131313';
    const originRouterAddress = '0x1414141414141414141414141414141414141414';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x4444444444444444444444444444444444444444': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Float32Array([1, 2])[Symbol.iterator]());
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x4444444444444444444444444444444444444444' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived float64array-iterator-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x1515151515151515151515151515151515151515';
    const timelockOwnerB = '0x1616161616161616161616161616161616161616';
    const proposerIca = '0x1717171717171717171717171717171717171717';
    const destinationRouterAddress =
      '0x1818181818181818181818181818181818181818';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x0000000000000000000000001919191919191919191919191919191919191919';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Float64Array([1, 2])[Symbol.iterator]());
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async float64array-iterator-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a';
    const timelockOwnerB = '0x1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b';
    const proposerIca = '0x1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c';
    const destinationRouterAddress =
      '0x1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x0000000000000000000000001e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Float64Array([1, 2])[Symbol.iterator]());
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches float64array-iterator-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f';
    const timelockOwnerB = '0x2020202020202020202020202020202020202020';
    const proposerIca = '0x2121212121212121212121212121212121212121';
    const destinationRouterAddress =
      '0x2222222222222222222222222222222222222223';
    const originRouterAddress = '0x2323232323232323232323232323232323232323';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x4444444444444444444444444444444444444444': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Float64Array([1, 2])[Symbol.iterator]());
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x4444444444444444444444444444444444444444' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async float64array-iterator-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x2424242424242424242424242424242424242424';
    const timelockOwnerB = '0x2525252525252525252525252525252525252525';
    const proposerIca = '0x2626262626262626262626262626262626262626';
    const destinationRouterAddress =
      '0x2727272727272727272727272727272727272727';
    const originRouterAddress = '0x2828282828282828282828282828282828282828';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x4444444444444444444444444444444444444444': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Float64Array([1, 2])[Symbol.iterator]());
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x4444444444444444444444444444444444444444' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived uint8clampedarray-iterator-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x2929292929292929292929292929292929292929';
    const timelockOwnerB = '0x2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a';
    const proposerIca = '0x2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b';
    const destinationRouterAddress =
      '0x2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x0000000000000000000000002d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Uint8ClampedArray([1, 2])[Symbol.iterator]());
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async uint8clampedarray-iterator-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e';
    const timelockOwnerB = '0x2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f';
    const proposerIca = '0x3030303030303030303030303030303030303030';
    const destinationRouterAddress =
      '0x3131313131313131313131313131313131313131';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x0000000000000000000000003232323232323232323232323232323232323232';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Uint8ClampedArray([1, 2])[Symbol.iterator]());
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches uint8clampedarray-iterator-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x3333333333333333333333333333333333333333';
    const timelockOwnerB = '0x3434343434343434343434343434343434343434';
    const proposerIca = '0x3535353535353535353535353535353535353535';
    const destinationRouterAddress =
      '0x3636363636363636363636363636363636363636';
    const originRouterAddress = '0x3737373737373737373737373737373737373737';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x4444444444444444444444444444444444444444': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Uint8ClampedArray([1, 2])[Symbol.iterator]());
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x4444444444444444444444444444444444444444' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async uint8clampedarray-iterator-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x3838383838383838383838383838383838383838';
    const timelockOwnerB = '0x3939393939393939393939393939393939393939';
    const proposerIca = '0x3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a';
    const destinationRouterAddress =
      '0x3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b';
    const originRouterAddress = '0x3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x4444444444444444444444444444444444444444': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new Uint8ClampedArray([1, 2])[Symbol.iterator]());
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x4444444444444444444444444444444444444444' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived bigint64array-iterator-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d';
    const timelockOwnerB = '0x3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e';
    const proposerIca = '0x3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f';
    const destinationRouterAddress =
      '0x4040404040404040404040404040404040404040';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x0000000000000000000000004141414141414141414141414141414141414141';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new BigInt64Array([1n, 2n])[Symbol.iterator]());
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async bigint64array-iterator-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x4242424242424242424242424242424242424242';
    const timelockOwnerB = '0x4343434343434343434343434343434343434343';
    const proposerIca = '0x4444444444444444444444444444444444444445';
    const destinationRouterAddress =
      '0x4545454545454545454545454545454545454545';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x0000000000000000000000004646464646464646464646464646464646464646';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new BigInt64Array([1n, 2n])[Symbol.iterator]());
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches bigint64array-iterator-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x4747474747474747474747474747474747474747';
    const timelockOwnerB = '0x4848484848484848484848484848484848484848';
    const proposerIca = '0x4949494949494949494949494949494949494949';
    const destinationRouterAddress =
      '0x4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a';
    const originRouterAddress = '0x4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x4444444444444444444444444444444444444444': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new BigInt64Array([1n, 2n])[Symbol.iterator]());
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x4444444444444444444444444444444444444444' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async bigint64array-iterator-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c';
    const timelockOwnerB = '0x4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d';
    const proposerIca = '0x4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e4e';
    const destinationRouterAddress =
      '0x4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f4f';
    const originRouterAddress = '0x5050505050505050505050505050505050505050';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x4444444444444444444444444444444444444444': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new BigInt64Array([1n, 2n])[Symbol.iterator]());
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x4444444444444444444444444444444444444444' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived biguint64array-iterator-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x5151515151515151515151515151515151515151';
    const timelockOwnerB = '0x5252525252525252525252525252525252525252';
    const proposerIca = '0x5353535353535353535353535353535353535353';
    const destinationRouterAddress =
      '0x5454545454545454545454545454545454545454';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x0000000000000000000000005555555555555555555555555555555555555555';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new BigUint64Array([1n, 2n])[Symbol.iterator]());
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async biguint64array-iterator-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x5656565656565656565656565656565656565656';
    const timelockOwnerB = '0x5757575757575757575757575757575757575757';
    const proposerIca = '0x5858585858585858585858585858585858585858';
    const destinationRouterAddress =
      '0x5959595959595959595959595959595959595959';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x0000000000000000000000005a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new BigUint64Array([1n, 2n])[Symbol.iterator]());
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches biguint64array-iterator-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b';
    const timelockOwnerB = '0x5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c';
    const proposerIca = '0x5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d';
    const destinationRouterAddress =
      '0x5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e';
    const originRouterAddress = '0x5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f5f';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x4444444444444444444444444444444444444444': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new BigUint64Array([1n, 2n])[Symbol.iterator]());
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x4444444444444444444444444444444444444444' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async biguint64array-iterator-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x6060606060606060606060606060606060606060';
    const timelockOwnerB = '0x6161616161616161616161616161616161616161';
    const proposerIca = '0x6262626262626262626262626262626262626262';
    const destinationRouterAddress =
      '0x6363636363636363636363636363636363636363';
    const originRouterAddress = '0x6464646464646464646464646464646464646464';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x4444444444444444444444444444444444444444': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Object(new BigUint64Array([1n, 2n])[Symbol.iterator]());
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x4444444444444444444444444444444444444444' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived atomics-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x6565656565656565656565656565656565656565';
    const timelockOwnerB = '0x6666666666666666666666666666666666666666';
    const proposerIca = '0x6767676767676767676767676767676767676768';
    const destinationRouterAddress =
      '0x6868686868686868686868686868686868686869';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x0000000000000000000000006969696969696969696969696969696969696969';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Atomics;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async atomics-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x6a6a6a6a6a6a6a6a6a6a6a6a6a6a6a6a6a6a6a6a';
    const timelockOwnerB = '0x6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b';
    const proposerIca = '0x6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c';
    const destinationRouterAddress =
      '0x6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x0000000000000000000000006e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e6e';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Atomics;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches atomics-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f';
    const timelockOwnerB = '0x7070707070707070707070707070707070707070';
    const proposerIca = '0x7171717171717171717171717171717171717171';
    const destinationRouterAddress =
      '0x7272727272727272727272727272727272727272';
    const originRouterAddress = '0x7373737373737373737373737373737373737373';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x4444444444444444444444444444444444444444': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Atomics;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x4444444444444444444444444444444444444444' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async atomics-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x7474747474747474747474747474747474747474';
    const timelockOwnerB = '0x7575757575757575757575757575757575757575';
    const proposerIca = '0x7676767676767676767676767676767676767676';
    const destinationRouterAddress =
      '0x7777777777777777777777777777777777777777';
    const originRouterAddress = '0x7878787878787878787878787878787878787878';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x4444444444444444444444444444444444444444': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Atomics;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x4444444444444444444444444444444444444444' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived math-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x7979797979797979797979797979797979797979';
    const timelockOwnerB = '0x7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a';
    const proposerIca = '0x7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b';
    const destinationRouterAddress =
      '0x7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x0000000000000000000000007d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Math;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async math-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e';
    const timelockOwnerB = '0x7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f';
    const proposerIca = '0x8080808080808080808080808080808080808080';
    const destinationRouterAddress =
      '0x8181818181818181818181818181818181818181';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x0000000000000000000000008282828282828282828282828282828282828282';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Math;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches math-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x8383838383838383838383838383838383838383';
    const timelockOwnerB = '0x8484848484848484848484848484848484848484';
    const proposerIca = '0x8585858585858585858585858585858585858585';
    const destinationRouterAddress =
      '0x8686868686868686868686868686868686868686';
    const originRouterAddress = '0x8787878787878787878787878787878787878787';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x4444444444444444444444444444444444444444': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Math;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x4444444444444444444444444444444444444444' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async math-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x8888888888888888888888888888888888888888';
    const timelockOwnerB = '0x8989898989898989898989898989898989898989';
    const proposerIca = '0x8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a';
    const destinationRouterAddress =
      '0x8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b';
    const originRouterAddress = '0x8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x4444444444444444444444444444444444444444': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Math;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x4444444444444444444444444444444444444444' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived reflect-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d';
    const timelockOwnerB = '0x8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e';
    const proposerIca = '0x8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f';
    const destinationRouterAddress =
      '0x9090909090909090909090909090909090909091';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x0000000000000000000000009191919191919191919191919191919191919191';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Reflect;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async reflect-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x9292929292929292929292929292929292929292';
    const timelockOwnerB = '0x9393939393939393939393939393939393939393';
    const proposerIca = '0x9494949494949494949494949494949494949494';
    const destinationRouterAddress =
      '0x9595959595959595959595959595959595959595';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x0000000000000000000000009696969696969696969696969696969696969696';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Reflect;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches reflect-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x9797979797979797979797979797979797979797';
    const timelockOwnerB = '0x9898989898989898989898989898989898989898';
    const proposerIca = '0x9999999999999999999999999999999999999999';
    const destinationRouterAddress =
      '0x9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a';
    const originRouterAddress = '0x9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x4444444444444444444444444444444444444444': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Reflect;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x4444444444444444444444444444444444444444' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async reflect-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0x9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c';
    const timelockOwnerB = '0x9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d';
    const proposerIca = '0x9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e';
    const destinationRouterAddress =
      '0x9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f';
    const originRouterAddress = '0xa0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x4444444444444444444444444444444444444444': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Reflect;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x4444444444444444444444444444444444444444' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived json-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xa1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1';
    const timelockOwnerB = '0xa2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2';
    const proposerIca = '0xa3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3';
    const destinationRouterAddress =
      '0xa4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return JSON;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async json-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xa6a6a6a6a6a6a6a6a6a6a6a6a6a6a6a6a6a6a6a6';
    const timelockOwnerB = '0xa7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a7a7';
    const proposerIca = '0xa8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8a8';
    const destinationRouterAddress =
      '0xa9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return JSON;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches json-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xabababababababababababababababababababab';
    const timelockOwnerB = '0xacacacacacacacacacacacacacacacacacacacac';
    const proposerIca = '0xadadadadadadadadadadadadadadadadadadadad';
    const destinationRouterAddress =
      '0xaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeaeae';
    const originRouterAddress = '0xafafafafafafafafafafafafafafafafafafafaf';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x4444444444444444444444444444444444444444': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return JSON;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x4444444444444444444444444444444444444444' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async json-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xb0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0';
    const timelockOwnerB = '0xb1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1';
    const proposerIca = '0xb2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2';
    const destinationRouterAddress =
      '0xb3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3';
    const originRouterAddress = '0xb4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x4444444444444444444444444444444444444444': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return JSON;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x4444444444444444444444444444444444444444' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived console-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xb5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5';
    const timelockOwnerB = '0xb6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6b6';
    const proposerIca = '0xb7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7';
    const destinationRouterAddress =
      '0xb8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8b8';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return console;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async console-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xbabababababababababababababababababababa';
    const timelockOwnerB = '0xbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbc';
    const proposerIca = '0xbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbc';
    const destinationRouterAddress =
      '0xbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbd';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000bebebebebebebebebebebebebebebebebebebebe';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return console;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches console-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbf';
    const timelockOwnerB = '0xc0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0';
    const proposerIca = '0xc1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1';
    const destinationRouterAddress =
      '0xc2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2c2';
    const originRouterAddress = '0xc3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x4444444444444444444444444444444444444444': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return console;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x4444444444444444444444444444444444444444' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async console-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xc4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4c4';
    const timelockOwnerB = '0xc5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5';
    const proposerIca = '0xc6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6';
    const destinationRouterAddress =
      '0xc7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7';
    const originRouterAddress = '0xc8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x4444444444444444444444444444444444444444': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return console;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x4444444444444444444444444444444444444444' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived date-constructor-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xc9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9c9';
    const timelockOwnerB = '0xcacacacacacacacacacacacacacacacacacacaca';
    const proposerIca = '0xcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcb';
    const destinationRouterAddress =
      '0xcccccccccccccccccccccccccccccccccccccccc';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000cdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcd';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Date;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches event-derived async date-constructor-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xcececececececececececececececececececece';
    const timelockOwnerB = '0xcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcf';
    const proposerIca = '0xd0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d1';
    const destinationRouterAddress =
      '0xd1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d2';
    const originOwner = SIGNER.toLowerCase();
    const originOwnerBytes32 =
      `0x000000000000000000000000${originOwner.slice(2)}` as const;
    const originRouterBytes32 =
      '0x000000000000000000000000d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x2222222222222222222222222222222222222222': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        const normalizedAddress =
          typeof filter.address === 'string'
            ? filter.address.toLowerCase()
            : filter.address;
        if (
          (normalizedAddress === timelockOwnerA.toLowerCase() ||
            normalizedAddress === timelockOwnerB.toLowerCase()) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: normalizedAddress }];
        }
        if (normalizedAddress === destinationRouterAddress.toLowerCase()) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({
                address: destinationRouterAddress,
              }),
            },
            interface: {
              parseLog: () => ({
                args: {
                  origin: 31347,
                  router: originRouterBytes32,
                  owner: originOwnerBytes32,
                  ism: ethersConstants.AddressZero,
                },
              }),
            },
          } as any;
        }

        throw new Error('unexpected router');
      });

    let chainNameCalls = 0;
    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) {
            return SIGNER;
          }
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        getChainName: (domainId: number) => {
          chainNameCalls += 1;
          if (domainId === 31347) return 'anvil3';
          throw new Error(`unknown domain ${domainId}`);
        },
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Date;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x2222222222222222222222222222222222222222' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(chainNameCalls).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(5);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches date-constructor-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xd3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3';
    const timelockOwnerB = '0xd4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4';
    const proposerIca = '0xd5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5';
    const destinationRouterAddress =
      '0xd6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6d6';
    const originRouterAddress = '0xd7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x4444444444444444444444444444444444444444': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Date;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x4444444444444444444444444444444444444444' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });

  it('caches async date-constructor-object origin signer probes across timelock ICA inferences', async () => {
    const timelockOwnerA = '0xd8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8';
    const timelockOwnerB = '0xd9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9';
    const proposerIca = '0xdadadadadadadadadadadadadadadadadadadada';
    const destinationRouterAddress =
      '0xdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdb';
    const originRouterAddress = '0xdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdc';

    const ownerByTarget: Record<string, string> = {
      '0x1111111111111111111111111111111111111111': timelockOwnerA,
      '0x4444444444444444444444444444444444444444': timelockOwnerB,
    };

    const ownableStub = sinon.stub(Ownable__factory, 'connect').callsFake(
      (targetAddress: string) =>
        ({
          owner: async () => ownerByTarget[targetAddress.toLowerCase()],
        }) as any,
    );
    const safeStub = sinon
      .stub(ISafe__factory, 'connect')
      .throws(new Error('not safe'));

    const provider = {
      getLogs: sinon.stub().callsFake(async (filter: any) => {
        if (
          (filter.address === timelockOwnerA ||
            filter.address === timelockOwnerB) &&
          filter.topics?.[0] === 'RoleGranted'
        ) {
          return [{ topics: [], data: '0x' }];
        }
        return [];
      }),
    };

    const timelockStub = sinon
      .stub(TimelockController__factory, 'connect')
      .returns({
        getMinDelay: async () => 0,
        hasRole: async () => false,
        interface: {
          getEventTopic: (name: string) => name,
          parseLog: (_log: unknown) => ({ args: { account: proposerIca } }),
        },
      } as any);

    const icaRouterStub = sinon
      .stub(InterchainAccountRouter__factory, 'connect')
      .callsFake((address: string) => {
        if (address.toLowerCase() === destinationRouterAddress.toLowerCase()) {
          return {
            filters: {
              InterchainAccountCreated: (_accountAddress: string) => ({}),
            },
          } as any;
        }

        if (address.toLowerCase() === originRouterAddress.toLowerCase()) {
          return {
            ['getRemoteInterchainAccount(address,address,address)']: async () =>
              proposerIca,
          } as any;
        }

        throw new Error('unexpected router');
      });

    let originSignerProbeCalls = 0;
    let originSignerAddressLookups = 0;
    const context = {
      multiProvider: {
        getProtocol: () => ProtocolType.Ethereum,
        getSignerAddress: async (chainName: string) => {
          if (chainName === CHAIN) return SIGNER;
          originSignerAddressLookups += 1;
          throw new Error(`unexpected signer lookup for ${chainName}`);
        },
        getProvider: () => provider,
        tryGetSigner: async (chainName: string) => {
          if (chainName === CHAIN) return {};
          originSignerProbeCalls += 1;
          return Date;
        },
      },
      registry: {
        getAddresses: async () => ({
          [CHAIN]: {
            interchainAccountRouter: destinationRouterAddress,
          },
          anvil3: {
            interchainAccountRouter: originRouterAddress,
          },
        }),
      },
    } as any;

    try {
      const batches = await resolveSubmitterBatchesForTransactions({
        chain: CHAIN,
        transactions: [
          { ...TX, to: '0x1111111111111111111111111111111111111111' } as any,
          { ...TX, to: '0x4444444444444444444444444444444444444444' } as any,
        ],
        context,
      });

      expect(batches).to.have.length(2);
      expect(batches[0].transactions).to.have.length(1);
      expect(batches[1].transactions).to.have.length(1);
      expect(batches[0].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[0].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(batches[1].config.submitter.type).to.equal(
        TxSubmitterType.TIMELOCK_CONTROLLER,
      );
      expect(
        (batches[1].config.submitter as any).proposerSubmitter.type,
      ).to.equal(TxSubmitterType.JSON_RPC);
      expect(originSignerProbeCalls).to.equal(1);
      expect(originSignerAddressLookups).to.equal(1);
      expect(provider.getLogs.callCount).to.equal(4);
    } finally {
      ownableStub.restore();
      safeStub.restore();
      timelockStub.restore();
      icaRouterStub.restore();
    }
  });
});
