import { execFileSync } from 'child_process';
import fs from 'fs';
import path from 'path';
import * as ts from 'typescript';

import { expect } from 'chai';

const SOURCE_FILE_GLOB = '*.{ts,tsx,js,jsx,mts,mtsx,cts,ctsx,mjs,cjs}' as const;

type SdkPackageJson = {
  dependencies?: Record<string, string>;
  devDependencies?: Record<string, string>;
  optionalDependencies?: Record<string, string>;
  peerDependencies?: Record<string, string>;
};

type ModuleSpecifierReference = {
  source: string;
  filePath: string;
};

type SymbolSourceReference = {
  symbol: string;
  source: string;
};

type NamedExportSymbolReference = {
  symbol: string;
  isTypeOnly: boolean;
};

const DEFAULT_REQUIRE_LIKE_IDENTIFIERS = ['require'] as const;

function normalizeNamedSymbol(symbol: string): string {
  const trimmed = symbol.trim();
  if (!trimmed || trimmed.startsWith('...')) return '';
  return trimmed
    .replace(/^type\s+/, '')
    .replace(/\s+as\s+\w+$/, '')
    .replace(/\s*:\s*[^:]+$/, '')
    .replace(/\s*=\s*.+$/, '')
    .trim();
}

function hasExportModifier(node: ts.Node): boolean {
  if (!ts.canHaveModifiers(node)) return false;
  const modifiers = ts.getModifiers(node);
  return !!modifiers?.some(
    (modifier: ts.Modifier) => modifier.kind === ts.SyntaxKind.ExportKeyword,
  );
}

function hasDefaultModifier(node: ts.Node): boolean {
  if (!ts.canHaveModifiers(node)) return false;
  const modifiers = ts.getModifiers(node);
  return !!modifiers?.some(
    (modifier: ts.Modifier) => modifier.kind === ts.SyntaxKind.DefaultKeyword,
  );
}

function hasStaticModifier(node: ts.Node): boolean {
  if (!ts.canHaveModifiers(node)) return false;
  const modifiers = ts.getModifiers(node);
  return !!modifiers?.some(
    (modifier: ts.Modifier) => modifier.kind === ts.SyntaxKind.StaticKeyword,
  );
}

function hasDefaultExportInSourceFile(
  sourceText: string,
  filePath: string,
): boolean {
  const sourceFile = ts.createSourceFile(
    filePath,
    sourceText,
    ts.ScriptTarget.Latest,
    true,
    getScriptKind(filePath),
  );

  return sourceFile.statements.some((statement) => {
    if (ts.isExportAssignment(statement)) {
      return !statement.isExportEquals;
    }
    if (ts.isExportDeclaration(statement) && statement.exportClause) {
      if (ts.isNamedExports(statement.exportClause)) {
        return statement.exportClause.elements.some(
          (specifier) => specifier.name.text === 'default',
        );
      }
      if (ts.isNamespaceExport(statement.exportClause)) {
        return statement.exportClause.name.text === 'default';
      }
    }
    return hasExportModifier(statement) && hasDefaultModifier(statement);
  });
}

function hasDefaultReExportFromModule(
  sourceText: string,
  filePath: string,
  modulePath: string,
): boolean {
  const sourceFile = ts.createSourceFile(
    filePath,
    sourceText,
    ts.ScriptTarget.Latest,
    true,
    getScriptKind(filePath),
  );

  const visit = (node: ts.Node): boolean => {
    if (
      ts.isExportDeclaration(node) &&
      node.moduleSpecifier &&
      ts.isStringLiteralLike(node.moduleSpecifier) &&
      node.moduleSpecifier.text === modulePath &&
      node.exportClause
    ) {
      if (ts.isNamedExports(node.exportClause)) {
        return node.exportClause.elements.some(
          (specifier) =>
            specifier.name.text === 'default' ||
            specifier.propertyName?.text === 'default',
        );
      }
      if (ts.isNamespaceExport(node.exportClause)) {
        return node.exportClause.name.text === 'default';
      }
    }

    return ts.forEachChild(node, visit) ?? false;
  };

  return visit(sourceFile);
}

function extractNamedExportSymbols(
  sourceText: string,
  modulePath: string,
  filePath: string,
  fallbackModuleExportSymbols: readonly string[] = [],
): string[] {
  return [
    ...new Set(
      extractNamedExportSymbolReferences(
        sourceText,
        modulePath,
        filePath,
        fallbackModuleExportSymbols,
      ).map((reference) => reference.symbol),
    ),
  ];
}

function extractNamedExportSymbolReferences(
  sourceText: string,
  modulePath: string,
  filePath: string,
  fallbackModuleExportSymbols: readonly string[] = [],
): NamedExportSymbolReference[] {
  const references: NamedExportSymbolReference[] = [];
  const sourceFile = ts.createSourceFile(
    filePath,
    sourceText,
    ts.ScriptTarget.Latest,
    true,
    getScriptKind(filePath),
  );

  const visit = (node: ts.Node) => {
    if (
      ts.isExportDeclaration(node) &&
      node.moduleSpecifier &&
      ts.isStringLiteralLike(node.moduleSpecifier) &&
      node.moduleSpecifier.text === modulePath &&
      node.exportClause
    ) {
      if (ts.isNamedExports(node.exportClause)) {
        for (const exportSpecifier of node.exportClause.elements) {
          references.push({
            symbol: normalizeNamedSymbol(exportSpecifier.name.text),
            isTypeOnly: node.isTypeOnly || exportSpecifier.isTypeOnly,
          });
        }
      }
    } else if (
      ts.isExportDeclaration(node) &&
      node.moduleSpecifier &&
      ts.isStringLiteralLike(node.moduleSpecifier) &&
      node.moduleSpecifier.text === modulePath &&
      !node.exportClause &&
      !node.isTypeOnly
    ) {
      for (const symbol of fallbackModuleExportSymbols) {
        references.push({
          symbol: normalizeNamedSymbol(symbol),
          isTypeOnly: false,
        });
      }
    }
    ts.forEachChild(node, visit);
  };

  visit(sourceFile);
  return references.filter((reference) => reference.symbol.length > 0);
}

function hasValueExport(
  references: readonly NamedExportSymbolReference[],
  symbol: string,
): boolean {
  return references.some(
    (reference) => reference.symbol === symbol && !reference.isTypeOnly,
  );
}

function extractTopLevelDeclarationExports(
  sourceText: string,
  filePath: string,
): string[] {
  const symbols = new Set<string>();
  const sourceFile = ts.createSourceFile(
    filePath,
    sourceText,
    ts.ScriptTarget.Latest,
    true,
    getScriptKind(filePath),
  );

  const collectBindingIdentifiers = (name: ts.BindingName): string[] => {
    if (ts.isIdentifier(name)) return [name.text];
    if (ts.isObjectBindingPattern(name) || ts.isArrayBindingPattern(name)) {
      return name.elements.flatMap((element) =>
        ts.isBindingElement(element)
          ? element.dotDotDotToken
            ? []
            : collectBindingIdentifiers(element.name)
          : [],
      );
    }
    return [];
  };

  for (const statement of sourceFile.statements) {
    if (
      ts.isExportDeclaration(statement) &&
      !statement.moduleSpecifier &&
      statement.exportClause &&
      ts.isNamedExports(statement.exportClause)
    ) {
      for (const exportSpecifier of statement.exportClause.elements) {
        symbols.add(exportSpecifier.name.text);
      }
      continue;
    }

    if (!hasExportModifier(statement)) continue;
    if (ts.isFunctionDeclaration(statement) && statement.name) {
      if (hasDefaultModifier(statement)) continue;
      symbols.add(statement.name.text);
      continue;
    }
    if (
      (ts.isClassDeclaration(statement) ||
        ts.isInterfaceDeclaration(statement) ||
        ts.isTypeAliasDeclaration(statement) ||
        ts.isEnumDeclaration(statement)) &&
      statement.name
    ) {
      if (hasDefaultModifier(statement)) continue;
      symbols.add(statement.name.text);
      continue;
    }
    if (ts.isVariableStatement(statement)) {
      for (const declaration of statement.declarationList.declarations) {
        for (const symbol of collectBindingIdentifiers(declaration.name)) {
          symbols.add(symbol);
        }
      }
    }
  }

  return [...symbols].map(normalizeNamedSymbol).filter(Boolean);
}

function getScriptKind(filePath: string): ts.ScriptKind {
  if (/\.(?:[cm]?tsx)$/.test(filePath)) return ts.ScriptKind.TSX;
  if (filePath.endsWith('.jsx')) return ts.ScriptKind.JSX;
  if (/\.(?:[cm]?js)$/.test(filePath) || filePath.endsWith('.mjs')) {
    return ts.ScriptKind.JS;
  }
  return ts.ScriptKind.TS;
}

function readModuleSourceArg(
  callExpression: ts.CallExpression,
): string | undefined {
  const [firstArg] = callExpression.arguments;
  if (firstArg && ts.isStringLiteralLike(firstArg)) return firstArg.text;
  return undefined;
}

function unwrapInitializerExpression(expression: ts.Expression): ts.Expression {
  if (ts.isAwaitExpression(expression)) {
    return unwrapInitializerExpression(expression.expression);
  }
  if (ts.isParenthesizedExpression(expression)) {
    return unwrapInitializerExpression(expression.expression);
  }
  if (ts.isAsExpression(expression)) {
    return unwrapInitializerExpression(expression.expression);
  }
  if (ts.isTypeAssertionExpression(expression)) {
    return unwrapInitializerExpression(expression.expression);
  }
  if (ts.isNonNullExpression(expression)) {
    return unwrapInitializerExpression(expression.expression);
  }
  if (ts.isSatisfiesExpression(expression)) {
    return unwrapInitializerExpression(expression.expression);
  }
  return expression;
}

function unwrapCallTargetExpression(expression: ts.Expression): ts.Expression {
  const unwrapped = unwrapInitializerExpression(expression);
  if (
    ts.isBinaryExpression(unwrapped) &&
    unwrapped.operatorToken.kind === ts.SyntaxKind.CommaToken
  ) {
    return unwrapCallTargetExpression(unwrapped.right);
  }
  return unwrapped;
}

function isRequireLikeExpression(
  expression: ts.Expression,
  requireLikeIdentifiers: ReadonlySet<string>,
): boolean {
  const callTarget = unwrapCallTargetExpression(expression);
  return (
    ts.isIdentifier(callTarget) && requireLikeIdentifiers.has(callTarget.text)
  );
}

function readModuleSourceFromInitializer(
  expression: ts.Expression,
  requireLikeIdentifiers: ReadonlySet<string> = new Set(
    DEFAULT_REQUIRE_LIKE_IDENTIFIERS,
  ),
): string | undefined {
  const unwrapped = unwrapInitializerExpression(expression);
  if (!ts.isCallExpression(unwrapped)) return undefined;
  const callTarget = unwrapCallTargetExpression(unwrapped.expression);

  if (
    ts.isIdentifier(callTarget) &&
    requireLikeIdentifiers.has(callTarget.text)
  ) {
    return readModuleSourceArg(unwrapped);
  }
  if (callTarget.kind === ts.SyntaxKind.ImportKeyword) {
    return readModuleSourceArg(unwrapped);
  }
  return undefined;
}

function readModuleSourceFromCallExpression(
  callExpression: ts.CallExpression,
  requireLikeIdentifiers: ReadonlySet<string> = new Set(
    DEFAULT_REQUIRE_LIKE_IDENTIFIERS,
  ),
): string | undefined {
  return readModuleSourceFromInitializer(
    callExpression,
    requireLikeIdentifiers,
  );
}

function uniqueSources(
  ...sourceGroups: readonly (readonly string[] | string | undefined)[]
): string[] {
  const sources = new Set<string>();
  for (const sourceGroup of sourceGroups) {
    if (!sourceGroup) continue;
    if (typeof sourceGroup === 'string') {
      sources.add(sourceGroup);
      continue;
    }
    for (const source of sourceGroup) {
      if (source) sources.add(source);
    }
  }
  return [...sources];
}

function resolveModuleSourceFromExpression(
  expression: ts.Expression,
  moduleAliasByIdentifier: Map<string, string[]>,
  requireLikeIdentifiers: ReadonlySet<string> = new Set(
    DEFAULT_REQUIRE_LIKE_IDENTIFIERS,
  ),
): string[] {
  const unwrapped = unwrapInitializerExpression(expression);
  if (
    ts.isBinaryExpression(unwrapped) &&
    unwrapped.operatorToken.kind === ts.SyntaxKind.CommaToken
  ) {
    return resolveModuleSourceFromExpression(
      unwrapped.right,
      moduleAliasByIdentifier,
      requireLikeIdentifiers,
    );
  }
  if (
    ts.isBinaryExpression(unwrapped) &&
    [
      ts.SyntaxKind.BarBarToken,
      ts.SyntaxKind.AmpersandAmpersandToken,
      ts.SyntaxKind.QuestionQuestionToken,
    ].includes(unwrapped.operatorToken.kind)
  ) {
    const leftSource = resolveModuleSourceFromExpression(
      unwrapped.left,
      moduleAliasByIdentifier,
      requireLikeIdentifiers,
    );
    const rightSource = resolveModuleSourceFromExpression(
      unwrapped.right,
      moduleAliasByIdentifier,
      requireLikeIdentifiers,
    );
    return uniqueSources(leftSource, rightSource);
  }
  if (ts.isConditionalExpression(unwrapped)) {
    const whenTrueSource = resolveModuleSourceFromExpression(
      unwrapped.whenTrue,
      moduleAliasByIdentifier,
      requireLikeIdentifiers,
    );
    const whenFalseSource = resolveModuleSourceFromExpression(
      unwrapped.whenFalse,
      moduleAliasByIdentifier,
      requireLikeIdentifiers,
    );
    return uniqueSources(whenTrueSource, whenFalseSource);
  }
  const directSource = readModuleSourceFromInitializer(
    unwrapped,
    requireLikeIdentifiers,
  );
  if (directSource) return [directSource];
  if (ts.isIdentifier(unwrapped)) {
    return moduleAliasByIdentifier.get(unwrapped.text) ?? [];
  }
  if (ts.isObjectLiteralExpression(unwrapped)) {
    const sources = new Set<string>();
    for (const property of unwrapped.properties) {
      if (ts.isPropertyAssignment(property)) {
        for (const source of resolveModuleSourceFromExpression(
          property.initializer,
          moduleAliasByIdentifier,
          requireLikeIdentifiers,
        )) {
          sources.add(source);
        }
      } else if (ts.isShorthandPropertyAssignment(property)) {
        for (const source of moduleAliasByIdentifier.get(property.name.text) ??
          []) {
          sources.add(source);
        }
      } else if (ts.isSpreadAssignment(property)) {
        for (const source of resolveModuleSourceFromExpression(
          property.expression,
          moduleAliasByIdentifier,
          requireLikeIdentifiers,
        )) {
          sources.add(source);
        }
      }
    }
    return [...sources];
  }
  if (ts.isArrayLiteralExpression(unwrapped)) {
    const sources = new Set<string>();
    for (const element of unwrapped.elements) {
      if (ts.isOmittedExpression(element)) continue;
      if (ts.isSpreadElement(element)) {
        for (const source of resolveModuleSourceFromExpression(
          element.expression,
          moduleAliasByIdentifier,
          requireLikeIdentifiers,
        )) {
          sources.add(source);
        }
        continue;
      }
      for (const source of resolveModuleSourceFromExpression(
        element,
        moduleAliasByIdentifier,
        requireLikeIdentifiers,
      )) {
        sources.add(source);
      }
    }
    return [...sources];
  }
  if (ts.isPropertyAccessExpression(unwrapped)) {
    return resolveModuleSourceFromExpression(
      unwrapped.expression,
      moduleAliasByIdentifier,
      requireLikeIdentifiers,
    );
  }
  if (ts.isElementAccessExpression(unwrapped)) {
    return resolveModuleSourceFromExpression(
      unwrapped.expression,
      moduleAliasByIdentifier,
      requireLikeIdentifiers,
    );
  }
  return [];
}

function collectBindingElementSymbols(element: ts.BindingElement): string[] {
  const symbols = new Set<string>();
  if (element.propertyName) {
    if (ts.isIdentifier(element.propertyName)) {
      symbols.add(normalizeNamedSymbol(element.propertyName.text));
    } else if (ts.isStringLiteralLike(element.propertyName)) {
      symbols.add(normalizeNamedSymbol(element.propertyName.text));
    }
  }
  if (ts.isIdentifier(element.name)) {
    symbols.add(normalizeNamedSymbol(element.name.text));
  } else if (
    ts.isObjectBindingPattern(element.name) ||
    ts.isArrayBindingPattern(element.name)
  ) {
    for (const nestedElement of element.name.elements) {
      if (!ts.isBindingElement(nestedElement) || nestedElement.dotDotDotToken) {
        continue;
      }
      for (const symbol of collectBindingElementSymbols(nestedElement)) {
        symbols.add(symbol);
      }
    }
  }
  return [...symbols].filter(Boolean);
}

function collectBindingLocalNames(name: ts.BindingName): string[] {
  if (ts.isIdentifier(name)) {
    return [normalizeNamedSymbol(name.text)].filter(Boolean);
  }
  const localNames = new Set<string>();
  for (const element of name.elements) {
    if (!ts.isBindingElement(element)) continue;
    for (const localName of collectBindingLocalNames(element.name)) {
      localNames.add(localName);
    }
  }
  return [...localNames].filter(Boolean);
}

function unwrapAssignmentTargetExpression(
  expression: ts.Expression,
): ts.Expression {
  if (ts.isParenthesizedExpression(expression)) {
    return unwrapAssignmentTargetExpression(expression.expression);
  }
  if (ts.isAsExpression(expression)) {
    return unwrapAssignmentTargetExpression(expression.expression);
  }
  if (ts.isTypeAssertionExpression(expression)) {
    return unwrapAssignmentTargetExpression(expression.expression);
  }
  if (ts.isNonNullExpression(expression)) {
    return unwrapAssignmentTargetExpression(expression.expression);
  }
  if (ts.isSatisfiesExpression(expression)) {
    return unwrapAssignmentTargetExpression(expression.expression);
  }
  return expression;
}

function readAssignmentPropertyName(name: ts.PropertyName): string {
  if (ts.isIdentifier(name)) return normalizeNamedSymbol(name.text);
  if (ts.isStringLiteralLike(name) || ts.isNumericLiteral(name)) {
    return normalizeNamedSymbol(name.text);
  }
  if (
    ts.isComputedPropertyName(name) &&
    ts.isStringLiteralLike(name.expression)
  ) {
    return normalizeNamedSymbol(name.expression.text);
  }
  return '';
}

function collectAssignmentPatternSymbols(expression: ts.Expression): string[] {
  const unwrapped = unwrapAssignmentTargetExpression(expression);

  if (ts.isIdentifier(unwrapped)) {
    return [normalizeNamedSymbol(unwrapped.text)].filter(Boolean);
  }

  if (ts.isObjectLiteralExpression(unwrapped)) {
    const symbols = new Set<string>();
    for (const property of unwrapped.properties) {
      if (ts.isPropertyAssignment(property)) {
        const propertySymbol = readAssignmentPropertyName(property.name);
        if (propertySymbol) symbols.add(propertySymbol);
        for (const symbol of collectAssignmentPatternSymbols(
          property.initializer,
        )) {
          symbols.add(symbol);
        }
      } else if (ts.isShorthandPropertyAssignment(property)) {
        symbols.add(normalizeNamedSymbol(property.name.text));
      }
    }
    return [...symbols].filter(Boolean);
  }

  if (ts.isArrayLiteralExpression(unwrapped)) {
    const symbols = new Set<string>();
    for (const element of unwrapped.elements) {
      if (ts.isOmittedExpression(element)) continue;
      if (ts.isSpreadElement(element)) {
        for (const symbol of collectAssignmentPatternSymbols(
          element.expression,
        )) {
          symbols.add(symbol);
        }
        continue;
      }
      for (const symbol of collectAssignmentPatternSymbols(element)) {
        symbols.add(symbol);
      }
    }
    return [...symbols].filter(Boolean);
  }

  if (
    ts.isBinaryExpression(unwrapped) &&
    unwrapped.operatorToken.kind === ts.SyntaxKind.EqualsToken
  ) {
    return collectAssignmentPatternSymbols(unwrapped.left);
  }

  return [];
}

function collectAssignmentPatternLocalNames(
  expression: ts.Expression,
): string[] {
  const unwrapped = unwrapAssignmentTargetExpression(expression);

  if (ts.isIdentifier(unwrapped)) {
    return [normalizeNamedSymbol(unwrapped.text)].filter(Boolean);
  }

  if (ts.isObjectLiteralExpression(unwrapped)) {
    const localNames = new Set<string>();
    for (const property of unwrapped.properties) {
      if (ts.isPropertyAssignment(property)) {
        for (const localName of collectAssignmentPatternLocalNames(
          property.initializer,
        )) {
          localNames.add(localName);
        }
      } else if (ts.isShorthandPropertyAssignment(property)) {
        localNames.add(normalizeNamedSymbol(property.name.text));
      } else if (ts.isSpreadAssignment(property)) {
        for (const localName of collectAssignmentPatternLocalNames(
          property.expression,
        )) {
          localNames.add(localName);
        }
      }
    }
    return [...localNames].filter(Boolean);
  }

  if (ts.isArrayLiteralExpression(unwrapped)) {
    const localNames = new Set<string>();
    for (const element of unwrapped.elements) {
      if (ts.isOmittedExpression(element)) continue;
      if (ts.isSpreadElement(element)) {
        for (const localName of collectAssignmentPatternLocalNames(
          element.expression,
        )) {
          localNames.add(localName);
        }
        continue;
      }
      for (const localName of collectAssignmentPatternLocalNames(element)) {
        localNames.add(localName);
      }
    }
    return [...localNames].filter(Boolean);
  }

  if (
    ts.isBinaryExpression(unwrapped) &&
    unwrapped.operatorToken.kind === ts.SyntaxKind.EqualsToken
  ) {
    return collectAssignmentPatternLocalNames(unwrapped.left);
  }

  return [];
}

function readImportTypeQualifierSymbol(
  qualifier: ts.EntityName | undefined,
): string {
  if (!qualifier) return '';
  if (ts.isIdentifier(qualifier)) return qualifier.text;
  return readImportTypeQualifierSymbol(qualifier.left);
}

function isAmbientContextNode(node: ts.Node): boolean {
  if (node.getSourceFile().isDeclarationFile) return true;

  let current: ts.Node | undefined = node;
  while (current && !ts.isSourceFile(current)) {
    if (ts.canHaveModifiers(current)) {
      const modifiers = ts.getModifiers(current);
      if (
        modifiers?.some(
          (modifier) => modifier.kind === ts.SyntaxKind.DeclareKeyword,
        )
      ) {
        return true;
      }
    }
    current = current.parent;
  }

  return false;
}

function isLexicalScopeBoundary(node: ts.Node): boolean {
  const hasLexicalBindings = (declarations: ts.VariableDeclarationList) =>
    (declarations.flags & (ts.NodeFlags.Let | ts.NodeFlags.Const)) !== 0;
  const isLexicalLoopBoundary =
    (ts.isForStatement(node) &&
      node.initializer &&
      ts.isVariableDeclarationList(node.initializer) &&
      hasLexicalBindings(node.initializer)) ||
    ((ts.isForInStatement(node) || ts.isForOfStatement(node)) &&
      ts.isVariableDeclarationList(node.initializer) &&
      hasLexicalBindings(node.initializer));
  return (
    ts.isBlock(node) ||
    ts.isModuleBlock(node) ||
    ts.isCaseBlock(node) ||
    ts.isCatchClause(node) ||
    isLexicalLoopBoundary
  );
}

function shouldMergeNonLexicalScopeMutations(node: ts.Node): boolean {
  return (
    !ts.isModuleBlock(node) &&
    node.kind !== ts.SyntaxKind.ClassStaticBlockDeclaration
  );
}

function collectFunctionScopeShadowedIdentifiers(node: ts.Node): string[] {
  if (!ts.isFunctionLike(node)) return [];

  const shadowed = new Set<string>();
  if ('name' in node && node.name && ts.isIdentifier(node.name)) {
    shadowed.add(normalizeNamedSymbol(node.name.text));
  }

  for (const parameter of node.parameters) {
    for (const localName of collectBindingLocalNames(parameter.name)) {
      shadowed.add(localName);
    }
  }

  return [...shadowed].filter(Boolean);
}

function cloneStringArrayMap(
  source: Map<string, string[]>,
): Map<string, string[]> {
  return new Map(
    [...source.entries()].map(([key, values]) => [key, [...values]]),
  );
}

function restoreStringArrayMap(
  target: Map<string, string[]>,
  snapshot: Map<string, string[]>,
): void {
  target.clear();
  for (const [key, values] of snapshot.entries()) {
    target.set(key, [...values]);
  }
}

function restoreStringSet(target: Set<string>, snapshot: Set<string>): void {
  target.clear();
  for (const value of snapshot.values()) {
    target.add(value);
  }
}

function stringArraysEqual(
  left: string[] | undefined,
  right: string[],
): boolean {
  if (!left || left.length !== right.length) return false;
  for (let i = 0; i < left.length; i += 1) {
    if (left[i] !== right[i]) return false;
  }
  return true;
}

function mergeModuleAliasMaps(
  left: Map<string, string[]>,
  right: Map<string, string[]>,
): Map<string, string[]> {
  const merged = new Map<string, string[]>();
  const identifiers = new Set<string>([...left.keys(), ...right.keys()]);

  for (const identifier of identifiers) {
    const mergedSources = [
      ...(left.get(identifier) ?? []),
      ...(right.get(identifier) ?? []),
    ].filter((source, index, sources) => sources.indexOf(source) === index);
    if (mergedSources.length > 0) {
      merged.set(identifier, mergedSources);
    }
  }

  return merged;
}

type StaticPrimitiveValue = string | number | boolean | null | undefined;
const STATIC_PRIMITIVE_UNKNOWN = Symbol('static-primitive-unknown');
const DEFAULT_OBJECT_PROTOTYPE_KEYS = new Set(
  Object.getOwnPropertyNames(Object.prototype),
);
const DEFAULT_ARRAY_PROTOTYPE_KEYS = new Set([
  ...Object.getOwnPropertyNames(Array.prototype),
  ...Object.getOwnPropertyNames(Object.prototype),
]);
const DEFAULT_FUNCTION_PROTOTYPE_KEYS = new Set([
  ...Object.getOwnPropertyNames(Function.prototype),
  ...Object.getOwnPropertyNames(Object.prototype),
]);
const DEFAULT_FUNCTION_EXPRESSION_OWN_KEYS = new Set(
  Object.getOwnPropertyNames(function functionLiteralSample() {}),
);
const DEFAULT_ARROW_FUNCTION_OWN_KEYS = new Set(
  Object.getOwnPropertyNames(() => undefined),
);
const DEFAULT_CLASS_EXPRESSION_OWN_KEYS = new Set(
  Object.getOwnPropertyNames(class ClassLiteralSample {}),
);
const DEFAULT_REGEXP_OWN_KEYS = new Set(Object.getOwnPropertyNames(/sample/));
const DEFAULT_REGEXP_PROTOTYPE_KEYS = new Set([
  ...Object.getOwnPropertyNames(RegExp.prototype),
  ...Object.getOwnPropertyNames(Object.prototype),
]);

function readStaticPropertyName(
  propertyName: ts.PropertyName,
): string | typeof STATIC_PRIMITIVE_UNKNOWN {
  if (ts.isIdentifier(propertyName)) return propertyName.text;
  if (ts.isStringLiteralLike(propertyName)) return propertyName.text;
  if (ts.isNumericLiteral(propertyName)) return propertyName.text;
  if (ts.isComputedPropertyName(propertyName)) {
    const propertyValue = readStaticPrimitiveValue(propertyName.expression);
    if (propertyValue === STATIC_PRIMITIVE_UNKNOWN) {
      return STATIC_PRIMITIVE_UNKNOWN;
    }
    return String(propertyValue);
  }
  return STATIC_PRIMITIVE_UNKNOWN;
}

function readStaticObjectLiteralPropertyKeys(
  objectLiteral: ts.ObjectLiteralExpression,
): Set<string> | typeof STATIC_PRIMITIVE_UNKNOWN {
  const propertyKeys = new Set<string>();
  for (const property of objectLiteral.properties) {
    if (ts.isSpreadAssignment(property)) {
      return STATIC_PRIMITIVE_UNKNOWN;
    }
    if (
      ts.isPropertyAssignment(property) &&
      !ts.isComputedPropertyName(property.name) &&
      readStaticPropertyName(property.name) === '__proto__'
    ) {
      continue;
    }
    const propertyKey = readStaticPropertyName(property.name);
    if (propertyKey === STATIC_PRIMITIVE_UNKNOWN) {
      return STATIC_PRIMITIVE_UNKNOWN;
    }
    propertyKeys.add(propertyKey);
  }
  return propertyKeys;
}

function readStaticObjectLiteralPrototypeOverride(
  objectLiteral: ts.ObjectLiteralExpression,
): ts.Expression | null | undefined | typeof STATIC_PRIMITIVE_UNKNOWN {
  for (const property of objectLiteral.properties) {
    if (!ts.isPropertyAssignment(property)) continue;
    if (ts.isComputedPropertyName(property.name)) continue;
    const propertyKey = readStaticPropertyName(property.name);
    if (propertyKey !== '__proto__') continue;

    const initializerPrimitive = readStaticPrimitiveValue(property.initializer);
    if (initializerPrimitive !== STATIC_PRIMITIVE_UNKNOWN) {
      if (initializerPrimitive === null) return null;
      return undefined;
    }

    const initializerNonPrimitive = readStaticNonPrimitiveResult(
      property.initializer,
    );
    if (initializerNonPrimitive === true) {
      return property.initializer;
    }
    if (initializerNonPrimitive === false) {
      return undefined;
    }
    return STATIC_PRIMITIVE_UNKNOWN;
  }
  return undefined;
}

function readStaticObjectLiteralInMembership(
  propertyKey: string,
  objectLiteral: ts.ObjectLiteralExpression,
): boolean | typeof STATIC_PRIMITIVE_UNKNOWN {
  const ownPropertyKeys = readStaticObjectLiteralPropertyKeys(objectLiteral);
  if (ownPropertyKeys === STATIC_PRIMITIVE_UNKNOWN) {
    return STATIC_PRIMITIVE_UNKNOWN;
  }
  if (ownPropertyKeys.has(propertyKey)) {
    return true;
  }

  const prototypeOverride =
    readStaticObjectLiteralPrototypeOverride(objectLiteral);
  if (prototypeOverride === STATIC_PRIMITIVE_UNKNOWN) {
    return STATIC_PRIMITIVE_UNKNOWN;
  }
  if (prototypeOverride === null) {
    return false;
  }
  if (prototypeOverride) {
    return readStaticInMembership(propertyKey, prototypeOverride);
  }
  return DEFAULT_OBJECT_PROTOTYPE_KEYS.has(propertyKey);
}

function readStaticArrayIndex(propertyKey: string): number | undefined {
  if (!/^(0|[1-9]\d*)$/.test(propertyKey)) return undefined;
  const index = Number(propertyKey);
  if (!Number.isSafeInteger(index)) return undefined;
  return index;
}

function readStaticArrayInMembership(
  propertyKey: string,
  arrayLiteral: ts.ArrayLiteralExpression,
): boolean | typeof STATIC_PRIMITIVE_UNKNOWN {
  if (propertyKey === 'length') return true;

  const propertyIndex = readStaticArrayIndex(propertyKey);
  const explicitIndices = new Set<number>();
  let firstSpreadIndex: number | undefined;

  for (let index = 0; index < arrayLiteral.elements.length; index += 1) {
    const element = arrayLiteral.elements[index];
    if (ts.isSpreadElement(element)) {
      if (firstSpreadIndex === undefined) {
        firstSpreadIndex = index;
      }
      continue;
    }
    if (!ts.isOmittedExpression(element)) {
      explicitIndices.add(index);
    }
  }

  if (firstSpreadIndex === undefined) {
    if (propertyIndex === undefined) {
      return DEFAULT_ARRAY_PROTOTYPE_KEYS.has(propertyKey);
    }
    return explicitIndices.has(propertyIndex);
  }

  if (propertyIndex === undefined) {
    return DEFAULT_ARRAY_PROTOTYPE_KEYS.has(propertyKey);
  }
  if (propertyIndex < firstSpreadIndex) {
    return explicitIndices.has(propertyIndex);
  }
  return STATIC_PRIMITIVE_UNKNOWN;
}

function readStaticClassExpressionOwnKeys(expression: ts.ClassExpression): {
  ownKeys: Set<string>;
  hasUnknownDynamicKeys: boolean;
} {
  const ownKeys = new Set(DEFAULT_CLASS_EXPRESSION_OWN_KEYS);
  let hasUnknownDynamicKeys = false;
  for (const member of expression.members) {
    if (ts.isClassStaticBlockDeclaration(member)) {
      hasUnknownDynamicKeys = true;
      continue;
    }
    if (!hasStaticModifier(member)) continue;
    if (!member.name || ts.isPrivateIdentifier(member.name)) continue;
    const propertyKey = readStaticPropertyName(member.name);
    if (propertyKey === STATIC_PRIMITIVE_UNKNOWN) {
      hasUnknownDynamicKeys = true;
      continue;
    }
    ownKeys.add(propertyKey);
  }
  return { ownKeys, hasUnknownDynamicKeys };
}

function readStaticFunctionInMembership(
  propertyKey: string,
  expression: ts.FunctionExpression | ts.ArrowFunction | ts.ClassExpression,
): boolean | typeof STATIC_PRIMITIVE_UNKNOWN {
  if (ts.isFunctionExpression(expression)) {
    return (
      DEFAULT_FUNCTION_EXPRESSION_OWN_KEYS.has(propertyKey) ||
      DEFAULT_FUNCTION_PROTOTYPE_KEYS.has(propertyKey)
    );
  }
  if (ts.isArrowFunction(expression)) {
    return (
      DEFAULT_ARROW_FUNCTION_OWN_KEYS.has(propertyKey) ||
      DEFAULT_FUNCTION_PROTOTYPE_KEYS.has(propertyKey)
    );
  }
  const classOwnKeys = readStaticClassExpressionOwnKeys(expression);
  if (
    classOwnKeys.ownKeys.has(propertyKey) ||
    DEFAULT_FUNCTION_PROTOTYPE_KEYS.has(propertyKey)
  ) {
    return true;
  }
  return classOwnKeys.hasUnknownDynamicKeys ? STATIC_PRIMITIVE_UNKNOWN : false;
}

function readStaticRegExpInMembership(propertyKey: string): boolean {
  return (
    DEFAULT_REGEXP_OWN_KEYS.has(propertyKey) ||
    DEFAULT_REGEXP_PROTOTYPE_KEYS.has(propertyKey)
  );
}

function readStaticInMembership(
  propertyKey: string,
  rightExpression: ts.Expression,
): boolean | typeof STATIC_PRIMITIVE_UNKNOWN {
  const unwrapped = unwrapInitializerExpression(rightExpression);

  if (ts.isObjectLiteralExpression(unwrapped)) {
    return readStaticObjectLiteralInMembership(propertyKey, unwrapped);
  }
  if (ts.isArrayLiteralExpression(unwrapped)) {
    return readStaticArrayInMembership(propertyKey, unwrapped);
  }
  if (
    ts.isFunctionExpression(unwrapped) ||
    ts.isArrowFunction(unwrapped) ||
    ts.isClassExpression(unwrapped)
  ) {
    return readStaticFunctionInMembership(propertyKey, unwrapped);
  }
  if (ts.isRegularExpressionLiteral(unwrapped)) {
    return readStaticRegExpInMembership(propertyKey);
  }

  if (ts.isConditionalExpression(unwrapped)) {
    const selectorCondition = readStaticBooleanCondition(unwrapped.condition);
    if (selectorCondition === true) {
      return readStaticInMembership(propertyKey, unwrapped.whenTrue);
    }
    if (selectorCondition === false) {
      return readStaticInMembership(propertyKey, unwrapped.whenFalse);
    }
    const whenTrueResult = readStaticInMembership(
      propertyKey,
      unwrapped.whenTrue,
    );
    const whenFalseResult = readStaticInMembership(
      propertyKey,
      unwrapped.whenFalse,
    );
    if (
      whenTrueResult !== STATIC_PRIMITIVE_UNKNOWN &&
      whenTrueResult === whenFalseResult
    ) {
      return whenTrueResult;
    }
    return STATIC_PRIMITIVE_UNKNOWN;
  }

  if (ts.isBinaryExpression(unwrapped)) {
    if (unwrapped.operatorToken.kind === ts.SyntaxKind.CommaToken) {
      return readStaticInMembership(propertyKey, unwrapped.right);
    }

    if (unwrapped.operatorToken.kind === ts.SyntaxKind.QuestionQuestionToken) {
      const leftNullish = readStaticNullishCondition(unwrapped.left);
      if (leftNullish === true) {
        return readStaticInMembership(propertyKey, unwrapped.right);
      }
      if (leftNullish === false) {
        return readStaticInMembership(propertyKey, unwrapped.left);
      }
      const leftResult = readStaticInMembership(propertyKey, unwrapped.left);
      const rightResult = readStaticInMembership(propertyKey, unwrapped.right);
      if (
        leftResult !== STATIC_PRIMITIVE_UNKNOWN &&
        leftResult === rightResult
      ) {
        return leftResult;
      }
      return STATIC_PRIMITIVE_UNKNOWN;
    }

    if (
      unwrapped.operatorToken.kind === ts.SyntaxKind.AmpersandAmpersandToken ||
      unwrapped.operatorToken.kind === ts.SyntaxKind.BarBarToken
    ) {
      const leftCondition = readStaticBooleanCondition(unwrapped.left);
      if (
        unwrapped.operatorToken.kind === ts.SyntaxKind.AmpersandAmpersandToken
      ) {
        if (leftCondition === true) {
          return readStaticInMembership(propertyKey, unwrapped.right);
        }
        if (leftCondition === false) {
          return readStaticInMembership(propertyKey, unwrapped.left);
        }
      } else {
        if (leftCondition === true) {
          return readStaticInMembership(propertyKey, unwrapped.left);
        }
        if (leftCondition === false) {
          return readStaticInMembership(propertyKey, unwrapped.right);
        }
      }
      const leftResult = readStaticInMembership(propertyKey, unwrapped.left);
      const rightResult = readStaticInMembership(propertyKey, unwrapped.right);
      if (
        leftResult !== STATIC_PRIMITIVE_UNKNOWN &&
        leftResult === rightResult
      ) {
        return leftResult;
      }
      return STATIC_PRIMITIVE_UNKNOWN;
    }
  }

  return STATIC_PRIMITIVE_UNKNOWN;
}

function readStaticTypeofResult(
  expression: ts.Expression,
): string | typeof STATIC_PRIMITIVE_UNKNOWN {
  const unwrapped = unwrapInitializerExpression(expression);

  if (
    ts.isObjectLiteralExpression(unwrapped) ||
    ts.isArrayLiteralExpression(unwrapped) ||
    ts.isRegularExpressionLiteral(unwrapped)
  ) {
    return 'object';
  }
  if (
    ts.isFunctionExpression(unwrapped) ||
    ts.isArrowFunction(unwrapped) ||
    ts.isClassExpression(unwrapped)
  ) {
    return 'function';
  }

  if (ts.isConditionalExpression(unwrapped)) {
    const selectorCondition = readStaticBooleanCondition(unwrapped.condition);
    if (selectorCondition === true) {
      const whenTrueResult = readStaticTypeofResult(unwrapped.whenTrue);
      if (whenTrueResult !== STATIC_PRIMITIVE_UNKNOWN) {
        return whenTrueResult;
      }
      if (isStaticallyBooleanValuedExpression(unwrapped.whenTrue)) {
        return 'boolean';
      }
      return STATIC_PRIMITIVE_UNKNOWN;
    }
    if (selectorCondition === false) {
      const whenFalseResult = readStaticTypeofResult(unwrapped.whenFalse);
      if (whenFalseResult !== STATIC_PRIMITIVE_UNKNOWN) {
        return whenFalseResult;
      }
      if (isStaticallyBooleanValuedExpression(unwrapped.whenFalse)) {
        return 'boolean';
      }
      return STATIC_PRIMITIVE_UNKNOWN;
    }
    if (
      isStaticallyBooleanValuedExpression(unwrapped.whenTrue) &&
      isStaticallyBooleanValuedExpression(unwrapped.whenFalse)
    ) {
      return 'boolean';
    }
    const whenTrueResult = readStaticTypeofResult(unwrapped.whenTrue);
    const whenFalseResult = readStaticTypeofResult(unwrapped.whenFalse);
    if (
      whenTrueResult !== STATIC_PRIMITIVE_UNKNOWN &&
      whenTrueResult === whenFalseResult
    ) {
      return whenTrueResult;
    }
    return STATIC_PRIMITIVE_UNKNOWN;
  }

  if (ts.isBinaryExpression(unwrapped)) {
    if (unwrapped.operatorToken.kind === ts.SyntaxKind.CommaToken) {
      return readStaticTypeofResult(unwrapped.right);
    }

    if (unwrapped.operatorToken.kind === ts.SyntaxKind.QuestionQuestionToken) {
      const leftNullish = readStaticNullishCondition(unwrapped.left);
      if (leftNullish === true) {
        return readStaticTypeofResult(unwrapped.right);
      }
      if (leftNullish === false) {
        return readStaticTypeofResult(unwrapped.left);
      }
      if (
        isStaticallyBooleanValuedExpression(unwrapped.left) &&
        isStaticallyBooleanValuedExpression(unwrapped.right)
      ) {
        return 'boolean';
      }
      const leftResult = readStaticTypeofResult(unwrapped.left);
      const rightResult = readStaticTypeofResult(unwrapped.right);
      if (
        leftResult !== STATIC_PRIMITIVE_UNKNOWN &&
        leftResult === rightResult
      ) {
        return leftResult;
      }
      return STATIC_PRIMITIVE_UNKNOWN;
    }

    if (
      unwrapped.operatorToken.kind === ts.SyntaxKind.AmpersandAmpersandToken ||
      unwrapped.operatorToken.kind === ts.SyntaxKind.BarBarToken
    ) {
      const leftCondition = readStaticBooleanCondition(unwrapped.left);
      if (
        unwrapped.operatorToken.kind === ts.SyntaxKind.AmpersandAmpersandToken
      ) {
        if (leftCondition === true) {
          const rightResult = readStaticTypeofResult(unwrapped.right);
          if (rightResult !== STATIC_PRIMITIVE_UNKNOWN) {
            return rightResult;
          }
          if (isStaticallyBooleanValuedExpression(unwrapped.right)) {
            return 'boolean';
          }
          return STATIC_PRIMITIVE_UNKNOWN;
        }
        if (leftCondition === false) {
          const leftResult = readStaticTypeofResult(unwrapped.left);
          if (leftResult !== STATIC_PRIMITIVE_UNKNOWN) {
            return leftResult;
          }
          if (isStaticallyBooleanValuedExpression(unwrapped.left)) {
            return 'boolean';
          }
          return STATIC_PRIMITIVE_UNKNOWN;
        }
      } else {
        if (leftCondition === true) {
          const leftResult = readStaticTypeofResult(unwrapped.left);
          if (leftResult !== STATIC_PRIMITIVE_UNKNOWN) {
            return leftResult;
          }
          if (isStaticallyBooleanValuedExpression(unwrapped.left)) {
            return 'boolean';
          }
          return STATIC_PRIMITIVE_UNKNOWN;
        }
        if (leftCondition === false) {
          const rightResult = readStaticTypeofResult(unwrapped.right);
          if (rightResult !== STATIC_PRIMITIVE_UNKNOWN) {
            return rightResult;
          }
          if (isStaticallyBooleanValuedExpression(unwrapped.right)) {
            return 'boolean';
          }
          return STATIC_PRIMITIVE_UNKNOWN;
        }
      }
      if (
        isStaticallyBooleanValuedExpression(unwrapped.left) &&
        isStaticallyBooleanValuedExpression(unwrapped.right)
      ) {
        return 'boolean';
      }
      const leftResult = readStaticTypeofResult(unwrapped.left);
      const rightResult = readStaticTypeofResult(unwrapped.right);
      if (
        leftResult !== STATIC_PRIMITIVE_UNKNOWN &&
        leftResult === rightResult
      ) {
        return leftResult;
      }
      return STATIC_PRIMITIVE_UNKNOWN;
    }
  }

  const primitiveValue = readStaticPrimitiveValue(unwrapped);
  if (primitiveValue === STATIC_PRIMITIVE_UNKNOWN) {
    if (isStaticallyBooleanValuedExpression(unwrapped)) {
      return 'boolean';
    }
    return STATIC_PRIMITIVE_UNKNOWN;
  }
  if (primitiveValue === null) return 'object';
  if (primitiveValue === undefined) return 'undefined';
  return typeof primitiveValue;
}

function mergeStaticDeleteTargetResults(
  leftResult: boolean | typeof STATIC_PRIMITIVE_UNKNOWN,
  rightResult: boolean | typeof STATIC_PRIMITIVE_UNKNOWN,
): boolean | typeof STATIC_PRIMITIVE_UNKNOWN {
  if (leftResult !== STATIC_PRIMITIVE_UNKNOWN && leftResult === rightResult) {
    return leftResult;
  }
  return STATIC_PRIMITIVE_UNKNOWN;
}

const NEW_EXPRESSION_CONSTRUCTOR_NAMES = [
  'Object',
  'Array',
  'Function',
  'RegExp',
  'Date',
  'String',
  'Number',
  'Boolean',
] as const;

const GLOBAL_CONSTRUCTOR_QUALIFIERS = [
  'globalThis',
  'window',
  'global',
  'self',
];

function readStaticGlobalQualifierResolution(
  qualifierExpression: ts.Expression,
): boolean | typeof STATIC_PRIMITIVE_UNKNOWN {
  const unwrappedQualifier = unwrapInitializerExpression(qualifierExpression);
  if (ts.isIdentifier(unwrappedQualifier)) {
    return GLOBAL_CONSTRUCTOR_QUALIFIERS.includes(unwrappedQualifier.text)
      ? true
      : STATIC_PRIMITIVE_UNKNOWN;
  }

  if (ts.isConditionalExpression(unwrappedQualifier)) {
    const selectorCondition = readStaticBooleanCondition(
      unwrappedQualifier.condition,
    );
    if (selectorCondition === true) {
      return readStaticGlobalQualifierResolution(unwrappedQualifier.whenTrue);
    }
    if (selectorCondition === false) {
      return readStaticGlobalQualifierResolution(unwrappedQualifier.whenFalse);
    }
    return mergeStaticDeleteTargetResults(
      readStaticGlobalQualifierResolution(unwrappedQualifier.whenTrue),
      readStaticGlobalQualifierResolution(unwrappedQualifier.whenFalse),
    );
  }

  if (ts.isBinaryExpression(unwrappedQualifier)) {
    if (unwrappedQualifier.operatorToken.kind === ts.SyntaxKind.CommaToken) {
      return readStaticGlobalQualifierResolution(unwrappedQualifier.right);
    }
    if (
      unwrappedQualifier.operatorToken.kind ===
      ts.SyntaxKind.QuestionQuestionToken
    ) {
      const leftNullish = readStaticNullishCondition(unwrappedQualifier.left);
      if (leftNullish === true) {
        return readStaticGlobalQualifierResolution(unwrappedQualifier.right);
      }
      if (leftNullish === false) {
        return readStaticGlobalQualifierResolution(unwrappedQualifier.left);
      }
      return mergeStaticDeleteTargetResults(
        readStaticGlobalQualifierResolution(unwrappedQualifier.left),
        readStaticGlobalQualifierResolution(unwrappedQualifier.right),
      );
    }
    if (
      unwrappedQualifier.operatorToken.kind ===
        ts.SyntaxKind.AmpersandAmpersandToken ||
      unwrappedQualifier.operatorToken.kind === ts.SyntaxKind.BarBarToken
    ) {
      const leftCondition = readStaticBooleanCondition(unwrappedQualifier.left);
      if (
        unwrappedQualifier.operatorToken.kind ===
        ts.SyntaxKind.AmpersandAmpersandToken
      ) {
        if (leftCondition === true) {
          return readStaticGlobalQualifierResolution(unwrappedQualifier.right);
        }
        if (leftCondition === false) {
          return readStaticGlobalQualifierResolution(unwrappedQualifier.left);
        }
      } else {
        if (leftCondition === true) {
          return readStaticGlobalQualifierResolution(unwrappedQualifier.left);
        }
        if (leftCondition === false) {
          return readStaticGlobalQualifierResolution(unwrappedQualifier.right);
        }
      }
      return mergeStaticDeleteTargetResults(
        readStaticGlobalQualifierResolution(unwrappedQualifier.left),
        readStaticGlobalQualifierResolution(unwrappedQualifier.right),
      );
    }
  }

  return STATIC_PRIMITIVE_UNKNOWN;
}

function readStaticKnownConstructorName(
  constructorExpression: ts.Expression,
): string | typeof STATIC_PRIMITIVE_UNKNOWN {
  const unwrappedConstructor = unwrapInitializerExpression(
    constructorExpression,
  );
  if (ts.isIdentifier(unwrappedConstructor)) {
    return unwrappedConstructor.text;
  }
  if (ts.isElementAccessExpression(unwrappedConstructor)) {
    if (!unwrappedConstructor.argumentExpression) {
      return STATIC_PRIMITIVE_UNKNOWN;
    }
    const qualifierIsKnownGlobal = readStaticGlobalQualifierResolution(
      unwrappedConstructor.expression,
    );
    if (qualifierIsKnownGlobal !== true) {
      return STATIC_PRIMITIVE_UNKNOWN;
    }
    const propertyNameValue = readStaticPrimitiveValue(
      unwrappedConstructor.argumentExpression,
    );
    if (propertyNameValue === STATIC_PRIMITIVE_UNKNOWN) {
      return STATIC_PRIMITIVE_UNKNOWN;
    }
    if (
      typeof propertyNameValue !== 'string' &&
      typeof propertyNameValue !== 'number'
    ) {
      return STATIC_PRIMITIVE_UNKNOWN;
    }
    return String(propertyNameValue);
  }
  if (!ts.isPropertyAccessExpression(unwrappedConstructor)) {
    return STATIC_PRIMITIVE_UNKNOWN;
  }
  const qualifierIsKnownGlobal = readStaticGlobalQualifierResolution(
    unwrappedConstructor.expression,
  );
  if (qualifierIsKnownGlobal !== true) {
    return STATIC_PRIMITIVE_UNKNOWN;
  }
  return unwrappedConstructor.name.text;
}

function readStaticDeleteResultForKnownNewConstructor(
  constructorName: string,
  propertyKey: string,
): boolean | typeof STATIC_PRIMITIVE_UNKNOWN {
  if (
    (constructorName === 'Array' || constructorName === 'String') &&
    propertyKey === 'length'
  ) {
    return STATIC_PRIMITIVE_UNKNOWN;
  }
  if (constructorName === 'Function' && propertyKey === 'prototype') {
    return STATIC_PRIMITIVE_UNKNOWN;
  }
  if (NEW_EXPRESSION_CONSTRUCTOR_NAMES.includes(constructorName as never)) {
    return true;
  }
  return STATIC_PRIMITIVE_UNKNOWN;
}

function readStaticDeleteResultForNewConstructorExpression(
  constructorExpression: ts.Expression,
  propertyKey: string,
): boolean | typeof STATIC_PRIMITIVE_UNKNOWN {
  const unwrappedConstructor = unwrapInitializerExpression(
    constructorExpression,
  );
  const knownConstructorName =
    readStaticKnownConstructorName(unwrappedConstructor);
  if (knownConstructorName !== STATIC_PRIMITIVE_UNKNOWN) {
    return readStaticDeleteResultForKnownNewConstructor(
      knownConstructorName,
      propertyKey,
    );
  }

  if (ts.isConditionalExpression(unwrappedConstructor)) {
    const selectorCondition = readStaticBooleanCondition(
      unwrappedConstructor.condition,
    );
    if (selectorCondition === true) {
      return readStaticDeleteResultForNewConstructorExpression(
        unwrappedConstructor.whenTrue,
        propertyKey,
      );
    }
    if (selectorCondition === false) {
      return readStaticDeleteResultForNewConstructorExpression(
        unwrappedConstructor.whenFalse,
        propertyKey,
      );
    }
    return mergeStaticDeleteTargetResults(
      readStaticDeleteResultForNewConstructorExpression(
        unwrappedConstructor.whenTrue,
        propertyKey,
      ),
      readStaticDeleteResultForNewConstructorExpression(
        unwrappedConstructor.whenFalse,
        propertyKey,
      ),
    );
  }

  if (ts.isBinaryExpression(unwrappedConstructor)) {
    if (unwrappedConstructor.operatorToken.kind === ts.SyntaxKind.CommaToken) {
      return readStaticDeleteResultForNewConstructorExpression(
        unwrappedConstructor.right,
        propertyKey,
      );
    }

    if (
      unwrappedConstructor.operatorToken.kind ===
      ts.SyntaxKind.QuestionQuestionToken
    ) {
      const leftNullish = readStaticNullishCondition(unwrappedConstructor.left);
      if (leftNullish === true) {
        return readStaticDeleteResultForNewConstructorExpression(
          unwrappedConstructor.right,
          propertyKey,
        );
      }
      if (leftNullish === false) {
        return readStaticDeleteResultForNewConstructorExpression(
          unwrappedConstructor.left,
          propertyKey,
        );
      }
      return mergeStaticDeleteTargetResults(
        readStaticDeleteResultForNewConstructorExpression(
          unwrappedConstructor.left,
          propertyKey,
        ),
        readStaticDeleteResultForNewConstructorExpression(
          unwrappedConstructor.right,
          propertyKey,
        ),
      );
    }

    if (
      unwrappedConstructor.operatorToken.kind ===
        ts.SyntaxKind.AmpersandAmpersandToken ||
      unwrappedConstructor.operatorToken.kind === ts.SyntaxKind.BarBarToken
    ) {
      const leftCondition = readStaticBooleanCondition(
        unwrappedConstructor.left,
      );
      if (
        unwrappedConstructor.operatorToken.kind ===
        ts.SyntaxKind.AmpersandAmpersandToken
      ) {
        if (leftCondition === true) {
          return readStaticDeleteResultForNewConstructorExpression(
            unwrappedConstructor.right,
            propertyKey,
          );
        }
        if (leftCondition === false) {
          return readStaticDeleteResultForNewConstructorExpression(
            unwrappedConstructor.left,
            propertyKey,
          );
        }
      } else {
        if (leftCondition === true) {
          return readStaticDeleteResultForNewConstructorExpression(
            unwrappedConstructor.left,
            propertyKey,
          );
        }
        if (leftCondition === false) {
          return readStaticDeleteResultForNewConstructorExpression(
            unwrappedConstructor.right,
            propertyKey,
          );
        }
      }
      return mergeStaticDeleteTargetResults(
        readStaticDeleteResultForNewConstructorExpression(
          unwrappedConstructor.left,
          propertyKey,
        ),
        readStaticDeleteResultForNewConstructorExpression(
          unwrappedConstructor.right,
          propertyKey,
        ),
      );
    }
  }

  return STATIC_PRIMITIVE_UNKNOWN;
}

function readStaticDeleteResultForPropertyTarget(
  targetExpression: ts.Expression,
  propertyKey: string,
): boolean | typeof STATIC_PRIMITIVE_UNKNOWN {
  const unwrappedTarget = unwrapInitializerExpression(targetExpression);

  if (ts.isObjectLiteralExpression(unwrappedTarget)) {
    return true;
  }
  if (ts.isArrayLiteralExpression(unwrappedTarget)) {
    return propertyKey === 'length' ? false : true;
  }
  if (ts.isFunctionExpression(unwrappedTarget)) {
    return propertyKey === 'prototype' ? STATIC_PRIMITIVE_UNKNOWN : true;
  }
  if (ts.isArrowFunction(unwrappedTarget)) {
    return true;
  }
  if (ts.isClassExpression(unwrappedTarget)) {
    return propertyKey === 'prototype' ? STATIC_PRIMITIVE_UNKNOWN : true;
  }
  if (ts.isRegularExpressionLiteral(unwrappedTarget)) {
    return true;
  }
  if (ts.isNewExpression(unwrappedTarget)) {
    return readStaticDeleteResultForNewConstructorExpression(
      unwrappedTarget.expression,
      propertyKey,
    );
  }

  const primitiveTarget = readStaticPrimitiveValue(unwrappedTarget);
  if (primitiveTarget !== STATIC_PRIMITIVE_UNKNOWN) {
    if (primitiveTarget === null || primitiveTarget === undefined) {
      return STATIC_PRIMITIVE_UNKNOWN;
    }
    if (typeof primitiveTarget === 'string' && propertyKey === 'length') {
      return STATIC_PRIMITIVE_UNKNOWN;
    }
    return true;
  }

  if (ts.isConditionalExpression(unwrappedTarget)) {
    const selectorCondition = readStaticBooleanCondition(
      unwrappedTarget.condition,
    );
    if (selectorCondition === true) {
      return readStaticDeleteResultForPropertyTarget(
        unwrappedTarget.whenTrue,
        propertyKey,
      );
    }
    if (selectorCondition === false) {
      return readStaticDeleteResultForPropertyTarget(
        unwrappedTarget.whenFalse,
        propertyKey,
      );
    }
    return mergeStaticDeleteTargetResults(
      readStaticDeleteResultForPropertyTarget(
        unwrappedTarget.whenTrue,
        propertyKey,
      ),
      readStaticDeleteResultForPropertyTarget(
        unwrappedTarget.whenFalse,
        propertyKey,
      ),
    );
  }

  if (ts.isBinaryExpression(unwrappedTarget)) {
    if (unwrappedTarget.operatorToken.kind === ts.SyntaxKind.CommaToken) {
      return readStaticDeleteResultForPropertyTarget(
        unwrappedTarget.right,
        propertyKey,
      );
    }

    if (
      unwrappedTarget.operatorToken.kind === ts.SyntaxKind.QuestionQuestionToken
    ) {
      const leftNullish = readStaticNullishCondition(unwrappedTarget.left);
      if (leftNullish === true) {
        return readStaticDeleteResultForPropertyTarget(
          unwrappedTarget.right,
          propertyKey,
        );
      }
      if (leftNullish === false) {
        return readStaticDeleteResultForPropertyTarget(
          unwrappedTarget.left,
          propertyKey,
        );
      }
      return mergeStaticDeleteTargetResults(
        readStaticDeleteResultForPropertyTarget(
          unwrappedTarget.left,
          propertyKey,
        ),
        readStaticDeleteResultForPropertyTarget(
          unwrappedTarget.right,
          propertyKey,
        ),
      );
    }

    if (
      unwrappedTarget.operatorToken.kind ===
        ts.SyntaxKind.AmpersandAmpersandToken ||
      unwrappedTarget.operatorToken.kind === ts.SyntaxKind.BarBarToken
    ) {
      const leftCondition = readStaticBooleanCondition(unwrappedTarget.left);
      if (
        unwrappedTarget.operatorToken.kind ===
        ts.SyntaxKind.AmpersandAmpersandToken
      ) {
        if (leftCondition === true) {
          return readStaticDeleteResultForPropertyTarget(
            unwrappedTarget.right,
            propertyKey,
          );
        }
        if (leftCondition === false) {
          return readStaticDeleteResultForPropertyTarget(
            unwrappedTarget.left,
            propertyKey,
          );
        }
      } else {
        if (leftCondition === true) {
          return readStaticDeleteResultForPropertyTarget(
            unwrappedTarget.left,
            propertyKey,
          );
        }
        if (leftCondition === false) {
          return readStaticDeleteResultForPropertyTarget(
            unwrappedTarget.right,
            propertyKey,
          );
        }
      }
      return mergeStaticDeleteTargetResults(
        readStaticDeleteResultForPropertyTarget(
          unwrappedTarget.left,
          propertyKey,
        ),
        readStaticDeleteResultForPropertyTarget(
          unwrappedTarget.right,
          propertyKey,
        ),
      );
    }
  }

  return STATIC_PRIMITIVE_UNKNOWN;
}

function readStaticDeleteResultForElementTarget(
  targetExpression: ts.Expression,
  argumentExpression: ts.Expression | undefined,
): boolean | typeof STATIC_PRIMITIVE_UNKNOWN {
  const unwrappedTarget = unwrapInitializerExpression(targetExpression);
  if (ts.isObjectLiteralExpression(unwrappedTarget)) {
    return true;
  }
  if (!argumentExpression) {
    return STATIC_PRIMITIVE_UNKNOWN;
  }

  const unwrappedArgument = unwrapInitializerExpression(argumentExpression);

  if (ts.isConditionalExpression(unwrappedArgument)) {
    const selectorCondition = readStaticBooleanCondition(
      unwrappedArgument.condition,
    );
    if (selectorCondition === true) {
      return readStaticDeleteResultForElementTarget(
        unwrappedTarget,
        unwrappedArgument.whenTrue,
      );
    }
    if (selectorCondition === false) {
      return readStaticDeleteResultForElementTarget(
        unwrappedTarget,
        unwrappedArgument.whenFalse,
      );
    }
    return mergeStaticDeleteTargetResults(
      readStaticDeleteResultForElementTarget(
        unwrappedTarget,
        unwrappedArgument.whenTrue,
      ),
      readStaticDeleteResultForElementTarget(
        unwrappedTarget,
        unwrappedArgument.whenFalse,
      ),
    );
  }

  if (ts.isBinaryExpression(unwrappedArgument)) {
    if (unwrappedArgument.operatorToken.kind === ts.SyntaxKind.CommaToken) {
      return readStaticDeleteResultForElementTarget(
        unwrappedTarget,
        unwrappedArgument.right,
      );
    }

    if (
      unwrappedArgument.operatorToken.kind ===
      ts.SyntaxKind.QuestionQuestionToken
    ) {
      const evaluateNullishLeftBranch = (
        leftBranchExpression: ts.Expression,
      ): boolean | typeof STATIC_PRIMITIVE_UNKNOWN => {
        const branchNullish = readStaticNullishCondition(leftBranchExpression);
        if (branchNullish === true) {
          return readStaticDeleteResultForElementTarget(
            unwrappedTarget,
            unwrappedArgument.right,
          );
        }
        if (branchNullish === false) {
          return readStaticDeleteResultForElementTarget(
            unwrappedTarget,
            leftBranchExpression,
          );
        }
        return mergeStaticDeleteTargetResults(
          readStaticDeleteResultForElementTarget(
            unwrappedTarget,
            leftBranchExpression,
          ),
          readStaticDeleteResultForElementTarget(
            unwrappedTarget,
            unwrappedArgument.right,
          ),
        );
      };

      const nullishLeft = unwrapInitializerExpression(unwrappedArgument.left);
      const nullishRightPrimitive = readStaticPrimitiveValue(
        unwrappedArgument.right,
      );
      if (
        ts.isBinaryExpression(nullishLeft) &&
        nullishLeft.operatorToken.kind === ts.SyntaxKind.BarBarToken &&
        readStaticNullishCondition(nullishLeft.right) === true &&
        nullishRightPrimitive !== STATIC_PRIMITIVE_UNKNOWN
      ) {
        const logicalSource = unwrapInitializerExpression(nullishLeft.left);
        if (
          ts.isBinaryExpression(logicalSource) &&
          logicalSource.operatorToken.kind ===
            ts.SyntaxKind.AmpersandAmpersandToken
        ) {
          const logicalRightPrimitive = readStaticPrimitiveValue(
            logicalSource.right,
          );
          if (
            logicalRightPrimitive !== STATIC_PRIMITIVE_UNKNOWN &&
            logicalRightPrimitive === nullishRightPrimitive
          ) {
            return readStaticDeleteResultForPropertyTarget(
              unwrappedTarget,
              String(nullishRightPrimitive),
            );
          }
        }
      }
      if (ts.isConditionalExpression(nullishLeft)) {
        const selectorCondition = readStaticBooleanCondition(
          nullishLeft.condition,
        );
        if (selectorCondition === true) {
          return evaluateNullishLeftBranch(nullishLeft.whenTrue);
        }
        if (selectorCondition === false) {
          return evaluateNullishLeftBranch(nullishLeft.whenFalse);
        }
        return mergeStaticDeleteTargetResults(
          evaluateNullishLeftBranch(nullishLeft.whenTrue),
          evaluateNullishLeftBranch(nullishLeft.whenFalse),
        );
      }

      return evaluateNullishLeftBranch(unwrappedArgument.left);
    }

    if (
      unwrappedArgument.operatorToken.kind ===
        ts.SyntaxKind.AmpersandAmpersandToken ||
      unwrappedArgument.operatorToken.kind === ts.SyntaxKind.BarBarToken
    ) {
      const logicalLeft = unwrapInitializerExpression(unwrappedArgument.left);
      if (
        ts.isBinaryExpression(logicalLeft) &&
        ((unwrappedArgument.operatorToken.kind === ts.SyntaxKind.BarBarToken &&
          logicalLeft.operatorToken.kind ===
            ts.SyntaxKind.AmpersandAmpersandToken) ||
          (unwrappedArgument.operatorToken.kind ===
            ts.SyntaxKind.AmpersandAmpersandToken &&
            logicalLeft.operatorToken.kind === ts.SyntaxKind.BarBarToken))
      ) {
        const leftSharedPrimitive = readStaticPrimitiveValue(logicalLeft.right);
        const rightSharedPrimitive = readStaticPrimitiveValue(
          unwrappedArgument.right,
        );
        if (
          leftSharedPrimitive !== STATIC_PRIMITIVE_UNKNOWN &&
          leftSharedPrimitive === rightSharedPrimitive
        ) {
          return readStaticDeleteResultForPropertyTarget(
            unwrappedTarget,
            String(rightSharedPrimitive),
          );
        }
      }

      const leftCondition = readStaticBooleanCondition(logicalLeft);
      if (
        unwrappedArgument.operatorToken.kind ===
        ts.SyntaxKind.AmpersandAmpersandToken
      ) {
        if (leftCondition === true) {
          return readStaticDeleteResultForElementTarget(
            unwrappedTarget,
            unwrappedArgument.right,
          );
        }
        if (leftCondition === false) {
          return readStaticDeleteResultForElementTarget(
            unwrappedTarget,
            logicalLeft,
          );
        }
      } else {
        if (leftCondition === true) {
          return readStaticDeleteResultForElementTarget(
            unwrappedTarget,
            logicalLeft,
          );
        }
        if (leftCondition === false) {
          return readStaticDeleteResultForElementTarget(
            unwrappedTarget,
            unwrappedArgument.right,
          );
        }
      }
      return mergeStaticDeleteTargetResults(
        readStaticDeleteResultForElementTarget(unwrappedTarget, logicalLeft),
        readStaticDeleteResultForElementTarget(
          unwrappedTarget,
          unwrappedArgument.right,
        ),
      );
    }
  }

  const primitiveArgument = readStaticPrimitiveValue(unwrappedArgument);
  if (primitiveArgument !== STATIC_PRIMITIVE_UNKNOWN) {
    return readStaticDeleteResultForPropertyTarget(
      unwrappedTarget,
      String(primitiveArgument),
    );
  }

  return STATIC_PRIMITIVE_UNKNOWN;
}

function readStaticPrimitiveValue(
  expression: ts.Expression,
): StaticPrimitiveValue | typeof STATIC_PRIMITIVE_UNKNOWN {
  const unwrapped = unwrapInitializerExpression(expression);

  if (ts.isStringLiteralLike(unwrapped)) return unwrapped.text;
  if (ts.isNumericLiteral(unwrapped)) return Number(unwrapped.text);
  if (ts.isTemplateExpression(unwrapped)) {
    let templateValue = unwrapped.head.text;
    for (const span of unwrapped.templateSpans) {
      const expressionValue = readStaticPrimitiveValue(span.expression);
      if (expressionValue === STATIC_PRIMITIVE_UNKNOWN) {
        return STATIC_PRIMITIVE_UNKNOWN;
      }
      templateValue += `${String(expressionValue)}${span.literal.text}`;
    }
    return templateValue;
  }
  if (unwrapped.kind === ts.SyntaxKind.TrueKeyword) return true;
  if (unwrapped.kind === ts.SyntaxKind.FalseKeyword) return false;
  if (unwrapped.kind === ts.SyntaxKind.NullKeyword) return null;
  if (ts.isIdentifier(unwrapped) && unwrapped.text === 'undefined') {
    return undefined;
  }

  if (ts.isVoidExpression(unwrapped)) {
    return undefined;
  }

  if (ts.isBinaryExpression(unwrapped)) {
    if (unwrapped.operatorToken.kind === ts.SyntaxKind.CommaToken) {
      return readStaticPrimitiveValue(unwrapped.right);
    }

    if (unwrapped.operatorToken.kind === ts.SyntaxKind.InstanceOfKeyword) {
      const rightExpression = unwrapInitializerExpression(unwrapped.right);
      if (!ts.isIdentifier(rightExpression)) {
        return STATIC_PRIMITIVE_UNKNOWN;
      }
      const constructorName = rightExpression.text;
      if (
        !['Object', 'Array', 'Function', 'RegExp'].includes(constructorName)
      ) {
        return STATIC_PRIMITIVE_UNKNOWN;
      }
      return readStaticInstanceofResult(unwrapped.left, constructorName);
    }

    if (unwrapped.operatorToken.kind === ts.SyntaxKind.InKeyword) {
      const leftValue = readStaticPrimitiveValue(unwrapped.left);
      if (leftValue === STATIC_PRIMITIVE_UNKNOWN) {
        return STATIC_PRIMITIVE_UNKNOWN;
      }
      return readStaticInMembership(String(leftValue), unwrapped.right);
    }

    if (
      [
        ts.SyntaxKind.PlusToken,
        ts.SyntaxKind.MinusToken,
        ts.SyntaxKind.AsteriskToken,
        ts.SyntaxKind.SlashToken,
        ts.SyntaxKind.PercentToken,
        ts.SyntaxKind.AsteriskAsteriskToken,
        ts.SyntaxKind.BarToken,
        ts.SyntaxKind.AmpersandToken,
        ts.SyntaxKind.CaretToken,
        ts.SyntaxKind.LessThanLessThanToken,
        ts.SyntaxKind.GreaterThanGreaterThanToken,
        ts.SyntaxKind.GreaterThanGreaterThanGreaterThanToken,
      ].includes(unwrapped.operatorToken.kind)
    ) {
      const leftValue = readStaticPrimitiveValue(unwrapped.left);
      const rightValue = readStaticPrimitiveValue(unwrapped.right);
      if (
        leftValue === STATIC_PRIMITIVE_UNKNOWN ||
        rightValue === STATIC_PRIMITIVE_UNKNOWN
      ) {
        return STATIC_PRIMITIVE_UNKNOWN;
      }

      if (unwrapped.operatorToken.kind === ts.SyntaxKind.PlusToken) {
        if (typeof leftValue === 'string' || typeof rightValue === 'string') {
          return String(leftValue) + String(rightValue);
        }
        return Number(leftValue) + Number(rightValue);
      }

      const leftNumber = Number(leftValue);
      const rightNumber = Number(rightValue);
      if (unwrapped.operatorToken.kind === ts.SyntaxKind.MinusToken) {
        return leftNumber - rightNumber;
      }
      if (unwrapped.operatorToken.kind === ts.SyntaxKind.AsteriskToken) {
        return leftNumber * rightNumber;
      }
      if (unwrapped.operatorToken.kind === ts.SyntaxKind.SlashToken) {
        return leftNumber / rightNumber;
      }
      if (unwrapped.operatorToken.kind === ts.SyntaxKind.PercentToken) {
        return leftNumber % rightNumber;
      }
      if (
        unwrapped.operatorToken.kind === ts.SyntaxKind.AsteriskAsteriskToken
      ) {
        return leftNumber ** rightNumber;
      }
      if (unwrapped.operatorToken.kind === ts.SyntaxKind.BarToken) {
        return leftNumber | rightNumber;
      }
      if (unwrapped.operatorToken.kind === ts.SyntaxKind.AmpersandToken) {
        return leftNumber & rightNumber;
      }
      if (unwrapped.operatorToken.kind === ts.SyntaxKind.CaretToken) {
        return leftNumber ^ rightNumber;
      }
      if (
        unwrapped.operatorToken.kind === ts.SyntaxKind.LessThanLessThanToken
      ) {
        return leftNumber << rightNumber;
      }
      if (
        unwrapped.operatorToken.kind ===
        ts.SyntaxKind.GreaterThanGreaterThanToken
      ) {
        return leftNumber >> rightNumber;
      }
      return leftNumber >>> rightNumber;
    }

    if (
      unwrapped.operatorToken.kind === ts.SyntaxKind.EqualsEqualsToken ||
      unwrapped.operatorToken.kind === ts.SyntaxKind.ExclamationEqualsToken ||
      unwrapped.operatorToken.kind === ts.SyntaxKind.EqualsEqualsEqualsToken ||
      unwrapped.operatorToken.kind ===
        ts.SyntaxKind.ExclamationEqualsEqualsToken ||
      unwrapped.operatorToken.kind === ts.SyntaxKind.LessThanToken ||
      unwrapped.operatorToken.kind === ts.SyntaxKind.LessThanEqualsToken ||
      unwrapped.operatorToken.kind === ts.SyntaxKind.GreaterThanToken ||
      unwrapped.operatorToken.kind === ts.SyntaxKind.GreaterThanEqualsToken
    ) {
      if (
        unwrapped.operatorToken.kind ===
          ts.SyntaxKind.EqualsEqualsEqualsToken ||
        unwrapped.operatorToken.kind ===
          ts.SyntaxKind.ExclamationEqualsEqualsToken
      ) {
        const leftNonPrimitive = readStaticNonPrimitiveResult(unwrapped.left);
        const rightNonPrimitive = readStaticNonPrimitiveResult(unwrapped.right);
        if (leftNonPrimitive === true || rightNonPrimitive === true) {
          return (
            unwrapped.operatorToken.kind ===
            ts.SyntaxKind.ExclamationEqualsEqualsToken
          );
        }
      }

      if (
        unwrapped.operatorToken.kind === ts.SyntaxKind.EqualsEqualsToken ||
        unwrapped.operatorToken.kind === ts.SyntaxKind.ExclamationEqualsToken
      ) {
        const leftNonPrimitive = readStaticNonPrimitiveResult(unwrapped.left);
        const rightNonPrimitive = readStaticNonPrimitiveResult(unwrapped.right);
        if (leftNonPrimitive === true && rightNonPrimitive === true) {
          return (
            unwrapped.operatorToken.kind ===
            ts.SyntaxKind.ExclamationEqualsToken
          );
        }
        const leftValue = readStaticPrimitiveValue(unwrapped.left);
        const rightValue = readStaticPrimitiveValue(unwrapped.right);
        const leftIsNullishPrimitive =
          leftValue === null || leftValue === undefined;
        const rightIsNullishPrimitive =
          rightValue === null || rightValue === undefined;
        if (
          (leftNonPrimitive === true && rightIsNullishPrimitive) ||
          (rightNonPrimitive === true && leftIsNullishPrimitive)
        ) {
          return (
            unwrapped.operatorToken.kind ===
            ts.SyntaxKind.ExclamationEqualsToken
          );
        }
      }

      const leftValue = readStaticPrimitiveValue(unwrapped.left);
      const rightValue = readStaticPrimitiveValue(unwrapped.right);
      if (
        leftValue === STATIC_PRIMITIVE_UNKNOWN ||
        rightValue === STATIC_PRIMITIVE_UNKNOWN
      ) {
        return STATIC_PRIMITIVE_UNKNOWN;
      }
      const leftComparable = leftValue as any;
      const rightComparable = rightValue as any;
      if (unwrapped.operatorToken.kind === ts.SyntaxKind.EqualsEqualsToken) {
        return leftComparable == rightComparable;
      }
      if (
        unwrapped.operatorToken.kind === ts.SyntaxKind.ExclamationEqualsToken
      ) {
        return leftComparable != rightComparable;
      }
      if (
        unwrapped.operatorToken.kind === ts.SyntaxKind.EqualsEqualsEqualsToken
      ) {
        return leftComparable === rightComparable;
      }
      if (
        unwrapped.operatorToken.kind ===
        ts.SyntaxKind.ExclamationEqualsEqualsToken
      ) {
        return leftComparable !== rightComparable;
      }
      if (unwrapped.operatorToken.kind === ts.SyntaxKind.LessThanToken) {
        return leftComparable < rightComparable;
      }
      if (unwrapped.operatorToken.kind === ts.SyntaxKind.LessThanEqualsToken) {
        return leftComparable <= rightComparable;
      }
      if (unwrapped.operatorToken.kind === ts.SyntaxKind.GreaterThanToken) {
        return leftComparable > rightComparable;
      }
      return leftComparable >= rightComparable;
    }

    if (unwrapped.operatorToken.kind === ts.SyntaxKind.QuestionQuestionToken) {
      const leftValue = readStaticPrimitiveValue(unwrapped.left);
      if (leftValue === STATIC_PRIMITIVE_UNKNOWN) {
        const leftNullish = readStaticNullishCondition(unwrapped.left);
        if (leftNullish === true) {
          return readStaticPrimitiveValue(unwrapped.right);
        }
        if (leftNullish === false) {
          return readStaticPrimitiveValue(unwrapped.left);
        }
        return STATIC_PRIMITIVE_UNKNOWN;
      }
      if (leftValue !== null && leftValue !== undefined) {
        return leftValue;
      }
      return readStaticPrimitiveValue(unwrapped.right);
    }

    if (
      unwrapped.operatorToken.kind === ts.SyntaxKind.AmpersandAmpersandToken ||
      unwrapped.operatorToken.kind === ts.SyntaxKind.BarBarToken
    ) {
      const leftValue = readStaticPrimitiveValue(unwrapped.left);
      if (leftValue === STATIC_PRIMITIVE_UNKNOWN) {
        const leftCondition = readStaticBooleanCondition(unwrapped.left);
        if (leftCondition === undefined) {
          const rightValue = readStaticPrimitiveValue(unwrapped.right);
          if (
            rightValue !== STATIC_PRIMITIVE_UNKNOWN &&
            isStaticallyBooleanValuedExpression(unwrapped.left)
          ) {
            if (
              unwrapped.operatorToken.kind ===
                ts.SyntaxKind.AmpersandAmpersandToken &&
              rightValue === false
            ) {
              return false;
            }
            if (
              unwrapped.operatorToken.kind === ts.SyntaxKind.BarBarToken &&
              rightValue === true
            ) {
              return true;
            }
          }
          return STATIC_PRIMITIVE_UNKNOWN;
        }
        if (
          unwrapped.operatorToken.kind === ts.SyntaxKind.AmpersandAmpersandToken
        ) {
          return leftCondition
            ? readStaticPrimitiveValue(unwrapped.right)
            : isStaticallyBooleanValuedExpression(unwrapped.left)
              ? false
              : STATIC_PRIMITIVE_UNKNOWN;
        }
        return leftCondition
          ? isStaticallyBooleanValuedExpression(unwrapped.left)
            ? true
            : STATIC_PRIMITIVE_UNKNOWN
          : readStaticPrimitiveValue(unwrapped.right);
      }

      const leftTruthiness = Boolean(leftValue);
      if (
        unwrapped.operatorToken.kind === ts.SyntaxKind.AmpersandAmpersandToken
      ) {
        return leftTruthiness
          ? readStaticPrimitiveValue(unwrapped.right)
          : leftValue;
      }

      return leftTruthiness
        ? leftValue
        : readStaticPrimitiveValue(unwrapped.right);
    }
  }

  if (ts.isConditionalExpression(unwrapped)) {
    const selectorCondition = readStaticBooleanCondition(unwrapped.condition);
    if (selectorCondition === true) {
      return readStaticPrimitiveValue(unwrapped.whenTrue);
    }
    if (selectorCondition === false) {
      return readStaticPrimitiveValue(unwrapped.whenFalse);
    }
    const whenTrueValue = readStaticPrimitiveValue(unwrapped.whenTrue);
    const whenFalseValue = readStaticPrimitiveValue(unwrapped.whenFalse);
    if (
      whenTrueValue === STATIC_PRIMITIVE_UNKNOWN ||
      whenFalseValue === STATIC_PRIMITIVE_UNKNOWN
    ) {
      return STATIC_PRIMITIVE_UNKNOWN;
    }
    return whenTrueValue === whenFalseValue
      ? whenTrueValue
      : STATIC_PRIMITIVE_UNKNOWN;
  }

  if (
    ts.isPrefixUnaryExpression(unwrapped) &&
    unwrapped.operator === ts.SyntaxKind.ExclamationToken
  ) {
    const operandCondition = readStaticBooleanCondition(unwrapped.operand);
    if (operandCondition !== undefined) {
      return !operandCondition;
    }
    const operandValue = readStaticPrimitiveValue(unwrapped.operand);
    if (operandValue === STATIC_PRIMITIVE_UNKNOWN) {
      return STATIC_PRIMITIVE_UNKNOWN;
    }
    return !Boolean(operandValue);
  }

  if (ts.isVoidExpression(unwrapped)) {
    return undefined;
  }

  if (ts.isDeleteExpression(unwrapped)) {
    const operand = unwrapInitializerExpression(unwrapped.expression);
    if (ts.isPropertyAccessExpression(operand)) {
      return readStaticDeleteResultForPropertyTarget(
        operand.expression,
        operand.name.text,
      );
    }
    if (ts.isElementAccessExpression(operand)) {
      return readStaticDeleteResultForElementTarget(
        operand.expression,
        operand.argumentExpression,
      );
    }
    if (ts.isIdentifier(operand)) {
      return STATIC_PRIMITIVE_UNKNOWN;
    }
    return true;
  }

  if (
    ts.isTypeOfExpression(unwrapped) &&
    unwrapped.expression.kind === ts.SyntaxKind.Identifier
  ) {
    return STATIC_PRIMITIVE_UNKNOWN;
  }

  if (ts.isTypeOfExpression(unwrapped)) {
    return readStaticTypeofResult(unwrapped.expression);
  }

  if (
    ts.isPrefixUnaryExpression(unwrapped) &&
    (unwrapped.operator === ts.SyntaxKind.MinusToken ||
      unwrapped.operator === ts.SyntaxKind.PlusToken ||
      unwrapped.operator === ts.SyntaxKind.TildeToken)
  ) {
    const operandValue = readStaticPrimitiveValue(unwrapped.operand);
    if (operandValue === STATIC_PRIMITIVE_UNKNOWN) {
      return STATIC_PRIMITIVE_UNKNOWN;
    }
    if (
      typeof operandValue !== 'number' &&
      typeof operandValue !== 'boolean' &&
      typeof operandValue !== 'string' &&
      operandValue !== null &&
      operandValue !== undefined
    ) {
      return STATIC_PRIMITIVE_UNKNOWN;
    }
    const numericValue = Number(operandValue);
    if (unwrapped.operator === ts.SyntaxKind.TildeToken) {
      return ~numericValue;
    }
    return unwrapped.operator === ts.SyntaxKind.MinusToken
      ? -numericValue
      : numericValue;
  }

  return STATIC_PRIMITIVE_UNKNOWN;
}

function readStaticBooleanCondition(
  expression: ts.Expression,
): boolean | undefined {
  const unwrapped = unwrapInitializerExpression(expression);

  if (unwrapped.kind === ts.SyntaxKind.TrueKeyword) return true;
  if (unwrapped.kind === ts.SyntaxKind.FalseKeyword) return false;
  if (isStaticallyTruthyNonPrimitiveExpression(unwrapped)) {
    return true;
  }
  const primitiveValue = readStaticPrimitiveValue(unwrapped);
  if (primitiveValue !== STATIC_PRIMITIVE_UNKNOWN) {
    return Boolean(primitiveValue);
  }
  if (ts.isConditionalExpression(unwrapped)) {
    const selectorCondition = readStaticBooleanCondition(unwrapped.condition);
    if (selectorCondition === true) {
      return readStaticBooleanCondition(unwrapped.whenTrue);
    }
    if (selectorCondition === false) {
      return readStaticBooleanCondition(unwrapped.whenFalse);
    }
    const whenTrueCondition = readStaticBooleanCondition(unwrapped.whenTrue);
    const whenFalseCondition = readStaticBooleanCondition(unwrapped.whenFalse);
    if (
      whenTrueCondition !== undefined &&
      whenTrueCondition === whenFalseCondition
    ) {
      return whenTrueCondition;
    }
    return undefined;
  }

  if (ts.isBinaryExpression(unwrapped)) {
    if (unwrapped.operatorToken.kind === ts.SyntaxKind.QuestionQuestionToken) {
      const leftNullish = readStaticNullishCondition(unwrapped.left);
      if (leftNullish === true) {
        return readStaticBooleanCondition(unwrapped.right);
      }
      if (leftNullish === false) {
        return readStaticBooleanCondition(unwrapped.left);
      }
      const leftCondition = readStaticBooleanCondition(unwrapped.left);
      const rightCondition = readStaticBooleanCondition(unwrapped.right);
      if (
        leftCondition !== undefined &&
        rightCondition !== undefined &&
        leftCondition === rightCondition
      ) {
        return leftCondition;
      }
      return undefined;
    }

    if (
      unwrapped.operatorToken.kind === ts.SyntaxKind.AmpersandAmpersandToken ||
      unwrapped.operatorToken.kind === ts.SyntaxKind.BarBarToken
    ) {
      const leftCondition = readStaticBooleanCondition(unwrapped.left);
      const rightCondition = readStaticBooleanCondition(unwrapped.right);

      if (
        unwrapped.operatorToken.kind === ts.SyntaxKind.AmpersandAmpersandToken
      ) {
        if (leftCondition === false || rightCondition === false) {
          return false;
        }
        if (leftCondition === true && rightCondition === true) {
          return true;
        }
        return undefined;
      }

      if (leftCondition === true || rightCondition === true) {
        return true;
      }
      if (leftCondition === false && rightCondition === false) {
        return false;
      }
      return undefined;
    }

    if (
      unwrapped.operatorToken.kind === ts.SyntaxKind.EqualsEqualsToken ||
      unwrapped.operatorToken.kind === ts.SyntaxKind.ExclamationEqualsToken ||
      unwrapped.operatorToken.kind === ts.SyntaxKind.EqualsEqualsEqualsToken ||
      unwrapped.operatorToken.kind ===
        ts.SyntaxKind.ExclamationEqualsEqualsToken
    ) {
      const leftValue = readStaticPrimitiveValue(unwrapped.left);
      const rightValue = readStaticPrimitiveValue(unwrapped.right);
      if (
        leftValue === STATIC_PRIMITIVE_UNKNOWN ||
        rightValue === STATIC_PRIMITIVE_UNKNOWN
      ) {
        return undefined;
      }
      if (unwrapped.operatorToken.kind === ts.SyntaxKind.EqualsEqualsToken) {
        return (leftValue as any) == (rightValue as any);
      }
      if (
        unwrapped.operatorToken.kind === ts.SyntaxKind.ExclamationEqualsToken
      ) {
        return (leftValue as any) != (rightValue as any);
      }
      const isEqual = leftValue === rightValue;
      return unwrapped.operatorToken.kind ===
        ts.SyntaxKind.EqualsEqualsEqualsToken
        ? isEqual
        : !isEqual;
    }

    if (
      unwrapped.operatorToken.kind === ts.SyntaxKind.LessThanToken ||
      unwrapped.operatorToken.kind === ts.SyntaxKind.LessThanEqualsToken ||
      unwrapped.operatorToken.kind === ts.SyntaxKind.GreaterThanToken ||
      unwrapped.operatorToken.kind === ts.SyntaxKind.GreaterThanEqualsToken
    ) {
      const leftValue = readStaticPrimitiveValue(unwrapped.left);
      const rightValue = readStaticPrimitiveValue(unwrapped.right);
      if (
        leftValue === STATIC_PRIMITIVE_UNKNOWN ||
        rightValue === STATIC_PRIMITIVE_UNKNOWN
      ) {
        return undefined;
      }
      const leftComparable = leftValue as any;
      const rightComparable = rightValue as any;
      if (unwrapped.operatorToken.kind === ts.SyntaxKind.LessThanToken) {
        return leftComparable < rightComparable;
      }
      if (unwrapped.operatorToken.kind === ts.SyntaxKind.LessThanEqualsToken) {
        return leftComparable <= rightComparable;
      }
      if (unwrapped.operatorToken.kind === ts.SyntaxKind.GreaterThanToken) {
        return leftComparable > rightComparable;
      }
      return leftComparable >= rightComparable;
    }
  }

  if (
    ts.isPrefixUnaryExpression(unwrapped) &&
    unwrapped.operator === ts.SyntaxKind.ExclamationToken
  ) {
    const operandCondition = readStaticBooleanCondition(unwrapped.operand);
    if (operandCondition === undefined) return undefined;
    return !operandCondition;
  }

  return undefined;
}

function isStaticallyBooleanValuedExpression(
  expression: ts.Expression,
): boolean {
  const unwrapped = unwrapInitializerExpression(expression);
  if (
    unwrapped.kind === ts.SyntaxKind.TrueKeyword ||
    unwrapped.kind === ts.SyntaxKind.FalseKeyword
  ) {
    return true;
  }
  if (
    ts.isPrefixUnaryExpression(unwrapped) &&
    unwrapped.operator === ts.SyntaxKind.ExclamationToken
  ) {
    return true;
  }
  if (ts.isDeleteExpression(unwrapped)) {
    return true;
  }
  if (ts.isConditionalExpression(unwrapped)) {
    const selectorCondition = readStaticBooleanCondition(unwrapped.condition);
    if (selectorCondition === true) {
      return isStaticallyBooleanValuedExpression(unwrapped.whenTrue);
    }
    if (selectorCondition === false) {
      return isStaticallyBooleanValuedExpression(unwrapped.whenFalse);
    }
    return (
      isStaticallyBooleanValuedExpression(unwrapped.whenTrue) &&
      isStaticallyBooleanValuedExpression(unwrapped.whenFalse)
    );
  }
  if (ts.isBinaryExpression(unwrapped)) {
    if (unwrapped.operatorToken.kind === ts.SyntaxKind.CommaToken) {
      return isStaticallyBooleanValuedExpression(unwrapped.right);
    }
    if (unwrapped.operatorToken.kind === ts.SyntaxKind.QuestionQuestionToken) {
      const leftNullish = readStaticNullishCondition(unwrapped.left);
      if (leftNullish === true) {
        return isStaticallyBooleanValuedExpression(unwrapped.right);
      }
      if (leftNullish === false) {
        return isStaticallyBooleanValuedExpression(unwrapped.left);
      }
      return (
        isStaticallyBooleanValuedExpression(unwrapped.left) &&
        isStaticallyBooleanValuedExpression(unwrapped.right)
      );
    }
    if (
      unwrapped.operatorToken.kind === ts.SyntaxKind.AmpersandAmpersandToken ||
      unwrapped.operatorToken.kind === ts.SyntaxKind.BarBarToken
    ) {
      const leftCondition = readStaticBooleanCondition(unwrapped.left);
      if (
        unwrapped.operatorToken.kind === ts.SyntaxKind.AmpersandAmpersandToken
      ) {
        if (leftCondition === true) {
          return isStaticallyBooleanValuedExpression(unwrapped.right);
        }
        if (leftCondition === false) {
          return isStaticallyBooleanValuedExpression(unwrapped.left);
        }
      } else {
        if (leftCondition === true) {
          return isStaticallyBooleanValuedExpression(unwrapped.left);
        }
        if (leftCondition === false) {
          return isStaticallyBooleanValuedExpression(unwrapped.right);
        }
      }
      return (
        isStaticallyBooleanValuedExpression(unwrapped.left) &&
        isStaticallyBooleanValuedExpression(unwrapped.right)
      );
    }
    return (
      unwrapped.operatorToken.kind === ts.SyntaxKind.EqualsEqualsToken ||
      unwrapped.operatorToken.kind === ts.SyntaxKind.ExclamationEqualsToken ||
      unwrapped.operatorToken.kind === ts.SyntaxKind.EqualsEqualsEqualsToken ||
      unwrapped.operatorToken.kind ===
        ts.SyntaxKind.ExclamationEqualsEqualsToken ||
      unwrapped.operatorToken.kind === ts.SyntaxKind.LessThanToken ||
      unwrapped.operatorToken.kind === ts.SyntaxKind.LessThanEqualsToken ||
      unwrapped.operatorToken.kind === ts.SyntaxKind.GreaterThanToken ||
      unwrapped.operatorToken.kind === ts.SyntaxKind.GreaterThanEqualsToken ||
      unwrapped.operatorToken.kind === ts.SyntaxKind.InstanceOfKeyword ||
      unwrapped.operatorToken.kind === ts.SyntaxKind.InKeyword
    );
  }
  return false;
}

function isStaticallyTruthyNonPrimitiveExpression(
  expression: ts.Expression,
): boolean {
  return (
    ts.isObjectLiteralExpression(expression) ||
    ts.isArrayLiteralExpression(expression) ||
    ts.isFunctionExpression(expression) ||
    ts.isArrowFunction(expression) ||
    ts.isClassExpression(expression) ||
    ts.isRegularExpressionLiteral(expression)
  );
}

function readStaticNullishCondition(
  expression: ts.Expression,
): boolean | undefined {
  const unwrapped = unwrapInitializerExpression(expression);
  if (ts.isConditionalExpression(unwrapped)) {
    const selectorCondition = readStaticBooleanCondition(unwrapped.condition);
    if (selectorCondition === true) {
      return readStaticNullishCondition(unwrapped.whenTrue);
    }
    if (selectorCondition === false) {
      return readStaticNullishCondition(unwrapped.whenFalse);
    }
    const whenTrueNullish = readStaticNullishCondition(unwrapped.whenTrue);
    const whenFalseNullish = readStaticNullishCondition(unwrapped.whenFalse);
    if (whenTrueNullish !== undefined && whenTrueNullish === whenFalseNullish) {
      return whenTrueNullish;
    }
    return undefined;
  }
  if (ts.isBinaryExpression(unwrapped)) {
    if (unwrapped.operatorToken.kind === ts.SyntaxKind.CommaToken) {
      return readStaticNullishCondition(unwrapped.right);
    }
    if (unwrapped.operatorToken.kind === ts.SyntaxKind.QuestionQuestionToken) {
      const leftNullish = readStaticNullishCondition(unwrapped.left);
      if (leftNullish === true) {
        return readStaticNullishCondition(unwrapped.right);
      }
      if (leftNullish === false) {
        return readStaticNullishCondition(unwrapped.left);
      }
      return undefined;
    }
    if (
      unwrapped.operatorToken.kind === ts.SyntaxKind.AmpersandAmpersandToken ||
      unwrapped.operatorToken.kind === ts.SyntaxKind.BarBarToken
    ) {
      const leftCondition = readStaticBooleanCondition(unwrapped.left);
      const leftNullish = readStaticNullishCondition(unwrapped.left);
      const rightNullish = readStaticNullishCondition(unwrapped.right);
      if (
        unwrapped.operatorToken.kind === ts.SyntaxKind.AmpersandAmpersandToken
      ) {
        if (leftCondition === true) {
          return rightNullish;
        }
        if (leftCondition === false) {
          return leftNullish;
        }
      } else {
        if (leftCondition === true) {
          return false;
        }
        if (leftCondition === false) {
          return rightNullish;
        }
        if (rightNullish === false) {
          return false;
        }
      }
      if (leftNullish !== undefined && leftNullish === rightNullish) {
        return leftNullish;
      }
      return undefined;
    }
  }
  if (isStaticallyTruthyNonPrimitiveExpression(unwrapped)) return false;
  const primitiveValue = readStaticPrimitiveValue(unwrapped);
  if (primitiveValue === STATIC_PRIMITIVE_UNKNOWN) {
    if (isStaticallyBooleanValuedExpression(unwrapped)) {
      return false;
    }
    return undefined;
  }
  return primitiveValue === null || primitiveValue === undefined;
}

function readStaticNonPrimitiveResult(
  expression: ts.Expression,
): boolean | undefined {
  const unwrapped = unwrapInitializerExpression(expression);
  if (isStaticallyTruthyNonPrimitiveExpression(unwrapped)) return true;

  const primitiveValue = readStaticPrimitiveValue(unwrapped);
  if (primitiveValue !== STATIC_PRIMITIVE_UNKNOWN) return false;
  if (isStaticallyBooleanValuedExpression(unwrapped)) return false;

  if (ts.isConditionalExpression(unwrapped)) {
    const selectorCondition = readStaticBooleanCondition(unwrapped.condition);
    if (selectorCondition === true) {
      return readStaticNonPrimitiveResult(unwrapped.whenTrue);
    }
    if (selectorCondition === false) {
      return readStaticNonPrimitiveResult(unwrapped.whenFalse);
    }
    const whenTrueResult = readStaticNonPrimitiveResult(unwrapped.whenTrue);
    const whenFalseResult = readStaticNonPrimitiveResult(unwrapped.whenFalse);
    if (whenTrueResult !== undefined && whenTrueResult === whenFalseResult) {
      return whenTrueResult;
    }
    return undefined;
  }

  if (ts.isBinaryExpression(unwrapped)) {
    if (unwrapped.operatorToken.kind === ts.SyntaxKind.CommaToken) {
      return readStaticNonPrimitiveResult(unwrapped.right);
    }

    if (unwrapped.operatorToken.kind === ts.SyntaxKind.QuestionQuestionToken) {
      const leftNullish = readStaticNullishCondition(unwrapped.left);
      if (leftNullish === true) {
        return readStaticNonPrimitiveResult(unwrapped.right);
      }
      if (leftNullish === false) {
        return readStaticNonPrimitiveResult(unwrapped.left);
      }
      const leftResult = readStaticNonPrimitiveResult(unwrapped.left);
      const rightResult = readStaticNonPrimitiveResult(unwrapped.right);
      if (leftResult !== undefined && leftResult === rightResult) {
        return leftResult;
      }
      return undefined;
    }

    if (
      unwrapped.operatorToken.kind === ts.SyntaxKind.AmpersandAmpersandToken ||
      unwrapped.operatorToken.kind === ts.SyntaxKind.BarBarToken
    ) {
      const leftCondition = readStaticBooleanCondition(unwrapped.left);
      if (
        unwrapped.operatorToken.kind === ts.SyntaxKind.AmpersandAmpersandToken
      ) {
        if (leftCondition === true) {
          return readStaticNonPrimitiveResult(unwrapped.right);
        }
        if (leftCondition === false) {
          return readStaticNonPrimitiveResult(unwrapped.left);
        }
      } else {
        if (leftCondition === true) {
          return readStaticNonPrimitiveResult(unwrapped.left);
        }
        if (leftCondition === false) {
          return readStaticNonPrimitiveResult(unwrapped.right);
        }
      }
    }
  }

  return undefined;
}

function readStaticInstanceofResult(
  expression: ts.Expression,
  constructorName: 'Object' | 'Array' | 'Function' | 'RegExp' | string,
): boolean | typeof STATIC_PRIMITIVE_UNKNOWN {
  const unwrapped = unwrapInitializerExpression(expression);

  if (ts.isObjectLiteralExpression(unwrapped)) {
    return constructorName === 'Object';
  }
  if (ts.isArrayLiteralExpression(unwrapped)) {
    return constructorName === 'Array' || constructorName === 'Object';
  }
  if (
    ts.isFunctionExpression(unwrapped) ||
    ts.isArrowFunction(unwrapped) ||
    ts.isClassExpression(unwrapped)
  ) {
    return constructorName === 'Function' || constructorName === 'Object';
  }
  if (ts.isRegularExpressionLiteral(unwrapped)) {
    return constructorName === 'RegExp' || constructorName === 'Object';
  }

  if (ts.isConditionalExpression(unwrapped)) {
    const selectorCondition = readStaticBooleanCondition(unwrapped.condition);
    if (selectorCondition === true) {
      return readStaticInstanceofResult(unwrapped.whenTrue, constructorName);
    }
    if (selectorCondition === false) {
      return readStaticInstanceofResult(unwrapped.whenFalse, constructorName);
    }
    const whenTrueResult = readStaticInstanceofResult(
      unwrapped.whenTrue,
      constructorName,
    );
    const whenFalseResult = readStaticInstanceofResult(
      unwrapped.whenFalse,
      constructorName,
    );
    if (
      whenTrueResult !== STATIC_PRIMITIVE_UNKNOWN &&
      whenTrueResult === whenFalseResult
    ) {
      return whenTrueResult;
    }
    return STATIC_PRIMITIVE_UNKNOWN;
  }

  if (ts.isBinaryExpression(unwrapped)) {
    if (unwrapped.operatorToken.kind === ts.SyntaxKind.CommaToken) {
      return readStaticInstanceofResult(unwrapped.right, constructorName);
    }

    if (unwrapped.operatorToken.kind === ts.SyntaxKind.QuestionQuestionToken) {
      const leftNullish = readStaticNullishCondition(unwrapped.left);
      if (leftNullish === true) {
        return readStaticInstanceofResult(unwrapped.right, constructorName);
      }
      if (leftNullish === false) {
        return readStaticInstanceofResult(unwrapped.left, constructorName);
      }
      const leftResult = readStaticInstanceofResult(
        unwrapped.left,
        constructorName,
      );
      const rightResult = readStaticInstanceofResult(
        unwrapped.right,
        constructorName,
      );
      if (
        leftResult !== STATIC_PRIMITIVE_UNKNOWN &&
        leftResult === rightResult
      ) {
        return leftResult;
      }
      return STATIC_PRIMITIVE_UNKNOWN;
    }

    if (
      unwrapped.operatorToken.kind === ts.SyntaxKind.AmpersandAmpersandToken ||
      unwrapped.operatorToken.kind === ts.SyntaxKind.BarBarToken
    ) {
      const leftCondition = readStaticBooleanCondition(unwrapped.left);
      if (
        unwrapped.operatorToken.kind === ts.SyntaxKind.AmpersandAmpersandToken
      ) {
        if (leftCondition === true) {
          return readStaticInstanceofResult(unwrapped.right, constructorName);
        }
        if (leftCondition === false) {
          return readStaticInstanceofResult(unwrapped.left, constructorName);
        }
      } else {
        if (leftCondition === true) {
          return readStaticInstanceofResult(unwrapped.left, constructorName);
        }
        if (leftCondition === false) {
          return readStaticInstanceofResult(unwrapped.right, constructorName);
        }
      }
      const leftResult = readStaticInstanceofResult(
        unwrapped.left,
        constructorName,
      );
      const rightResult = readStaticInstanceofResult(
        unwrapped.right,
        constructorName,
      );
      if (
        leftResult !== STATIC_PRIMITIVE_UNKNOWN &&
        leftResult === rightResult
      ) {
        return leftResult;
      }
      return STATIC_PRIMITIVE_UNKNOWN;
    }
  }

  const primitiveValue = readStaticPrimitiveValue(unwrapped);
  if (primitiveValue === STATIC_PRIMITIVE_UNKNOWN) {
    if (isStaticallyBooleanValuedExpression(unwrapped)) {
      return false;
    }
    return STATIC_PRIMITIVE_UNKNOWN;
  }
  return false;
}

function collectVarScopeStatementBindings(
  statement: ts.Statement,
  declaredIdentifiers: Set<string>,
): void {
  if (ts.isLabeledStatement(statement)) {
    collectVarScopeStatementBindings(statement.statement, declaredIdentifiers);
    return;
  }

  if (ts.isVariableStatement(statement)) {
    if (isAmbientContextNode(statement)) return;
    const declarationList = statement.declarationList;
    const hasLexicalBindings =
      (declarationList.flags & (ts.NodeFlags.Let | ts.NodeFlags.Const)) !== 0;
    if (hasLexicalBindings) return;
    for (const declaration of declarationList.declarations) {
      for (const localName of collectBindingLocalNames(declaration.name)) {
        declaredIdentifiers.add(localName);
      }
    }
    return;
  }

  if (
    ts.isFunctionDeclaration(statement) ||
    ts.isClassDeclaration(statement) ||
    ts.isEnumDeclaration(statement)
  ) {
    return;
  }

  if (ts.isBlock(statement)) {
    for (const nestedStatement of statement.statements) {
      collectVarScopeStatementBindings(nestedStatement, declaredIdentifiers);
    }
    return;
  }

  if (ts.isIfStatement(statement)) {
    collectVarScopeStatementBindings(
      statement.thenStatement,
      declaredIdentifiers,
    );
    if (statement.elseStatement) {
      collectVarScopeStatementBindings(
        statement.elseStatement,
        declaredIdentifiers,
      );
    }
    return;
  }

  if (
    ts.isDoStatement(statement) ||
    ts.isWhileStatement(statement) ||
    ts.isWithStatement(statement)
  ) {
    collectVarScopeStatementBindings(statement.statement, declaredIdentifiers);
    return;
  }

  if (ts.isForStatement(statement)) {
    if (
      statement.initializer &&
      ts.isVariableDeclarationList(statement.initializer) &&
      (statement.initializer.flags &
        (ts.NodeFlags.Let | ts.NodeFlags.Const)) ===
        0
    ) {
      for (const declaration of statement.initializer.declarations) {
        for (const localName of collectBindingLocalNames(declaration.name)) {
          declaredIdentifiers.add(localName);
        }
      }
    }
    collectVarScopeStatementBindings(statement.statement, declaredIdentifiers);
    return;
  }

  if (ts.isForInStatement(statement) || ts.isForOfStatement(statement)) {
    if (
      ts.isVariableDeclarationList(statement.initializer) &&
      (statement.initializer.flags &
        (ts.NodeFlags.Let | ts.NodeFlags.Const)) ===
        0
    ) {
      for (const declaration of statement.initializer.declarations) {
        for (const localName of collectBindingLocalNames(declaration.name)) {
          declaredIdentifiers.add(localName);
        }
      }
    }
    collectVarScopeStatementBindings(statement.statement, declaredIdentifiers);
    return;
  }

  if (ts.isSwitchStatement(statement)) {
    for (const clause of statement.caseBlock.clauses) {
      for (const nestedStatement of clause.statements) {
        collectVarScopeStatementBindings(nestedStatement, declaredIdentifiers);
      }
    }
    return;
  }

  if (ts.isTryStatement(statement)) {
    for (const nestedStatement of statement.tryBlock.statements) {
      collectVarScopeStatementBindings(nestedStatement, declaredIdentifiers);
    }
    if (statement.catchClause) {
      for (const nestedStatement of statement.catchClause.block.statements) {
        collectVarScopeStatementBindings(nestedStatement, declaredIdentifiers);
      }
    }
    if (statement.finallyBlock) {
      for (const nestedStatement of statement.finallyBlock.statements) {
        collectVarScopeStatementBindings(nestedStatement, declaredIdentifiers);
      }
    }
  }
}

function collectStatementLexicalScopeBindings(
  statement: ts.Statement,
  declaredIdentifiers: Set<string>,
  includeVarDeclarations = false,
): void {
  if (ts.isLabeledStatement(statement)) {
    collectStatementLexicalScopeBindings(
      statement.statement,
      declaredIdentifiers,
      includeVarDeclarations,
    );
    return;
  }

  if (ts.isVariableStatement(statement)) {
    if (isAmbientContextNode(statement)) return;
    const declarationList = statement.declarationList;
    const hasLexicalBindings =
      (declarationList.flags & (ts.NodeFlags.Let | ts.NodeFlags.Const)) !== 0;
    if (!hasLexicalBindings && !includeVarDeclarations) {
      return;
    }
    for (const declaration of declarationList.declarations) {
      for (const localName of collectBindingLocalNames(declaration.name)) {
        declaredIdentifiers.add(localName);
      }
    }
    return;
  }

  if (
    (ts.isFunctionDeclaration(statement) ||
      ts.isClassDeclaration(statement) ||
      ts.isEnumDeclaration(statement)) &&
    statement.name &&
    !isAmbientContextNode(statement)
  ) {
    declaredIdentifiers.add(normalizeNamedSymbol(statement.name.text));
  }

  if (includeVarDeclarations) {
    collectVarScopeStatementBindings(statement, declaredIdentifiers);
  }
}

function collectLexicalScopeDeclaredIdentifiers(node: ts.Node): Set<string> {
  const declaredIdentifiers = new Set<string>();

  if (
    ts.isForStatement(node) &&
    node.initializer &&
    ts.isVariableDeclarationList(node.initializer) &&
    (node.initializer.flags & (ts.NodeFlags.Let | ts.NodeFlags.Const)) !== 0
  ) {
    for (const declaration of node.initializer.declarations) {
      for (const localName of collectBindingLocalNames(declaration.name)) {
        declaredIdentifiers.add(localName);
      }
    }
    return declaredIdentifiers;
  }

  if (
    (ts.isForInStatement(node) || ts.isForOfStatement(node)) &&
    ts.isVariableDeclarationList(node.initializer) &&
    (node.initializer.flags & (ts.NodeFlags.Let | ts.NodeFlags.Const)) !== 0
  ) {
    for (const declaration of node.initializer.declarations) {
      for (const localName of collectBindingLocalNames(declaration.name)) {
        declaredIdentifiers.add(localName);
      }
    }
    return declaredIdentifiers;
  }

  if (ts.isCatchClause(node)) {
    const variableDeclaration = node.variableDeclaration;
    if (variableDeclaration) {
      for (const localName of collectBindingLocalNames(
        variableDeclaration.name,
      )) {
        declaredIdentifiers.add(localName);
      }
    }
    for (const statement of node.block.statements) {
      collectStatementLexicalScopeBindings(statement, declaredIdentifiers);
    }
    return declaredIdentifiers;
  }

  if (
    ts.isBlock(node) &&
    node.parent?.kind === ts.SyntaxKind.ClassStaticBlockDeclaration
  ) {
    for (const statement of node.statements) {
      collectStatementLexicalScopeBindings(
        statement,
        declaredIdentifiers,
        true,
      );
    }
    return declaredIdentifiers;
  }

  const statements = ts.isCaseBlock(node)
    ? node.clauses.flatMap((clause) => clause.statements)
    : ts.isBlock(node) || ts.isModuleBlock(node)
      ? [...node.statements]
      : [];

  for (const statement of statements) {
    collectStatementLexicalScopeBindings(statement, declaredIdentifiers);
  }

  return declaredIdentifiers;
}

function resolveModuleSourceFromEntityName(
  name: ts.EntityName,
  moduleAliasByIdentifier: Map<string, string[]>,
): string[] {
  if (ts.isIdentifier(name)) {
    return moduleAliasByIdentifier.get(name.text) ?? [];
  }
  return resolveModuleSourceFromEntityName(name.left, moduleAliasByIdentifier);
}

function collectSymbolSourceReferences(
  contents: string,
  filePath: string,
): SymbolSourceReference[] {
  const references: SymbolSourceReference[] = [];
  const moduleAliasByIdentifier = new Map<string, string[]>();
  const requireLikeIdentifiers = new Set<string>(
    DEFAULT_REQUIRE_LIKE_IDENTIFIERS,
  );
  const sourceFile = ts.createSourceFile(
    filePath,
    contents,
    ts.ScriptTarget.Latest,
    true,
    getScriptKind(filePath),
  );

  const readSpecifierSymbols = (
    specifier: ts.ImportSpecifier | ts.ExportSpecifier,
  ): string[] => {
    const symbols = new Set<string>();
    symbols.add(normalizeNamedSymbol(specifier.name.text));
    if (specifier.propertyName) {
      symbols.add(normalizeNamedSymbol(specifier.propertyName.text));
    }
    return [...symbols].filter(Boolean);
  };

  const visit = (node: ts.Node) => {
    const scopeSnapshot = isLexicalScopeBoundary(node)
      ? {
          moduleAliases: cloneStringArrayMap(moduleAliasByIdentifier),
          requireLikeIdentifiers: new Set(requireLikeIdentifiers),
          declaredIdentifiers: collectLexicalScopeDeclaredIdentifiers(node),
          mergeNonLexicalMutations: shouldMergeNonLexicalScopeMutations(node),
        }
      : undefined;
    const functionScopeSnapshot = ts.isFunctionLike(node)
      ? {
          moduleAliases: cloneStringArrayMap(moduleAliasByIdentifier),
          requireLikeIdentifiers: new Set(requireLikeIdentifiers),
        }
      : undefined;

    if (functionScopeSnapshot) {
      for (const shadowedIdentifier of collectFunctionScopeShadowedIdentifiers(
        node,
      )) {
        moduleAliasByIdentifier.delete(shadowedIdentifier);
        requireLikeIdentifiers.delete(shadowedIdentifier);
      }
    }

    if (scopeSnapshot) {
      for (const shadowedIdentifier of scopeSnapshot.declaredIdentifiers) {
        moduleAliasByIdentifier.delete(shadowedIdentifier);
        requireLikeIdentifiers.delete(shadowedIdentifier);
      }
    }

    if (
      (ts.isFunctionDeclaration(node) ||
        ts.isClassDeclaration(node) ||
        ts.isEnumDeclaration(node)) &&
      node.name &&
      !isAmbientContextNode(node)
    ) {
      const shadowedIdentifier = normalizeNamedSymbol(node.name.text);
      if (shadowedIdentifier) {
        moduleAliasByIdentifier.delete(shadowedIdentifier);
        requireLikeIdentifiers.delete(shadowedIdentifier);
      }
    }

    if (ts.isImportDeclaration(node)) {
      const source = ts.isStringLiteralLike(node.moduleSpecifier)
        ? node.moduleSpecifier.text
        : undefined;
      if (source && node.importClause?.name) {
        moduleAliasByIdentifier.set(node.importClause.name.text, [source]);
        references.push({
          symbol: normalizeNamedSymbol(node.importClause.name.text),
          source,
        });
      }
      const namedBindings = node.importClause?.namedBindings;
      if (source && namedBindings) {
        if (ts.isNamespaceImport(namedBindings)) {
          moduleAliasByIdentifier.set(namedBindings.name.text, [source]);
        }
        if (ts.isNamedImports(namedBindings)) {
          for (const importSpecifier of namedBindings.elements) {
            for (const symbol of readSpecifierSymbols(importSpecifier)) {
              references.push({ symbol, source });
            }
          }
        }
      }
    }

    if (ts.isExportDeclaration(node)) {
      const source = node.moduleSpecifier;
      const namedExports = node.exportClause;
      if (
        source &&
        ts.isStringLiteralLike(source) &&
        namedExports &&
        ts.isNamedExports(namedExports)
      ) {
        for (const exportSpecifier of namedExports.elements) {
          for (const symbol of readSpecifierSymbols(exportSpecifier)) {
            references.push({ symbol, source: source.text });
          }
        }
      }
    }

    if (ts.isImportTypeNode(node)) {
      const argument = node.argument;
      if (
        ts.isLiteralTypeNode(argument) &&
        ts.isStringLiteralLike(argument.literal)
      ) {
        const symbol = normalizeNamedSymbol(
          readImportTypeQualifierSymbol(node.qualifier),
        );
        if (symbol) {
          references.push({ symbol, source: argument.literal.text });
        }
      }
    }

    if (ts.isQualifiedName(node)) {
      const sources = resolveModuleSourceFromEntityName(
        node.left,
        moduleAliasByIdentifier,
      );
      for (const source of sources) {
        references.push({
          symbol: normalizeNamedSymbol(node.right.text),
          source,
        });
      }
    }

    if (
      ts.isImportEqualsDeclaration(node) &&
      ts.isExternalModuleReference(node.moduleReference) &&
      node.moduleReference.expression &&
      ts.isStringLiteralLike(node.moduleReference.expression)
    ) {
      moduleAliasByIdentifier.set(node.name.text, [
        node.moduleReference.expression.text,
      ]);
      references.push({
        symbol: normalizeNamedSymbol(node.name.text),
        source: node.moduleReference.expression.text,
      });
    }

    if (ts.isVariableDeclaration(node) && ts.isIdentifier(node.name)) {
      if (isAmbientContextNode(node)) {
        ts.forEachChild(node, visit);
        return;
      }
      const initializer = node.initializer
        ? unwrapInitializerExpression(node.initializer)
        : undefined;
      if (initializer) {
        if (isRequireLikeExpression(initializer, requireLikeIdentifiers)) {
          requireLikeIdentifiers.add(node.name.text);
        } else {
          requireLikeIdentifiers.delete(node.name.text);
        }
      } else {
        requireLikeIdentifiers.delete(node.name.text);
      }
      const sources = initializer
        ? resolveModuleSourceFromExpression(
            initializer,
            moduleAliasByIdentifier,
            requireLikeIdentifiers,
          )
        : [];
      if (sources.length > 0) {
        moduleAliasByIdentifier.set(node.name.text, sources);
      } else {
        moduleAliasByIdentifier.delete(node.name.text);
      }
    }

    if (
      ts.isBinaryExpression(node) &&
      [
        ts.SyntaxKind.EqualsToken,
        ts.SyntaxKind.BarBarEqualsToken,
        ts.SyntaxKind.AmpersandAmpersandEqualsToken,
        ts.SyntaxKind.QuestionQuestionEqualsToken,
      ].includes(node.operatorToken.kind)
    ) {
      const rightExpression = unwrapInitializerExpression(node.right);
      const rightIsRequireLike = isRequireLikeExpression(
        rightExpression,
        requireLikeIdentifiers,
      );
      const sources = resolveModuleSourceFromExpression(
        rightExpression,
        moduleAliasByIdentifier,
        requireLikeIdentifiers,
      );

      if (ts.isIdentifier(node.left)) {
        if (rightIsRequireLike) {
          requireLikeIdentifiers.add(node.left.text);
        } else if (node.operatorToken.kind === ts.SyntaxKind.EqualsToken) {
          requireLikeIdentifiers.delete(node.left.text);
        }
        if (sources.length > 0) {
          moduleAliasByIdentifier.set(node.left.text, sources);
        } else if (node.operatorToken.kind === ts.SyntaxKind.EqualsToken) {
          moduleAliasByIdentifier.delete(node.left.text);
        }
      }

      if (node.operatorToken.kind === ts.SyntaxKind.EqualsToken) {
        const assignmentSymbols = collectAssignmentPatternSymbols(node.left);
        for (const source of sources) {
          for (const symbol of assignmentSymbols) {
            references.push({ symbol, source });
          }
        }

        const assignmentLocalNames = collectAssignmentPatternLocalNames(
          node.left,
        );
        if (!ts.isIdentifier(node.left)) {
          for (const localName of assignmentLocalNames) {
            requireLikeIdentifiers.delete(localName);
          }
        }
        if (sources.length > 0) {
          for (const localName of assignmentLocalNames) {
            moduleAliasByIdentifier.set(localName, sources);
          }
        } else {
          for (const localName of assignmentLocalNames) {
            moduleAliasByIdentifier.delete(localName);
          }
        }
      }
    }

    if (ts.isPropertyAccessExpression(node)) {
      const sources = resolveModuleSourceFromExpression(
        node.expression,
        moduleAliasByIdentifier,
        requireLikeIdentifiers,
      );
      for (const source of sources) {
        references.push({
          symbol: normalizeNamedSymbol(node.name.text),
          source,
        });
      }
    }

    if (
      ts.isElementAccessExpression(node) &&
      node.argumentExpression &&
      ts.isStringLiteralLike(node.argumentExpression)
    ) {
      const sources = resolveModuleSourceFromExpression(
        node.expression,
        moduleAliasByIdentifier,
        requireLikeIdentifiers,
      );
      for (const source of sources) {
        references.push({
          symbol: normalizeNamedSymbol(node.argumentExpression.text),
          source,
        });
      }
    }

    if (
      ts.isVariableDeclaration(node) &&
      (ts.isObjectBindingPattern(node.name) ||
        ts.isArrayBindingPattern(node.name))
    ) {
      const initializer = node.initializer
        ? unwrapInitializerExpression(node.initializer)
        : undefined;
      const sources = initializer
        ? resolveModuleSourceFromExpression(
            initializer,
            moduleAliasByIdentifier,
            requireLikeIdentifiers,
          )
        : [];
      const bindingLocalNames = collectBindingLocalNames(node.name);
      for (const localName of bindingLocalNames) {
        requireLikeIdentifiers.delete(localName);
      }
      if (sources.length > 0) {
        for (const localName of bindingLocalNames) {
          moduleAliasByIdentifier.set(localName, sources);
        }
      } else {
        for (const localName of bindingLocalNames) {
          moduleAliasByIdentifier.delete(localName);
        }
      }
      for (const source of sources) {
        for (const bindingElement of node.name.elements) {
          if (
            !ts.isBindingElement(bindingElement) ||
            bindingElement.dotDotDotToken
          ) {
            continue;
          }
          for (const symbol of collectBindingElementSymbols(bindingElement)) {
            references.push({
              symbol,
              source,
            });
          }
        }
      }
    }
    let handledChildren = false;
    if (ts.isIfStatement(node)) {
      handledChildren = true;
      visit(node.expression);
      const condition = readStaticBooleanCondition(node.expression);
      if (condition === true) {
        visit(node.thenStatement);
      } else if (condition === false) {
        if (node.elseStatement) {
          visit(node.elseStatement);
        }
      } else {
        const preBranchModuleAliases = cloneStringArrayMap(
          moduleAliasByIdentifier,
        );
        const preBranchRequireLikeIdentifiers = new Set(requireLikeIdentifiers);

        restoreStringArrayMap(moduleAliasByIdentifier, preBranchModuleAliases);
        restoreStringSet(
          requireLikeIdentifiers,
          preBranchRequireLikeIdentifiers,
        );
        visit(node.thenStatement);
        const thenModuleAliases = cloneStringArrayMap(moduleAliasByIdentifier);
        const thenRequireLikeIdentifiers = new Set(requireLikeIdentifiers);

        restoreStringArrayMap(moduleAliasByIdentifier, preBranchModuleAliases);
        restoreStringSet(
          requireLikeIdentifiers,
          preBranchRequireLikeIdentifiers,
        );
        if (node.elseStatement) {
          visit(node.elseStatement);
        }
        const elseModuleAliases = cloneStringArrayMap(moduleAliasByIdentifier);
        const elseRequireLikeIdentifiers = new Set(requireLikeIdentifiers);

        restoreStringArrayMap(
          moduleAliasByIdentifier,
          mergeModuleAliasMaps(thenModuleAliases, elseModuleAliases),
        );
        restoreStringSet(
          requireLikeIdentifiers,
          new Set([
            ...thenRequireLikeIdentifiers,
            ...elseRequireLikeIdentifiers,
          ]),
        );
      }
    }

    if (!handledChildren) {
      ts.forEachChild(node, visit);
    }

    if (scopeSnapshot) {
      const postScopeModuleAliases = cloneStringArrayMap(
        moduleAliasByIdentifier,
      );
      const postScopeRequireLikeIdentifiers = new Set(requireLikeIdentifiers);

      restoreStringArrayMap(
        moduleAliasByIdentifier,
        scopeSnapshot.moduleAliases,
      );
      restoreStringSet(
        requireLikeIdentifiers,
        scopeSnapshot.requireLikeIdentifiers,
      );

      if (scopeSnapshot.mergeNonLexicalMutations) {
        for (const [identifier, sources] of postScopeModuleAliases.entries()) {
          if (scopeSnapshot.declaredIdentifiers.has(identifier)) continue;
          const previousSources = scopeSnapshot.moduleAliases.get(identifier);
          if (!stringArraysEqual(previousSources, sources)) {
            moduleAliasByIdentifier.set(identifier, [...sources]);
          }
        }

        for (const identifier of scopeSnapshot.moduleAliases.keys()) {
          if (scopeSnapshot.declaredIdentifiers.has(identifier)) continue;
          if (!postScopeModuleAliases.has(identifier)) {
            moduleAliasByIdentifier.delete(identifier);
          }
        }

        for (const identifier of postScopeRequireLikeIdentifiers) {
          if (scopeSnapshot.declaredIdentifiers.has(identifier)) continue;
          if (!scopeSnapshot.requireLikeIdentifiers.has(identifier)) {
            requireLikeIdentifiers.add(identifier);
          }
        }

        for (const identifier of scopeSnapshot.requireLikeIdentifiers) {
          if (scopeSnapshot.declaredIdentifiers.has(identifier)) continue;
          if (!postScopeRequireLikeIdentifiers.has(identifier)) {
            requireLikeIdentifiers.delete(identifier);
          }
        }
      }
    } else if (functionScopeSnapshot) {
      restoreStringArrayMap(
        moduleAliasByIdentifier,
        functionScopeSnapshot.moduleAliases,
      );
      restoreStringSet(
        requireLikeIdentifiers,
        functionScopeSnapshot.requireLikeIdentifiers,
      );
    }

    if (
      ts.isFunctionDeclaration(node) &&
      node.name &&
      !isAmbientContextNode(node)
    ) {
      const shadowedIdentifier = normalizeNamedSymbol(node.name.text);
      if (shadowedIdentifier) {
        moduleAliasByIdentifier.delete(shadowedIdentifier);
        requireLikeIdentifiers.delete(shadowedIdentifier);
      }
    }
  };

  visit(sourceFile);
  const seenReferences = new Set<string>();
  return references.filter((reference) => {
    if (!reference.symbol.length) return false;
    const key = `${reference.symbol}@${reference.source}`;
    if (seenReferences.has(key)) return false;
    seenReferences.add(key);
    return true;
  });
}

function collectModuleSpecifierReferences(
  contents: string,
  filePath: string,
): ModuleSpecifierReference[] {
  const references: ModuleSpecifierReference[] = [];
  const requireLikeIdentifiers = new Set<string>(
    DEFAULT_REQUIRE_LIKE_IDENTIFIERS,
  );
  const sourceFile = ts.createSourceFile(
    filePath,
    contents,
    ts.ScriptTarget.Latest,
    true,
    getScriptKind(filePath),
  );

  const visit = (node: ts.Node) => {
    const scopeSnapshot = isLexicalScopeBoundary(node)
      ? {
          requireLikeIdentifiers: new Set(requireLikeIdentifiers),
          declaredIdentifiers: collectLexicalScopeDeclaredIdentifiers(node),
          mergeNonLexicalMutations: shouldMergeNonLexicalScopeMutations(node),
        }
      : undefined;
    const functionScopeSnapshot = ts.isFunctionLike(node)
      ? new Set(requireLikeIdentifiers)
      : undefined;

    if (functionScopeSnapshot) {
      for (const shadowedIdentifier of collectFunctionScopeShadowedIdentifiers(
        node,
      )) {
        requireLikeIdentifiers.delete(shadowedIdentifier);
      }
    }

    if (scopeSnapshot) {
      for (const shadowedIdentifier of scopeSnapshot.declaredIdentifiers) {
        requireLikeIdentifiers.delete(shadowedIdentifier);
      }
    }

    if (
      (ts.isFunctionDeclaration(node) ||
        ts.isClassDeclaration(node) ||
        ts.isEnumDeclaration(node)) &&
      node.name &&
      !isAmbientContextNode(node)
    ) {
      const shadowedIdentifier = normalizeNamedSymbol(node.name.text);
      if (shadowedIdentifier) {
        requireLikeIdentifiers.delete(shadowedIdentifier);
      }
    }

    if (
      ts.isImportDeclaration(node) &&
      ts.isStringLiteralLike(node.moduleSpecifier)
    ) {
      references.push({ source: node.moduleSpecifier.text, filePath });
    }

    if (
      ts.isImportEqualsDeclaration(node) &&
      ts.isExternalModuleReference(node.moduleReference) &&
      node.moduleReference.expression &&
      ts.isStringLiteralLike(node.moduleReference.expression)
    ) {
      references.push({
        source: node.moduleReference.expression.text,
        filePath,
      });
    }

    if (ts.isExportDeclaration(node)) {
      if (
        node.moduleSpecifier &&
        ts.isStringLiteralLike(node.moduleSpecifier)
      ) {
        references.push({ source: node.moduleSpecifier.text, filePath });
      }
    }

    if (ts.isImportTypeNode(node)) {
      const argument = node.argument;
      if (
        ts.isLiteralTypeNode(argument) &&
        ts.isStringLiteralLike(argument.literal)
      ) {
        references.push({ source: argument.literal.text, filePath });
      }
    }

    if (ts.isCallExpression(node)) {
      const source = readModuleSourceFromCallExpression(
        node,
        requireLikeIdentifiers,
      );
      if (source) references.push({ source, filePath });
    }

    if (ts.isVariableDeclaration(node) && ts.isIdentifier(node.name)) {
      if (isAmbientContextNode(node)) {
        ts.forEachChild(node, visit);
        return;
      }
      const initializer = node.initializer
        ? unwrapInitializerExpression(node.initializer)
        : undefined;
      if (initializer) {
        if (isRequireLikeExpression(initializer, requireLikeIdentifiers)) {
          requireLikeIdentifiers.add(node.name.text);
        } else {
          requireLikeIdentifiers.delete(node.name.text);
        }
      } else {
        requireLikeIdentifiers.delete(node.name.text);
      }
    }

    if (
      ts.isVariableDeclaration(node) &&
      (ts.isObjectBindingPattern(node.name) ||
        ts.isArrayBindingPattern(node.name))
    ) {
      for (const localName of collectBindingLocalNames(node.name)) {
        requireLikeIdentifiers.delete(localName);
      }
    }

    if (
      ts.isBinaryExpression(node) &&
      [
        ts.SyntaxKind.EqualsToken,
        ts.SyntaxKind.BarBarEqualsToken,
        ts.SyntaxKind.AmpersandAmpersandEqualsToken,
        ts.SyntaxKind.QuestionQuestionEqualsToken,
      ].includes(node.operatorToken.kind)
    ) {
      const rightExpression = unwrapInitializerExpression(node.right);
      if (ts.isIdentifier(node.left)) {
        if (isRequireLikeExpression(rightExpression, requireLikeIdentifiers)) {
          requireLikeIdentifiers.add(node.left.text);
        } else if (node.operatorToken.kind === ts.SyntaxKind.EqualsToken) {
          requireLikeIdentifiers.delete(node.left.text);
        }
      }

      if (
        node.operatorToken.kind === ts.SyntaxKind.EqualsToken &&
        !ts.isIdentifier(node.left)
      ) {
        for (const localName of collectAssignmentPatternLocalNames(node.left)) {
          requireLikeIdentifiers.delete(localName);
        }
      }
    }
    let handledChildren = false;
    if (ts.isIfStatement(node)) {
      handledChildren = true;
      visit(node.expression);
      const condition = readStaticBooleanCondition(node.expression);
      if (condition === true) {
        visit(node.thenStatement);
      } else if (condition === false) {
        if (node.elseStatement) {
          visit(node.elseStatement);
        }
      } else {
        const preBranchRequireLikeIdentifiers = new Set(requireLikeIdentifiers);

        restoreStringSet(
          requireLikeIdentifiers,
          preBranchRequireLikeIdentifiers,
        );
        visit(node.thenStatement);
        const thenRequireLikeIdentifiers = new Set(requireLikeIdentifiers);

        restoreStringSet(
          requireLikeIdentifiers,
          preBranchRequireLikeIdentifiers,
        );
        if (node.elseStatement) {
          visit(node.elseStatement);
        }
        const elseRequireLikeIdentifiers = new Set(requireLikeIdentifiers);

        restoreStringSet(
          requireLikeIdentifiers,
          new Set([
            ...thenRequireLikeIdentifiers,
            ...elseRequireLikeIdentifiers,
          ]),
        );
      }
    }

    if (!handledChildren) {
      ts.forEachChild(node, visit);
    }

    if (scopeSnapshot) {
      const postScopeRequireLikeIdentifiers = new Set(requireLikeIdentifiers);

      restoreStringSet(
        requireLikeIdentifiers,
        scopeSnapshot.requireLikeIdentifiers,
      );

      if (scopeSnapshot.mergeNonLexicalMutations) {
        for (const identifier of postScopeRequireLikeIdentifiers) {
          if (scopeSnapshot.declaredIdentifiers.has(identifier)) continue;
          if (!scopeSnapshot.requireLikeIdentifiers.has(identifier)) {
            requireLikeIdentifiers.add(identifier);
          }
        }

        for (const identifier of scopeSnapshot.requireLikeIdentifiers) {
          if (scopeSnapshot.declaredIdentifiers.has(identifier)) continue;
          if (!postScopeRequireLikeIdentifiers.has(identifier)) {
            requireLikeIdentifiers.delete(identifier);
          }
        }
      }
    } else if (functionScopeSnapshot) {
      restoreStringSet(requireLikeIdentifiers, functionScopeSnapshot);
    }

    if (
      ts.isFunctionDeclaration(node) &&
      node.name &&
      !isAmbientContextNode(node)
    ) {
      const shadowedIdentifier = normalizeNamedSymbol(node.name.text);
      if (shadowedIdentifier) {
        requireLikeIdentifiers.delete(shadowedIdentifier);
      }
    }
  };

  visit(sourceFile);
  return references;
}

function collectSdkSourceFilePaths(dirPath: string): string[] {
  const entries = fs.readdirSync(dirPath, { withFileTypes: true });
  const filePaths: string[] = [];
  for (const entry of entries) {
    const entryPath = path.join(dirPath, entry.name);
    if (entry.isDirectory()) {
      filePaths.push(...collectSdkSourceFilePaths(entryPath));
      continue;
    }
    if (!entry.isFile() || !/\.(?:[cm]?[jt]sx?)$/.test(entry.name)) continue;
    filePaths.push(entryPath);
  }
  return filePaths;
}

function collectDefaultImportNamesFromSource(
  sourceText: string,
  filePath: string,
  moduleName: string,
): string[] {
  const defaultImportNames: string[] = [];
  const sourceFile = ts.createSourceFile(
    filePath,
    sourceText,
    ts.ScriptTarget.Latest,
    true,
    getScriptKind(filePath),
  );

  const visit = (node: ts.Node) => {
    if (
      ts.isImportDeclaration(node) &&
      ts.isStringLiteralLike(node.moduleSpecifier) &&
      node.moduleSpecifier.text === moduleName &&
      node.importClause
    ) {
      if (node.importClause.name) {
        defaultImportNames.push(
          normalizeNamedSymbol(node.importClause.name.text),
        );
      }
      if (
        node.importClause.namedBindings &&
        ts.isNamedImports(node.importClause.namedBindings)
      ) {
        for (const importSpecifier of node.importClause.namedBindings
          .elements) {
          const importedName =
            importSpecifier.propertyName?.text ?? importSpecifier.name.text;
          if (importedName !== 'default') continue;
          defaultImportNames.push(
            normalizeNamedSymbol(importSpecifier.name.text),
          );
        }
      }
    }
    ts.forEachChild(node, visit);
  };

  visit(sourceFile);
  return [...new Set(defaultImportNames.filter(Boolean))];
}

function collectDefaultImportsFromModule(
  sourceFilePaths: readonly string[],
  moduleName: string,
): string[] {
  const defaultImports: string[] = [];
  for (const sourceFilePath of sourceFilePaths) {
    const contents = fs.readFileSync(sourceFilePath, 'utf8');
    const defaultImportNames = collectDefaultImportNamesFromSource(
      contents,
      sourceFilePath,
      moduleName,
    );
    for (const localName of defaultImportNames) {
      defaultImports.push(
        `${path.relative(process.cwd(), sourceFilePath)} -> ${localName}`,
      );
    }
  }
  return defaultImports;
}

function collectDefaultSymbolReferencesFromModule(
  sourceFilePaths: readonly string[],
  moduleName: string,
): string[] {
  const defaultReferences: string[] = [];
  for (const sourceFilePath of sourceFilePaths) {
    const contents = fs.readFileSync(sourceFilePath, 'utf8');
    const references = collectSymbolSourceReferences(contents, sourceFilePath);
    for (const reference of references) {
      if (reference.source !== moduleName || reference.symbol !== 'default') {
        continue;
      }
      defaultReferences.push(
        `${path.relative(process.cwd(), sourceFilePath)} -> ${reference.symbol}`,
      );
    }
  }
  return defaultReferences;
}

function isInfraModuleSpecifier(source: string): boolean {
  return (
    source === '@hyperlane-xyz/infra' ||
    source.startsWith('@hyperlane-xyz/infra/') ||
    source.includes('typescript/infra') ||
    source.includes('/infra/') ||
    source.includes('../../infra')
  );
}

function expectNoRipgrepMatches(pattern: string, description: string): void {
  try {
    const output = execFileSync(
      'rg',
      [pattern, 'src', '--glob', SOURCE_FILE_GLOB],
      {
        cwd: process.cwd(),
        encoding: 'utf8',
      },
    );
    expect.fail(`Found disallowed ${description}:\n${output}`);
  } catch (error) {
    const commandError = error as Error & { status?: number };
    // rg exits with status 1 when no matches are found.
    if (commandError.status === 1) {
      return;
    }
    throw error;
  }
}

describe('Gnosis Safe migration guards', () => {
  it('extracts wildcard module re-exports with fallback symbols', () => {
    const source = "export * from './fixtures/guard-module.js';";
    const symbols = extractNamedExportSymbols(
      source,
      './fixtures/guard-module.js',
      'fixture.ts',
      ['getSafe', 'createSafeTransaction', 'getSafe'],
    );
    expect(symbols).to.deep.equal(['getSafe', 'createSafeTransaction']);
  });

  it('tracks export aliases by their public symbol names', () => {
    const source =
      "export { internalGetSafe as getSafe } from './fixtures/guard-module.js';";
    const symbols = extractNamedExportSymbols(
      source,
      './fixtures/guard-module.js',
      'fixture.ts',
    );
    expect(symbols).to.deep.equal(['getSafe']);
  });

  it('tracks type-only named export specifiers', () => {
    const source =
      "export { type getSafe as getSafe } from './fixtures/guard-module.js';";
    const references = extractNamedExportSymbolReferences(
      source,
      './fixtures/guard-module.js',
      'fixture.ts',
    );
    expect(references).to.deep.equal([{ symbol: 'getSafe', isTypeOnly: true }]);
  });

  it('tracks mixed value and type named export specifiers', () => {
    const source =
      "export { type ParseableSafeTx, getSafe } from './fixtures/guard-module.js';";
    const references = extractNamedExportSymbolReferences(
      source,
      './fixtures/guard-module.js',
      'fixture.ts',
    );
    expect(references).to.deep.equal([
      { symbol: 'ParseableSafeTx', isTypeOnly: true },
      { symbol: 'getSafe', isTypeOnly: false },
    ]);
  });

  it('detects runtime export when symbol is exported as both type and value', () => {
    const references: NamedExportSymbolReference[] = [
      { symbol: 'getSafe', isTypeOnly: true },
      { symbol: 'getSafe', isTypeOnly: false },
    ];
    expect(hasValueExport(references, 'getSafe')).to.equal(true);
  });

  it('rejects runtime export when symbol is only type-exported', () => {
    const references: NamedExportSymbolReference[] = [
      { symbol: 'ParseableSafeTx', isTypeOnly: true },
      { symbol: 'SafeCallData', isTypeOnly: true },
    ];
    expect(hasValueExport(references, 'ParseableSafeTx')).to.equal(false);
  });

  it('ignores type-only wildcard module re-exports for fallback symbols', () => {
    const source = "export type * from './fixtures/guard-module.js';";
    const symbols = extractNamedExportSymbols(
      source,
      './fixtures/guard-module.js',
      'fixture.ts',
      ['getSafe', 'createSafeTransaction'],
    );
    expect(symbols).to.deep.equal([]);
  });

  it('extracts local export specifier aliases from source declarations', () => {
    const source = [
      'const internalCall = 1;',
      'export { internalCall as SafeCallData };',
      'const internalStatus = 2;',
      'export { internalStatus as SafeStatus };',
    ].join('\n');
    const symbols = extractTopLevelDeclarationExports(source, 'fixture.ts');
    expect(symbols).to.deep.equal(['SafeCallData', 'SafeStatus']);
  });

  it('ignores default exports in top-level declaration extraction', () => {
    const source = [
      'export default function internalDefault() { return 1; }',
      'export function getSafe() { return 2; }',
      'export default class InternalDefaultClass {}',
      'export class SafeStatus {}',
    ].join('\n');
    const symbols = extractTopLevelDeclarationExports(source, 'fixture.ts');
    expect(symbols).to.deep.equal(['getSafe', 'SafeStatus']);
  });

  it('detects default export assignments in source-file scan', () => {
    const source = [
      'const internalValue = 1;',
      'export default internalValue;',
    ].join('\n');
    expect(hasDefaultExportInSourceFile(source, 'fixture.ts')).to.equal(true);
  });

  it('detects local default export alias declarations', () => {
    const source = [
      'const getSafe = () => 1;',
      'export { getSafe as default };',
    ].join('\n');
    expect(hasDefaultExportInSourceFile(source, 'fixture.ts')).to.equal(true);
  });

  it('detects type-only local default export alias declarations', () => {
    const source = [
      'type SafeType = { safe: true };',
      'export { type SafeType as default };',
    ].join('\n');
    expect(hasDefaultExportInSourceFile(source, 'fixture.ts')).to.equal(true);
  });

  it('does not treat aliased default re-exports as module default export', () => {
    const source =
      "export { default as SafeDefault } from './fixtures/guard-module.js';";
    expect(hasDefaultExportInSourceFile(source, 'fixture.ts')).to.equal(false);
  });

  it('detects direct default re-exports as module default export', () => {
    const source = "export { default } from './fixtures/guard-module.js';";
    expect(hasDefaultExportInSourceFile(source, 'fixture.ts')).to.equal(true);
  });

  it('detects default re-exports from specific modules', () => {
    const source = [
      "export { default as SafeDefault } from './fixtures/guard-module.js';",
      "export { getSafe } from './fixtures/guard-module.js';",
    ].join('\n');
    expect(
      hasDefaultReExportFromModule(
        source,
        'fixture.ts',
        './fixtures/guard-module.js',
      ),
    ).to.equal(true);
    expect(
      hasDefaultReExportFromModule(source, 'fixture.ts', './fixtures/other.js'),
    ).to.equal(false);
  });

  it('detects namespace default re-exports from specific modules', () => {
    const source = [
      "export * as default from './fixtures/guard-module.js';",
      "export * as helpers from './fixtures/guard-module.js';",
    ].join('\n');
    expect(
      hasDefaultReExportFromModule(
        source,
        'fixture.ts',
        './fixtures/guard-module.js',
      ),
    ).to.equal(true);
    expect(
      hasDefaultReExportFromModule(source, 'fixture.ts', './fixtures/other.js'),
    ).to.equal(false);
  });

  it('detects type-only default re-exports from specific modules', () => {
    const source = [
      "export { type SafeType as default } from './fixtures/guard-module.js';",
      "export { type HelperType } from './fixtures/guard-module.js';",
    ].join('\n');
    expect(
      hasDefaultReExportFromModule(
        source,
        'fixture.ts',
        './fixtures/guard-module.js',
      ),
    ).to.equal(true);
    expect(
      hasDefaultReExportFromModule(source, 'fixture.ts', './fixtures/other.js'),
    ).to.equal(false);
  });

  it('tracks aliased named import and export symbols from module specifiers', () => {
    const source = [
      "import { SafeApiKit as SafeApiAlias } from './fixtures/guard-module.js';",
      "export { getSafe as getSafeAlias } from './fixtures/guard-module.js';",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('SafeApiKit@./fixtures/guard-module.js');
    expect(references).to.include('SafeApiAlias@./fixtures/guard-module.js');
    expect(references).to.include('getSafe@./fixtures/guard-module.js');
    expect(references).to.include('getSafeAlias@./fixtures/guard-module.js');
  });

  it('tracks default import local symbol names from module specifiers', () => {
    const source = "import SafeSdk from './fixtures/guard-module.js';";
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('SafeSdk@./fixtures/guard-module.js');
  });

  it('tracks import-equals local symbol names from module specifiers', () => {
    const source = "import getSafe = require('./fixtures/guard-module.js');";
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('getSafe@./fixtures/guard-module.js');
  });

  it('collects value and type-only default imports from source text', () => {
    const source = [
      "import SafeSdk from '@fixtures/guard-module';",
      "import type SafeType from '@fixtures/guard-module';",
      "import { default as SafeAlias } from '@fixtures/guard-module';",
      "import { type default as SafeTypeAlias } from '@fixtures/guard-module';",
      "import type { default as SafeTypeClauseAlias } from '@fixtures/guard-module';",
      "import { default } from '@fixtures/guard-module';",
      "import { getSafe } from '@fixtures/guard-module';",
      "import SafeOther from '@fixtures/other-module';",
    ].join('\n');
    const defaultImports = collectDefaultImportNamesFromSource(
      source,
      'fixture.ts',
      '@fixtures/guard-module',
    );
    expect(defaultImports).to.deep.equal([
      'SafeSdk',
      'SafeType',
      'SafeAlias',
      'SafeTypeAlias',
      'SafeTypeClauseAlias',
      'default',
    ]);
  });

  it('deduplicates default import names from repeated clauses', () => {
    const source = [
      "import SafeSdk from '@fixtures/guard-module';",
      "import { default as SafeSdk } from '@fixtures/guard-module';",
      "import type { default as SafeSdk } from '@fixtures/guard-module';",
    ].join('\n');
    const defaultImports = collectDefaultImportNamesFromSource(
      source,
      'fixture.ts',
      '@fixtures/guard-module',
    );
    expect(defaultImports).to.deep.equal(['SafeSdk']);
  });

  it('collects module specifiers from comma-wrapped require call targets', () => {
    const source = [
      "const directRequire = require('./fixtures/guard-module.js');",
      "const wrappedRequire = (0, require)('./fixtures/other-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('collects module specifiers from aliased require call targets', () => {
    const source = [
      'const reqAlias = require;',
      "const aliasRequire = reqAlias('./fixtures/guard-module.js');",
      'const nextAlias = reqAlias;',
      "const wrappedAliasRequire = (0, nextAlias)('./fixtures/other-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('collects module specifiers from logical-assignment require aliases', () => {
    const source = [
      'let reqAlias: any;',
      'reqAlias ||= require;',
      "const orAssignedRequire = reqAlias('./fixtures/guard-module.js');",
      'reqAlias &&= require;',
      "const andAssignedRequire = reqAlias('./fixtures/other-module.js');",
      'reqAlias ??= require;',
      "const nullishAssignedRequire = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('collects module specifiers from require aliases across shadowed scopes', () => {
    const source = [
      'let reqAlias: any = require;',
      '{',
      '  const reqAlias = () => undefined;',
      '  void reqAlias;',
      '}',
      "const postShadowRequire = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
  });

  it('does not leak require aliases across function parameter shadows', () => {
    const source = [
      'const reqAlias = require;',
      'function run(reqAlias: any) {',
      "  return reqAlias('./fixtures/other-module.js');",
      '}',
      "const outerCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps function-scope type-alias declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'function run() {',
      "  reqAlias('./fixtures/other-module.js');",
      '  type reqAlias = (_value: unknown) => unknown;',
      '}',
      'run();',
      "const outerCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps function-scope interface declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'function run() {',
      "  reqAlias('./fixtures/other-module.js');",
      '  interface reqAlias {',
      '    value: string;',
      '  }',
      '}',
      'run();',
      "const outerCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps function-scope ambient class declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'function run() {',
      "  reqAlias('./fixtures/other-module.js');",
      '  declare class reqAlias {}',
      '}',
      'run();',
      "const outerCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps function-scope ambient enum declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'function run() {',
      "  reqAlias('./fixtures/other-module.js');",
      '  declare enum reqAlias {',
      '    Marker = 0,',
      '  }',
      '}',
      'run();',
      "const outerCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps function-scope ambient function declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'function run() {',
      "  reqAlias('./fixtures/other-module.js');",
      '  declare function reqAlias(_path: string): unknown;',
      '}',
      'run();',
      "const outerCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps function-scope ambient namespace declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'function run() {',
      "  reqAlias('./fixtures/other-module.js');",
      '  declare namespace reqAlias {',
      '    const marker: unknown;',
      '  }',
      '}',
      'run();',
      "const outerCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps function-scope ambient module declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'function run() {',
      "  reqAlias('./fixtures/other-module.js');",
      '  declare module reqAlias {',
      '    const marker: unknown;',
      '  }',
      '}',
      'run();',
      "const outerCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps function-scope ambient const declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'function run() {',
      "  reqAlias('./fixtures/other-module.js');",
      '  declare const reqAlias: (_path: string) => unknown;',
      '}',
      'run();',
      "const outerCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps function-scope ambient let declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'function run() {',
      "  reqAlias('./fixtures/other-module.js');",
      '  declare let reqAlias: (_path: string) => unknown;',
      '}',
      'run();',
      "const outerCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps function-scope ambient var declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'function run() {',
      "  reqAlias('./fixtures/other-module.js');",
      '  declare var reqAlias: (_path: string) => unknown;',
      '}',
      'run();',
      "const outerCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('does not leak function-scope enum alias shadowing before declaration to outer module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'function run() {',
      "  reqAlias('./fixtures/other-module.js');",
      '  enum reqAlias {',
      '    Marker = 0,',
      '  }',
      '}',
      'run();',
      "const outerCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('does not leak function-scope enum alias declarations to outer module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'function run() {',
      '  enum reqAlias {',
      '    Marker = 0,',
      '  }',
      "  reqAlias('./fixtures/other-module.js');",
      '}',
      'run();',
      "const outerCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('does not leak function-scope class alias shadowing before declaration to outer module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'function run() {',
      "  reqAlias('./fixtures/other-module.js');",
      '  class reqAlias {}',
      '}',
      'run();',
      "const outerCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('does not leak function-scope class alias declarations to outer module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'function run() {',
      '  class reqAlias {}',
      "  reqAlias('./fixtures/other-module.js');",
      '}',
      'run();',
      "const outerCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps module specifier detection when require is ambient-declared as variable', () => {
    const source = [
      'declare const require: unknown;',
      "const ambientDeclaredCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
  });

  it('keeps module specifier detection when require is ambient-declared as function', () => {
    const source = [
      'declare function require(path: string): unknown;',
      "const ambientDeclaredCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
  });

  it('keeps module specifier detection when require is ambient-declared as class', () => {
    const source = [
      'declare class require {}',
      "const ambientDeclaredCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
  });

  it('keeps module specifier detection when require is ambient-declared as enum', () => {
    const source = [
      'declare enum require {',
      '  Marker = 0,',
      '}',
      "const ambientDeclaredCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
  });

  it('keeps module specifier detection when require is ambient-declared as namespace', () => {
    const source = [
      'declare namespace require {',
      '  const marker: unknown;',
      '}',
      "const ambientDeclaredCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
  });

  it('keeps module specifier detection when require is ambient-declared as module', () => {
    const source = [
      'declare module require {',
      '  const marker: unknown;',
      '}',
      "const ambientDeclaredCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
  });

  it('keeps module specifier detection when require is ambient-declared as let', () => {
    const source = [
      'declare let require: (path: string) => unknown;',
      "const ambientDeclaredCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
  });

  it('keeps module specifier detection when require is ambient-declared as var', () => {
    const source = [
      'declare var require: (path: string) => unknown;',
      "const ambientDeclaredCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
  });

  it('keeps module specifier detection when require has a type-alias declaration', () => {
    const source = [
      'type require = (path: string) => unknown;',
      "const ambientDeclaredCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
  });

  it('keeps module specifier detection when require has an interface declaration', () => {
    const source = [
      'interface require {',
      '  (path: string): unknown;',
      '}',
      "const ambientDeclaredCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
  });

  it('does not treat shadowed require parameter calls as module specifiers', () => {
    const source = [
      "const outerRequire = require('./fixtures/guard-module.js');",
      'function run(require: any) {',
      "  return require('./fixtures/other-module.js');",
      '}',
      'void outerRequire;',
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps try-block ambient class declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'try {',
      "  reqAlias('./fixtures/other-module.js');",
      '  declare class reqAlias {}',
      '} catch {}',
      "const postTryCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps try-block ambient enum declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'try {',
      "  reqAlias('./fixtures/other-module.js');",
      '  declare enum reqAlias {',
      '    Marker = 0,',
      '  }',
      '} catch {}',
      "const postTryCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps try-block ambient function declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'try {',
      "  reqAlias('./fixtures/other-module.js');",
      '  declare function reqAlias(path: string): unknown;',
      '} catch {}',
      "const postTryCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps try-block ambient namespace declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'try {',
      "  reqAlias('./fixtures/other-module.js');",
      '  declare namespace reqAlias {',
      '    const marker: unknown;',
      '  }',
      '} catch {}',
      "const postTryCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps try-block ambient module declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'try {',
      "  reqAlias('./fixtures/other-module.js');",
      '  declare module reqAlias {',
      '    const marker: unknown;',
      '  }',
      '} catch {}',
      "const postTryCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps try-block type-alias declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'try {',
      "  reqAlias('./fixtures/other-module.js');",
      '  type reqAlias = (_path: string) => unknown;',
      '} catch {}',
      "const postTryCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps try-block interface declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'try {',
      "  reqAlias('./fixtures/other-module.js');",
      '  interface reqAlias {',
      '    (_path: string): unknown;',
      '  }',
      '} catch {}',
      "const postTryCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps finally-block ambient class declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'try {} finally {',
      "  reqAlias('./fixtures/other-module.js');",
      '  declare class reqAlias {}',
      '}',
      "const postFinallyCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps finally-block ambient enum declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'try {} finally {',
      "  reqAlias('./fixtures/other-module.js');",
      '  declare enum reqAlias {',
      '    Marker = 0,',
      '  }',
      '}',
      "const postFinallyCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps finally-block ambient function declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'try {} finally {',
      "  reqAlias('./fixtures/other-module.js');",
      '  declare function reqAlias(path: string): unknown;',
      '}',
      "const postFinallyCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps finally-block ambient namespace declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'try {} finally {',
      "  reqAlias('./fixtures/other-module.js');",
      '  declare namespace reqAlias {',
      '    const marker: unknown;',
      '  }',
      '}',
      "const postFinallyCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps finally-block ambient module declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'try {} finally {',
      "  reqAlias('./fixtures/other-module.js');",
      '  declare module reqAlias {',
      '    const marker: unknown;',
      '  }',
      '}',
      "const postFinallyCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps finally-block type-alias declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'try {} finally {',
      "  reqAlias('./fixtures/other-module.js');",
      '  type reqAlias = (_path: string) => unknown;',
      '}',
      "const postFinallyCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps finally-block interface declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'try {} finally {',
      "  reqAlias('./fixtures/other-module.js');",
      '  interface reqAlias {',
      '    (_path: string): unknown;',
      '  }',
      '}',
      "const postFinallyCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps try-block ambient const declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'try {',
      "  reqAlias('./fixtures/other-module.js');",
      '  declare const reqAlias: (_path: string) => unknown;',
      '} catch {}',
      "const postTryCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps try-block ambient let declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'try {',
      "  reqAlias('./fixtures/other-module.js');",
      '  declare let reqAlias: (_path: string) => unknown;',
      '} catch {}',
      "const postTryCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps try-block ambient var declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'try {',
      "  reqAlias('./fixtures/other-module.js');",
      '  declare var reqAlias: (_path: string) => unknown;',
      '} catch {}',
      "const postTryCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps finally-block ambient const declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'try {} finally {',
      "  reqAlias('./fixtures/other-module.js');",
      '  declare const reqAlias: (_path: string) => unknown;',
      '}',
      "const postFinallyCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps finally-block ambient let declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'try {} finally {',
      "  reqAlias('./fixtures/other-module.js');",
      '  declare let reqAlias: (_path: string) => unknown;',
      '}',
      "const postFinallyCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps finally-block ambient var declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'try {} finally {',
      "  reqAlias('./fixtures/other-module.js');",
      '  declare var reqAlias: (_path: string) => unknown;',
      '}',
      "const postFinallyCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('does not leak require shadowing across catch clause scopes', () => {
    const source = [
      'try {',
      "  throw new Error('boom');",
      '} catch (require) {',
      "  require('./fixtures/other-module.js');",
      '}',
      "const postCatchCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('does not leak catch-block lexical alias declarations to outer module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'try {',
      "  throw new Error('boom');",
      '} catch (error) {',
      '  const reqAlias = () => undefined;',
      "  reqAlias('./fixtures/other-module.js');",
      '}',
      "const postCatchCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('does not leak catch-block lexical alias shadowing before declaration to outer module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'try {',
      "  throw new Error('boom');",
      '} catch (error) {',
      "  reqAlias('./fixtures/other-module.js');",
      '  const reqAlias = () => undefined;',
      '  void error;',
      '}',
      "const postCatchCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps catch-block type-alias declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'try {',
      "  throw new Error('boom');",
      '} catch (error) {',
      "  reqAlias('./fixtures/other-module.js');",
      '  type reqAlias = (_value: unknown) => unknown;',
      '  void error;',
      '}',
      "const postCatchCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps catch-block interface declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'try {',
      "  throw new Error('boom');",
      '} catch (error) {',
      "  reqAlias('./fixtures/other-module.js');",
      '  interface reqAlias {',
      '    value: string;',
      '  }',
      '  void error;',
      '}',
      "const postCatchCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps catch-block ambient class declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'try {',
      '  throw new Error("boom");',
      '} catch (_error) {',
      "  reqAlias('./fixtures/other-module.js');",
      '  declare class reqAlias {}',
      '}',
      "const postCatchCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps catch-block ambient enum declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'try {',
      '  throw new Error("boom");',
      '} catch (_error) {',
      "  reqAlias('./fixtures/other-module.js');",
      '  declare enum reqAlias {',
      '    Marker = 0,',
      '  }',
      '}',
      "const postCatchCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps catch-block ambient function declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'try {',
      '  throw new Error("boom");',
      '} catch (_error) {',
      "  reqAlias('./fixtures/other-module.js');",
      '  declare function reqAlias(_path: string): unknown;',
      '}',
      "const postCatchCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps catch-block ambient namespace declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'try {',
      '  throw new Error("boom");',
      '} catch (_error) {',
      "  reqAlias('./fixtures/other-module.js');",
      '  declare namespace reqAlias {',
      '    const marker: unknown;',
      '  }',
      '}',
      "const postCatchCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps catch-block ambient module declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'try {',
      '  throw new Error("boom");',
      '} catch (_error) {',
      "  reqAlias('./fixtures/other-module.js');",
      '  declare module reqAlias {',
      '    const marker: unknown;',
      '  }',
      '}',
      "const postCatchCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps catch-block ambient const declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'try {',
      '  throw new Error("boom");',
      '} catch (_error) {',
      "  reqAlias('./fixtures/other-module.js');",
      '  declare const reqAlias: (_path: string) => unknown;',
      '}',
      "const postCatchCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps catch-block ambient let declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'try {',
      '  throw new Error("boom");',
      '} catch (_error) {',
      "  reqAlias('./fixtures/other-module.js');",
      '  declare let reqAlias: (_path: string) => unknown;',
      '}',
      "const postCatchCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps catch-block ambient var declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'try {',
      '  throw new Error("boom");',
      '} catch (_error) {',
      "  reqAlias('./fixtures/other-module.js');",
      '  declare var reqAlias: (_path: string) => unknown;',
      '}',
      "const postCatchCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('does not leak hoisted catch-block function alias shadowing to outer module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'try {',
      "  throw new Error('boom');",
      '} catch (error) {',
      "  reqAlias('./fixtures/other-module.js');",
      '  function reqAlias(_value: unknown) {',
      '    return _value;',
      '  }',
      '  void error;',
      '}',
      "const postCatchCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('does not leak catch-block class alias declarations to outer module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'try {',
      "  throw new Error('boom');",
      '} catch (error) {',
      '  class reqAlias {}',
      "  reqAlias('./fixtures/other-module.js');",
      '}',
      "const postCatchCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('does not leak catch-block class alias shadowing before declaration to outer module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'try {',
      "  throw new Error('boom');",
      '} catch (error) {',
      "  reqAlias('./fixtures/other-module.js');",
      '  class reqAlias {}',
      '  void error;',
      '}',
      "const postCatchCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('does not leak catch-block enum alias shadowing before declaration to outer module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'try {',
      "  throw new Error('boom');",
      '} catch (error) {',
      "  reqAlias('./fixtures/other-module.js');",
      '  enum reqAlias {',
      '    Marker = 0,',
      '  }',
      '  void error;',
      '}',
      "const postCatchCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('does not leak catch-block enum alias declarations to outer module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'try {',
      "  throw new Error('boom');",
      '} catch (error) {',
      '  enum reqAlias {',
      '    Marker = 0,',
      '  }',
      "  reqAlias('./fixtures/other-module.js');",
      '}',
      "const postCatchCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('does not leak catch binding-pattern require shadowing to outer module specifiers', () => {
    const source = [
      "const outerRequire = require('./fixtures/guard-module.js');",
      'try {',
      '  throw { require: () => undefined };',
      '} catch ({ require }) {',
      "  require('./fixtures/other-module.js');",
      '}',
      'void outerRequire;',
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('does not leak catch binding-pattern alias shadowing to outer module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'try {',
      '  throw { reqAlias: () => undefined };',
      '} catch ({ reqAlias }) {',
      "  reqAlias('./fixtures/other-module.js');",
      '}',
      "const postCatchCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('does not leak nested catch binding-pattern require shadowing to outer module specifiers', () => {
    const source = [
      "const outerRequire = require('./fixtures/guard-module.js');",
      'try {',
      '  throw { nested: { require: () => undefined } };',
      '} catch ({ nested: { require } }) {',
      "  require('./fixtures/other-module.js');",
      '}',
      'void outerRequire;',
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('does not leak nested catch binding-pattern alias shadowing to outer module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'try {',
      '  throw { nested: { reqAlias: () => undefined } };',
      '} catch ({ nested: { reqAlias } }) {',
      "  reqAlias('./fixtures/other-module.js');",
      '}',
      "const postCatchCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps require alias var declarations made inside catch block scopes', () => {
    const source = [
      'let reqAlias: any;',
      'try {',
      "  throw new Error('boom');",
      '} catch (error) {',
      '  var reqAlias = require;',
      '}',
      "const postCatchCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
  });

  it('clears require alias var declarations to non-require values inside catch block scopes', () => {
    const source = [
      'let reqAlias: any = require;',
      'try {',
      "  throw new Error('boom');",
      '} catch (error) {',
      '  var reqAlias = () => undefined;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('does not leak require shadowing across lexical for-loop scopes', () => {
    const source = [
      'const reqAlias = require;',
      'for (const reqAlias of [() => undefined]) {',
      "  reqAlias('./fixtures/other-module.js');",
      '}',
      "const postLoopCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps lexical for-loop type-alias declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'for (const iteration of [1]) {',
      "  reqAlias('./fixtures/other-module.js');",
      '  type reqAlias = (_value: unknown) => unknown;',
      '  void iteration;',
      '}',
      "const postLoopCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps lexical for-loop interface declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'for (const iteration of [1]) {',
      "  reqAlias('./fixtures/other-module.js');",
      '  interface reqAlias {',
      '    value: string;',
      '  }',
      '  void iteration;',
      '}',
      "const postLoopCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps lexical for-loop ambient class declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'for (const iteration of [1]) {',
      "  reqAlias('./fixtures/other-module.js');",
      '  declare class reqAlias {}',
      '  void iteration;',
      '}',
      "const postLoopCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps lexical for-loop ambient enum declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'for (const iteration of [1]) {',
      "  reqAlias('./fixtures/other-module.js');",
      '  declare enum reqAlias {',
      '    Marker = 0,',
      '  }',
      '  void iteration;',
      '}',
      "const postLoopCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps lexical for-loop ambient function declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'for (const iteration of [1]) {',
      "  reqAlias('./fixtures/other-module.js');",
      '  declare function reqAlias(_path: string): unknown;',
      '  void iteration;',
      '}',
      "const postLoopCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps lexical for-loop ambient namespace declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'for (const iteration of [1]) {',
      "  reqAlias('./fixtures/other-module.js');",
      '  declare namespace reqAlias {',
      '    const marker: unknown;',
      '  }',
      '  void iteration;',
      '}',
      "const postLoopCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps lexical for-loop ambient module declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'for (const iteration of [1]) {',
      "  reqAlias('./fixtures/other-module.js');",
      '  declare module reqAlias {',
      '    const marker: unknown;',
      '  }',
      '  void iteration;',
      '}',
      "const postLoopCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps lexical for-loop ambient const declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'for (const iteration of [1]) {',
      "  reqAlias('./fixtures/other-module.js');",
      '  declare const reqAlias: (_path: string) => unknown;',
      '  void iteration;',
      '}',
      "const postLoopCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps lexical for-loop ambient let declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'for (const iteration of [1]) {',
      "  reqAlias('./fixtures/other-module.js');",
      '  declare let reqAlias: (_path: string) => unknown;',
      '  void iteration;',
      '}',
      "const postLoopCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps lexical for-loop ambient var declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'for (const iteration of [1]) {',
      "  reqAlias('./fixtures/other-module.js');",
      '  declare var reqAlias: (_path: string) => unknown;',
      '  void iteration;',
      '}',
      "const postLoopCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps while-block type-alias declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'while (true) {',
      "  reqAlias('./fixtures/other-module.js');",
      '  type reqAlias = (_path: string) => unknown;',
      '  break;',
      '}',
      "const postWhileCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps while-block interface declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'while (true) {',
      "  reqAlias('./fixtures/other-module.js');",
      '  interface reqAlias {',
      '    value: string;',
      '  }',
      '  break;',
      '}',
      "const postWhileCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps while-block ambient class declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'while (true) {',
      "  reqAlias('./fixtures/other-module.js');",
      '  declare class reqAlias {}',
      '  break;',
      '}',
      "const postWhileCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps while-block ambient enum declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'while (true) {',
      "  reqAlias('./fixtures/other-module.js');",
      '  declare enum reqAlias {',
      '    Marker = 0,',
      '  }',
      '  break;',
      '}',
      "const postWhileCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps while-block ambient function declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'while (true) {',
      "  reqAlias('./fixtures/other-module.js');",
      '  declare function reqAlias(_path: string): unknown;',
      '  break;',
      '}',
      "const postWhileCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps while-block ambient namespace declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'while (true) {',
      "  reqAlias('./fixtures/other-module.js');",
      '  declare namespace reqAlias {',
      '    const marker: unknown;',
      '  }',
      '  break;',
      '}',
      "const postWhileCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps while-block ambient module declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'while (true) {',
      "  reqAlias('./fixtures/other-module.js');",
      '  declare module reqAlias {',
      '    const marker: unknown;',
      '  }',
      '  break;',
      '}',
      "const postWhileCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps while-block ambient const declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'while (true) {',
      "  reqAlias('./fixtures/other-module.js');",
      '  declare const reqAlias: (_path: string) => unknown;',
      '  break;',
      '}',
      "const postWhileCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps while-block ambient let declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'while (true) {',
      "  reqAlias('./fixtures/other-module.js');",
      '  declare let reqAlias: (_path: string) => unknown;',
      '  break;',
      '}',
      "const postWhileCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps while-block ambient var declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'while (true) {',
      "  reqAlias('./fixtures/other-module.js');",
      '  declare var reqAlias: (_path: string) => unknown;',
      '  break;',
      '}',
      "const postWhileCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps do-while type-alias declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'do {',
      "  reqAlias('./fixtures/other-module.js');",
      '  type reqAlias = (_path: string) => unknown;',
      '} while (false);',
      "const postDoWhileCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps do-while interface declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'do {',
      "  reqAlias('./fixtures/other-module.js');",
      '  interface reqAlias {',
      '    value: string;',
      '  }',
      '} while (false);',
      "const postDoWhileCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps do-while ambient class declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'do {',
      "  reqAlias('./fixtures/other-module.js');",
      '  declare class reqAlias {}',
      '} while (false);',
      "const postDoWhileCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps do-while ambient enum declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'do {',
      "  reqAlias('./fixtures/other-module.js');",
      '  declare enum reqAlias {',
      '    Marker = 0,',
      '  }',
      '} while (false);',
      "const postDoWhileCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps do-while ambient function declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'do {',
      "  reqAlias('./fixtures/other-module.js');",
      '  declare function reqAlias(_path: string): unknown;',
      '} while (false);',
      "const postDoWhileCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps do-while ambient namespace declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'do {',
      "  reqAlias('./fixtures/other-module.js');",
      '  declare namespace reqAlias {',
      '    const marker: unknown;',
      '  }',
      '} while (false);',
      "const postDoWhileCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps do-while ambient module declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'do {',
      "  reqAlias('./fixtures/other-module.js');",
      '  declare module reqAlias {',
      '    const marker: unknown;',
      '  }',
      '} while (false);',
      "const postDoWhileCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps do-while ambient const declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'do {',
      "  reqAlias('./fixtures/other-module.js');",
      '  declare const reqAlias: (_path: string) => unknown;',
      '} while (false);',
      "const postDoWhileCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps do-while ambient let declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'do {',
      "  reqAlias('./fixtures/other-module.js');",
      '  declare let reqAlias: (_path: string) => unknown;',
      '} while (false);',
      "const postDoWhileCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps do-while ambient var declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'do {',
      "  reqAlias('./fixtures/other-module.js');",
      '  declare var reqAlias: (_path: string) => unknown;',
      '} while (false);',
      "const postDoWhileCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('does not leak direct require shadowing across while scopes', () => {
    const source = [
      'while (true) {',
      '  const require = () => undefined;',
      "  require('./fixtures/other-module.js');",
      '  break;',
      '}',
      "const postWhileCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('does not leak direct require shadowing across do-while scopes', () => {
    const source = [
      'do {',
      '  const require = () => undefined;',
      "  require('./fixtures/other-module.js');",
      '} while (false);',
      "const postDoWhileCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('does not leak while-block lexical alias shadowing before declaration to outer module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'while (true) {',
      "  reqAlias('./fixtures/other-module.js');",
      '  const reqAlias = () => undefined;',
      '  break;',
      '}',
      "const postWhileCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('does not leak do-while lexical alias shadowing before declaration to outer module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'do {',
      "  reqAlias('./fixtures/other-module.js');",
      '  const reqAlias = () => undefined;',
      '} while (false);',
      "const postDoWhileCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('does not leak direct require shadowing across if-branch scopes', () => {
    const source = [
      'if (true) {',
      '  const require = () => undefined;',
      "  require('./fixtures/other-module.js');",
      '}',
      "const postIfCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('does not leak direct require shadowing across else-branch scopes', () => {
    const source = [
      'if (false) {',
      '  void 0;',
      '} else {',
      '  const require = () => undefined;',
      "  require('./fixtures/other-module.js');",
      '}',
      "const postElseCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('does not leak if-branch lexical alias shadowing before declaration to outer module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'if (true) {',
      "  reqAlias('./fixtures/other-module.js');",
      '  const reqAlias = () => undefined;',
      '}',
      "const postIfCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('does not leak else-branch lexical alias shadowing before declaration to outer module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'if (false) {',
      '  void 0;',
      '} else {',
      "  reqAlias('./fixtures/other-module.js');",
      '  const reqAlias = () => undefined;',
      '}',
      "const postElseCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps if-branch type-alias declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'if (true) {',
      "  reqAlias('./fixtures/other-module.js');",
      '  type reqAlias = (_path: string) => unknown;',
      '}',
      "const postIfCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps else-branch type-alias declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'if (false) {',
      '  void 0;',
      '} else {',
      "  reqAlias('./fixtures/other-module.js');",
      '  type reqAlias = (_path: string) => unknown;',
      '}',
      "const postElseCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps if-branch interface declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'if (true) {',
      "  reqAlias('./fixtures/other-module.js');",
      '  interface reqAlias {',
      '    value: string;',
      '  }',
      '}',
      "const postIfCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps else-branch interface declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'if (false) {',
      '  void 0;',
      '} else {',
      "  reqAlias('./fixtures/other-module.js');",
      '  interface reqAlias {',
      '    value: string;',
      '  }',
      '}',
      "const postElseCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps if-branch ambient class declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'if (true) {',
      "  reqAlias('./fixtures/other-module.js');",
      '  declare class reqAlias {}',
      '}',
      "const postIfCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps else-branch ambient class declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'if (false) {',
      '  void 0;',
      '} else {',
      "  reqAlias('./fixtures/other-module.js');",
      '  declare class reqAlias {}',
      '}',
      "const postElseCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps if-branch ambient enum declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'if (true) {',
      "  reqAlias('./fixtures/other-module.js');",
      '  declare enum reqAlias {',
      '    Marker = 0,',
      '  }',
      '}',
      "const postIfCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps else-branch ambient enum declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'if (false) {',
      '  void 0;',
      '} else {',
      "  reqAlias('./fixtures/other-module.js');",
      '  declare enum reqAlias {',
      '    Marker = 0,',
      '  }',
      '}',
      "const postElseCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps if-branch ambient function declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'if (true) {',
      "  reqAlias('./fixtures/other-module.js');",
      '  declare function reqAlias(_path: string): unknown;',
      '}',
      "const postIfCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps else-branch ambient function declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'if (false) {',
      '  void 0;',
      '} else {',
      "  reqAlias('./fixtures/other-module.js');",
      '  declare function reqAlias(_path: string): unknown;',
      '}',
      "const postElseCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps if-branch ambient namespace declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'if (true) {',
      "  reqAlias('./fixtures/other-module.js');",
      '  declare namespace reqAlias {',
      '    const marker: unknown;',
      '  }',
      '}',
      "const postIfCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps else-branch ambient namespace declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'if (false) {',
      '  void 0;',
      '} else {',
      "  reqAlias('./fixtures/other-module.js');",
      '  declare namespace reqAlias {',
      '    const marker: unknown;',
      '  }',
      '}',
      "const postElseCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps if-branch ambient module declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'if (true) {',
      "  reqAlias('./fixtures/other-module.js');",
      '  declare module reqAlias {',
      '    const marker: unknown;',
      '  }',
      '}',
      "const postIfCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps else-branch ambient module declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'if (false) {',
      '  void 0;',
      '} else {',
      "  reqAlias('./fixtures/other-module.js');",
      '  declare module reqAlias {',
      '    const marker: unknown;',
      '  }',
      '}',
      "const postElseCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps if-branch ambient const declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'if (true) {',
      "  reqAlias('./fixtures/other-module.js');",
      '  declare const reqAlias: (_path: string) => unknown;',
      '}',
      "const postIfCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps else-branch ambient const declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'if (false) {',
      '  void 0;',
      '} else {',
      "  reqAlias('./fixtures/other-module.js');",
      '  declare const reqAlias: (_path: string) => unknown;',
      '}',
      "const postElseCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps if-branch ambient let declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'if (true) {',
      "  reqAlias('./fixtures/other-module.js');",
      '  declare let reqAlias: (_path: string) => unknown;',
      '}',
      "const postIfCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps else-branch ambient let declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'if (false) {',
      '  void 0;',
      '} else {',
      "  reqAlias('./fixtures/other-module.js');",
      '  declare let reqAlias: (_path: string) => unknown;',
      '}',
      "const postElseCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps if-branch ambient var declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'if (true) {',
      "  reqAlias('./fixtures/other-module.js');",
      '  declare var reqAlias: (_path: string) => unknown;',
      '}',
      "const postIfCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps else-branch ambient var declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'if (false) {',
      '  void 0;',
      '} else {',
      "  reqAlias('./fixtures/other-module.js');",
      '  declare var reqAlias: (_path: string) => unknown;',
      '}',
      "const postElseCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps if-branch var alias declarations made inside block scopes', () => {
    const source = [
      'if (true) {',
      '  var reqAlias = require;',
      "  reqAlias('./fixtures/guard-module.js');",
      '}',
      "const postIfCall = reqAlias('./fixtures/other-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps else-branch var alias declarations made inside block scopes', () => {
    const source = [
      'if (false) {',
      '  void 0;',
      '} else {',
      '  var reqAlias = require;',
      "  reqAlias('./fixtures/guard-module.js');",
      '}',
      "const postElseCall = reqAlias('./fixtures/other-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('clears if-branch var alias declarations to non-require values inside block scopes', () => {
    const source = [
      'if (true) {',
      '  var reqAlias = require;',
      "  reqAlias('./fixtures/guard-module.js');",
      '  reqAlias = () => undefined;',
      '}',
      "const postIfCall = reqAlias('./fixtures/other-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('clears else-branch var alias declarations to non-require values inside block scopes', () => {
    const source = [
      'if (false) {',
      '  void 0;',
      '} else {',
      '  var reqAlias = require;',
      "  reqAlias('./fixtures/guard-module.js');",
      '  reqAlias = () => undefined;',
      '}',
      "const postElseCall = reqAlias('./fixtures/other-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('applies if-branch assignments to outer require aliases for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (true) {',
      '  reqAlias = () => undefined;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('applies else-branch assignments to outer require aliases for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (false) {',
      '  void 0;',
      '} else {',
      '  reqAlias = () => undefined;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('applies if-branch destructuring assignments to outer require aliases for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (true) {',
      '  ({ reqAlias } = { reqAlias: () => undefined });',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('applies else-branch destructuring assignments to outer require aliases for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (false) {',
      '  void 0;',
      '} else {',
      '  ({ reqAlias } = { reqAlias: () => undefined });',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('applies if-branch require assignments to outer aliases for module specifiers', () => {
    const source = [
      'let reqAlias: any;',
      'if (true) {',
      '  reqAlias = require;',
      '}',
      "const postIfCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
  });

  it('applies else-branch require assignments to outer aliases for module specifiers', () => {
    const source = [
      'let reqAlias: any;',
      'if (false) {',
      '  void 0;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "const postElseCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
  });

  it('keeps possible branch require aliases in module specifiers for unknown if conditions', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (Math.random() > 0.5) {',
      '  reqAlias = () => undefined;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps possible then-branch require aliases in module specifiers for unknown if conditions without else', () => {
    const source = [
      'let reqAlias: any = () => undefined;',
      'if (Math.random() > 0.5) {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats !false conditions as true branches for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (!false) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats !true conditions as false branches for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (!true) {',
      '  reqAlias = require;',
      '} else {',
      '  reqAlias = () => undefined;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats numeric truthy conditions as true branches for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (1) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats object and array literal truthy conditions as true branches for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (({} && [])) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats nullish-coalescing literal right conditions as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'if ((null ?? {})) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats signed truthy primitive conditions as true branches for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (+true) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats signed NaN conditions as false branches for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (+undefined) {',
      '  reqAlias = require;',
      '} else {',
      '  reqAlias = () => undefined;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats empty-string falsy conditions as false branches for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      "if ('') {",
      '  reqAlias = require;',
      '} else {',
      '  reqAlias = () => undefined;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps signed unknown conditions conservative for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js');",
      'if (+marker) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js');",
      'void baseline;',
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality void primitives as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if (((void marker) === undefined)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-inequality void primitives as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if (((void marker) !== undefined)) {',
      '  reqAlias = require;',
      '} else {',
      '  reqAlias = () => undefined;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats void conditions as false branches for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if (void marker) {',
      '  reqAlias = require;',
      '} else {',
      '  reqAlias = () => undefined;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality typeof primitives as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      "if (((typeof (1 + 2)) === 'number')) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-inequality typeof primitives as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      "if (((typeof (1 + 2)) !== 'string')) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps strict-comparison typeof unknown predicates conservative for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js');",
      "if (((typeof marker) === 'number')) reqAlias = () => undefined;",
      "reqAlias('./fixtures/other-module.js');",
      'void baseline;',
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality typeof object literals as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      "if (((typeof ({ value: 1 })) === 'object')) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-inequality typeof function expressions as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      "if (((typeof (() => 1)) !== 'object')) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-comparison wrapped typeof predicates with matching unknown selectors as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "if (((typeof (marker === 1 ? { safe: 1 } : [])) === 'object')) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-comparison wrapped negative typeof predicates with matching unknown selectors as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "if (((typeof (marker === 1 ? (() => 1) : (class WrappedType {}))) !== 'object')) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps strict-comparison wrapped typeof predicates with differing unknown selectors conservative for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js');",
      "if (((typeof (marker === 1 ? { safe: 1 } : (() => 1))) === 'object')) reqAlias = () => undefined;",
      "reqAlias('./fixtures/other-module.js');",
      'void baseline;',
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality delete primitives as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (((delete (1)) === true)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-inequality delete primitives as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (((delete (1)) !== false)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps strict-comparison delete unknown predicates conservative for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = globalThis as any;',
      "const baseline = require('./fixtures/guard-module.js');",
      'if (((delete marker.value) === true)) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js');",
      'void baseline;',
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality template primitives as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      "if ((`${'safe'}-${1}` === 'safe-1')) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-inequality template primitives as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      "if ((`${'safe'}-${1}` !== 'safe-2')) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps strict-comparison template unknown predicates conservative for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js');",
      "if ((`${marker}` === '1')) reqAlias = () => undefined;",
      "reqAlias('./fixtures/other-module.js');",
      'void baseline;',
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality in primitives as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      "if ((('safe' in { safe: 1 }) === true)) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-inequality in primitives as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      "if ((('safe' in { guard: 1 }) !== true)) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality inherited object-prototype in predicates as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      "if ((('toString' in {}) === true)) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-inequality null-prototype in predicates as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      "if ((('toString' in { __proto__: null }) !== true)) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps strict-comparison unknown prototype-override predicates conservative for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = globalThis as any;',
      "const baseline = require('./fixtures/guard-module.js');",
      "if ((('toString' in { __proto__: marker }) === true)) reqAlias = () => undefined;",
      "reqAlias('./fixtures/other-module.js');",
      'void baseline;',
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-comparison wrapped prototype-overrides with matching unknown selectors as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "if ((('safe' in { __proto__: marker === 1 ? { safe: 1 } : { safe: 2 } }) === true)) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps strict-comparison wrapped prototype-overrides with differing unknown selectors conservative for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js');",
      "if ((('safe' in { __proto__: marker === 1 ? { safe: 1 } : { guard: 1 } }) === true)) reqAlias = () => undefined;",
      "reqAlias('./fixtures/other-module.js');",
      'void baseline;',
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-comparison nullish-coalesced conditional-negation prototype-overrides as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "if ((('toString' in { __proto__: ((marker ? !left : !right) ?? (marker === 2 ? !up : !down)) }) === true)) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-comparison nullish-coalesced mixed prototype-overrides as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js');",
      "if ((('toString' in { __proto__: ((marker ? !left : !right) ?? (marker === 2 ? up : down)) }) === true)) reqAlias = () => undefined;",
      "reqAlias('./fixtures/other-module.js');",
      'void baseline;',
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-comparison nullish-coalesced boolean-comparison prototype-overrides as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "if ((('toString' in { __proto__: ((marker === 1) ?? { safe: 1 }) }) === true)) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps strict-comparison nullish-coalesced marker prototype-overrides conservative for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = globalThis as any;',
      "const baseline = require('./fixtures/guard-module.js');",
      "if ((('toString' in { __proto__: (marker ?? { safe: 1 }) }) === true)) reqAlias = () => undefined;",
      "reqAlias('./fixtures/other-module.js');",
      'void baseline;',
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality inherited array-prototype in predicates as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      "if ((('map' in ['safe']) === true)) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality function-prototype in predicates as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      "if ((('call' in (() => 1)) === true)) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-inequality arrow-prototype-key in predicates as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      "if ((('prototype' in (() => 1)) !== true)) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality regexp-prototype in predicates as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      "if ((('test' in /safe/) === true)) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality class-static-member in predicates as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      "if ((('safe' in (class { static safe = 1 })) === true)) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps strict-comparison class-static-block predicates conservative for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = globalThis as any;',
      "const baseline = require('./fixtures/guard-module.js');",
      "if ((('safe' in (class { static { if (marker) (this as any).safe = 1; } })) === true)) reqAlias = () => undefined;",
      "reqAlias('./fixtures/other-module.js');",
      'void baseline;',
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-comparison class-static-block prototype-key predicates as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = globalThis as any;',
      "if ((('prototype' in (class { static { if (marker) (this as any).safe = 1; } })) === true)) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-comparison class-static-known-key with static-block predicates as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = globalThis as any;',
      "if ((('safe' in (class { static safe = 1; static { if (marker) (this as any).extra = 1; } })) === true)) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-comparison class-known-static with unknown-computed-static predicates as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = globalThis as any;',
      "if ((('safe' in (class { static safe = 1; static [marker] = 1; })) === true)) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps strict-comparison class-unknown-computed-static predicates conservative for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = globalThis as any;',
      "const baseline = require('./fixtures/guard-module.js');",
      "if ((('safe' in (class { static [marker] = 1; })) === true)) reqAlias = () => undefined;",
      "reqAlias('./fixtures/other-module.js');",
      'void baseline;',
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality in array primitives as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      "if (((('0' in ['safe']) === true))) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-inequality in sparse-array primitives as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      "if (((('0' in [, 'safe']) !== true))) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality in spread-array length predicates as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const rest = globalThis as any;',
      "if (((('length' in ['safe', ...rest]) === true))) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality in spread-array pre-spread index predicates as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const rest = globalThis as any;',
      "if (((('0' in ['safe', ...rest]) === true))) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps strict-comparison in spread-array post-spread predicates conservative for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const rest = globalThis as any;',
      "const baseline = require('./fixtures/guard-module.js');",
      "if (((('2' in ['safe', ...rest]) === true))) reqAlias = () => undefined;",
      "reqAlias('./fixtures/other-module.js');",
      'void baseline;',
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats wrapped in array predicates with matching unknown selectors as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "if (((('0' in (marker === 1 ? ['safe'] : ['guard'])) === true))) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats wrapped negative in array predicates with matching unknown selectors as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "if (((('0' in (marker === 1 ? [, 'safe'] : [, 'guard'])) !== true))) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps strict-comparison wrapped in array predicates with differing unknown selectors conservative for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js');",
      "if (((('0' in (marker === 1 ? ['safe'] : [, 'safe'])) === true))) reqAlias = () => undefined;",
      "reqAlias('./fixtures/other-module.js');",
      'void baseline;',
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps strict-comparison in unknown predicates conservative for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = globalThis as any;',
      "const baseline = require('./fixtures/guard-module.js');",
      "if ((('safe' in marker) === true)) reqAlias = () => undefined;",
      "reqAlias('./fixtures/other-module.js');",
      'void baseline;',
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats wrapped in predicates with matching unknown selectors as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "if ((('safe' in (marker === 1 ? { safe: 1 } : { safe: 2 })) === true)) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats wrapped negative in predicates with matching unknown selectors as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "if ((('safe' in (marker === 1 ? { guard: 1 } : { guard: 2 })) !== true)) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps wrapped in predicates with differing unknown selectors conservative for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js');",
      "if ((('safe' in (marker === 1 ? { safe: 1 } : { guard: 1 })) === true)) reqAlias = () => undefined;",
      "reqAlias('./fixtures/other-module.js');",
      'void baseline;',
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality instanceof primitives as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (((({}) instanceof Object) === true)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-inequality instanceof primitives as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (((({}) instanceof Array) !== true)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps strict-comparison instanceof unknown predicates conservative for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = globalThis as any;',
      "const baseline = require('./fixtures/guard-module.js');",
      'if (((marker instanceof Object) === true)) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js');",
      'void baseline;',
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-comparison wrapped instanceof predicates with matching unknown selectors as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if ((((marker === 1 ? {} : []) instanceof Object) === true)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-comparison wrapped instanceof predicates with matching unknown selectors as deterministic for negative cases in module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if ((((marker === 1 ? {} : {}) instanceof Array) !== true)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps strict-comparison wrapped instanceof predicates with differing unknown selectors conservative for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js');",
      'if ((((marker === 1 ? {} : []) instanceof Array) === true)) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js');",
      'void baseline;',
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats relational true conditions as true branches for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (((1 + 2) > 2)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats relational false conditions as false branches for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      "if ((('ab' + 'cd') < 'aa')) {",
      '  reqAlias = require;',
      '} else {',
      '  reqAlias = () => undefined;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps relational unknown conditions conservative for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js');",
      'if (((marker + 1) > 2)) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js');",
      'void baseline;',
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality true conditions as true branches for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (1 === 1) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality false conditions as false branches for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (1 === 2) {',
      '  reqAlias = require;',
      '} else {',
      '  reqAlias = () => undefined;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality conditional primitives with static selectors as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'if ((true ? 1 : 2) === 1) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality logical-and primitives as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if (((0 && marker) === 0)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality logical-or primitives as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if (((1 || marker) === 1)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality nullish primitives with null left values as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (((null ?? 1) === 1)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality nullish primitives with undefined left values as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (((undefined ?? 1) === 1)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality nullish primitives with non-nullish left values as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if (((2 ?? marker) === 2)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality conditional primitives with matching unknown selectors as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if ((marker === 1 ? 1 : 1) === 1) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps strict-equality nullish primitives with unknown left values conservative for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js');",
      'if ((((marker === 1) ?? 1) === true)) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js');",
      'void baseline;',
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps strict-equality logical primitives with unknown left values conservative for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js');",
      'if ((((marker === 1) && 2) === 2)) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js');",
      'void baseline;',
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality logical-and false primitives with unknown-boolean left values as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if ((((marker === 1) && false) === false)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality logical-or true primitives with unknown-boolean left values as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if ((((marker === 1) || true) === true)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality logical-and false primitives with conditional-selected boolean left values as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if (((((true ? (marker === 1) : marker) && false) === false))) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality logical-or true primitives with conditional-selected boolean left values as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if (((((false ? marker : (marker === 1)) || true) === true))) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality logical-and false primitives with conditional-selected delete boolean left values as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if (((((true ? delete ({ safe: 1 }).safe : marker) && false) === false))) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality logical-or true primitives with conditional-selected delete boolean left values as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if (((((false ? marker : delete ({ safe: 1 }).safe) || true) === true))) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality direct-delete true predicates as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (((delete ({ safe: 1 }).safe) === true)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality direct-delete array-length false predicates as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (((delete ([] as any).length) === false)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality direct-delete object-element true predicates as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      "if (((delete ({ safe: 1 })['safe']) === true)) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality direct-delete array-element-length false predicates as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      "if (((delete ([] as any)['length']) === false)) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality direct-delete array-element-numeric true predicates as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (((delete ([] as any)[0]) === true)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality direct-delete array-element-template-length false predicates as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      "if (((delete ([] as any)[`len${'gth'}`]) === false)) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality direct-delete array-element-conditional-same-length predicates as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "if (((delete ([] as any)[marker === 1 ? 'length' : 'length']) === false)) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality direct-delete array-element-nullish-length predicates as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      "if (((delete ([] as any)[null ?? 'length']) === false)) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality direct-delete array-element-nullish-conditional-fallback-length predicates as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "if (((delete ([] as any)[((marker === 1 ? 'length' : undefined) ?? 'length')]) === false)) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps strict-equality direct-delete array-element-nullish-conditional-mixed-fallback predicates conservative for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js');",
      "if (((delete ([] as any)[((marker === 1 ? 'length' : undefined) ?? 'safe')]) === false)) reqAlias = () => undefined;",
      "reqAlias('./fixtures/other-module.js');",
      'void baseline;',
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality direct-delete array-element-nullish-logical-null-fallback-length predicates as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "if (((delete ([] as any)[(((marker === 1 && 'length') || null) ?? 'length')]) === false)) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps strict-equality direct-delete array-element-nullish-logical-null-mixed-fallback predicates conservative for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js');",
      "if (((delete ([] as any)[(((marker === 1 && 'length') || null) ?? 'safe')]) === false)) reqAlias = () => undefined;",
      "reqAlias('./fixtures/other-module.js');",
      'void baseline;',
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality direct-delete array-element-logical-same-length predicates as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "if (((delete ([] as any)[((marker === 1 && 'length') || 'length')]) === false)) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps strict-equality direct-delete array-element-logical-mixed-key predicates conservative for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js');",
      "if (((delete ([] as any)[((marker === 1 && 'length') || 'safe')]) === false)) reqAlias = () => undefined;",
      "reqAlias('./fixtures/other-module.js');",
      'void baseline;',
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality direct-delete array-element-conditional-numeric-nonlength predicates as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if (((delete ([] as any)[marker === 1 ? 0 : 1]) === true)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality direct-delete array-element-mixed-nullish-numeric predicates as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if (((delete ([] as any)[(marker === 1 ? null : 0) ?? 1]) === true)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps strict-equality direct-delete array-element-conditional-mixed-key predicates conservative for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js');",
      "if (((delete ([] as any)[marker === 1 ? 'length' : 'safe']) === false)) reqAlias = () => undefined;",
      "reqAlias('./fixtures/other-module.js');",
      'void baseline;',
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps strict-equality direct-delete array-element-dynamic-key predicates conservative for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js');",
      'if (((delete ([] as any)[marker]) === false)) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js');",
      'void baseline;',
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps strict-equality direct-delete unknown-target-element predicates conservative for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = globalThis as any;',
      "const baseline = require('./fixtures/guard-module.js');",
      "if (((delete marker['safe']) === true)) reqAlias = () => undefined;",
      "reqAlias('./fixtures/other-module.js');",
      'void baseline;',
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps strict-equality direct-delete unknown-target predicates conservative for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = globalThis as any;',
      "const baseline = require('./fixtures/guard-module.js');",
      'if (((delete marker.safe) === true)) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js');",
      'void baseline;',
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality direct-delete primitive-boolean targets as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (((delete ((false as any).safe) === true)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps strict-equality direct-delete primitive-string-length targets conservative for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      "const baseline = require('./fixtures/guard-module.js');",
      "if (((delete (('abc' as any).length) === false)) reqAlias = () => undefined;",
      "reqAlias('./fixtures/other-module.js');",
      'void baseline;',
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality direct-delete new-date-target predicates as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (((delete ((new Date() as any).safe) === true)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality direct-delete new-regexp-target predicates as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      "if (((delete ((new RegExp('safe') as any).source) === true)) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality direct-delete new-array-element predicates as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (((delete ((new Array() as any)[0]) === true)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality direct-delete new-function-nonprototype predicates as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (((delete ((new Function() as any).safe) === true)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality direct-delete new-string-nonlength predicates as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      "if (((delete ((new String('safe') as any).tag) === true)) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps strict-equality direct-delete new-array-length-target predicates conservative for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      "const baseline = require('./fixtures/guard-module.js');",
      'if (((delete ((new Array() as any).length) === false)) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js');",
      'void baseline;',
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps strict-equality direct-delete new-string-length-target predicates conservative for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      "const baseline = require('./fixtures/guard-module.js');",
      "if (((delete ((new String('safe') as any).length) === false)) reqAlias = () => undefined;",
      "reqAlias('./fixtures/other-module.js');",
      'void baseline;',
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality direct-delete conditional-known-new-constructor-target predicates as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if (((delete ((new ((marker === 1 ? Date : RegExp) as any)() as any).safe) === true)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality direct-delete globalthis-new-constructor-target predicates as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (((delete ((new ((globalThis as any).Date)() as any).safe) === true)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality direct-delete globalthis-element-new-constructor-target predicates as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      "if (((delete ((new ((globalThis as any)['Date'])() as any).safe) === true)) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality direct-delete self-element-new-constructor-target predicates as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      "if (((delete ((new ((self as any)['Date'])() as any).safe) === true)) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality direct-delete conditional-global-qualifier-new-constructor-target predicates as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if (((delete ((new (((marker === 1 ? globalThis : self) as any).Date)() as any).safe) === true)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality direct-delete nullish-global-qualifier-new-constructor-target predicates as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (((delete ((new ((((null as any) ?? globalThis) as any).Date)() as any).safe) === true)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps strict-equality direct-delete conditional-mixed-new-constructor-length predicates conservative for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js');",
      'if (((delete ((new ((marker === 1 ? Array : Date) as any)() as any).length) === false)) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js');",
      'void baseline;',
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps strict-equality direct-delete conditional-mixed-global-qualifier-new-constructor-target predicates conservative for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'const fallback = {} as any;',
      "const baseline = require('./fixtures/guard-module.js');",
      'if (((delete ((new (((marker === 1 ? globalThis : fallback) as any).Date)() as any).safe) === true)) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js');",
      'void baseline;',
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps strict-equality direct-delete mixed-nullish-global-qualifier-new-constructor-target predicates conservative for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'const fallback = {} as any;',
      "const baseline = require('./fixtures/guard-module.js');",
      'if (((delete ((new ((((marker === 1 ? null : fallback) ?? globalThis) as any).Date)() as any).safe) === true)) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js');",
      'void baseline;',
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps strict-equality direct-delete conditional-mixed-element-new-constructor-length predicates conservative for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js');",
      "if (((delete ((new ((globalThis as any)[marker === 1 ? 'Array' : 'Date'])() as any).length) === false)) reqAlias = () => undefined;",
      "reqAlias('./fixtures/other-module.js');",
      'void baseline;',
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps strict-equality direct-delete new-function-prototype-target predicates conservative for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      "const baseline = require('./fixtures/guard-module.js');",
      'if (((delete ((new Function() as any).prototype) === false)) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js');",
      'void baseline;',
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality direct-delete regexp-target predicates as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (((delete ((/safe/ as any).source) === true)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps strict-equality direct-delete mixed regexp-target predicates conservative for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'const fallback = globalThis as any;',
      "const baseline = require('./fixtures/guard-module.js');",
      'if (((delete ((marker === 1 ? (/safe/ as any) : fallback).source) === true)) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js');",
      'void baseline;',
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality direct-delete function-target nonprototype predicates as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (((delete (((function () {}) as any).safe) === true)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps strict-equality direct-delete function-target prototype predicates conservative for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      "const baseline = require('./fixtures/guard-module.js');",
      'if (((delete (((function () {}) as any).prototype) === false)) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js');",
      'void baseline;',
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality direct-delete class-target nonprototype predicates as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (((delete (((class {}) as any).safe) === true)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps strict-equality direct-delete class-target prototype predicates conservative for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      "const baseline = require('./fixtures/guard-module.js');",
      'if (((delete (((class {}) as any).prototype) === false)) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js');",
      'void baseline;',
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality direct-delete arrow-target prototype predicates as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (((delete (((() => {}) as any).prototype) === true)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality direct-delete conditional-object-target predicates as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if (((delete (marker === 1 ? { safe: 1 } : { guard: 1 }).safe) === true)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality direct-delete nullish-array-length-target predicates as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (((delete ((null ?? []) as any).length) === false)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality direct-delete logical-or object-target predicates as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (((delete (((false && (globalThis as any)) || { safe: 1 }).safe) === true)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality direct-delete logical-and array-length-target predicates as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (((delete (((true && ([] as any))).length) === false)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality direct-delete comma array-length-target predicates as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (((delete (((globalThis as any), ([] as any)).length) === false)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality direct-delete conditional-object-element-target predicates as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "if (((delete ((marker === 1 ? { safe: 1 } : { guard: 1 })['safe'])) === true)) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality direct-delete nullish-array-element-length-target predicates as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      "if (((delete (((null ?? []) as any)['length']) === false)) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality direct-delete logical-or object-element-target predicates as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      "if (((delete ((((false && (globalThis as any)) || { safe: 1 })['safe'])) === true)) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps strict-equality direct-delete mixed logical-element-target predicates conservative for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'const fallback = globalThis as any;',
      "const baseline = require('./fixtures/guard-module.js');",
      "if (((delete (((((marker === 1) && fallback) || { safe: 1 })['safe'])) === true)) reqAlias = () => undefined;",
      "reqAlias('./fixtures/other-module.js');",
      'void baseline;',
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps strict-equality direct-delete mixed logical-target predicates conservative for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'const fallback = globalThis as any;',
      "const baseline = require('./fixtures/guard-module.js');",
      'if (((delete ((((marker === 1) && fallback) || { safe: 1 }).safe) === true)) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js');",
      'void baseline;',
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps strict-equality direct-delete mixed conditional-target predicates conservative for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'const fallback = globalThis as any;',
      "const baseline = require('./fixtures/guard-module.js');",
      'if (((delete (marker === 1 ? { safe: 1 } : fallback).safe) === true)) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js');",
      'void baseline;',
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps strict-equality logical-and false primitives with conditional-selected nonboolean left values conservative for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js');",
      'if (((((true ? marker : (marker === 1)) && false) === false))) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js');",
      'void baseline;',
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps strict-equality logical-or true primitives with conditional-selected nonboolean left values conservative for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js');",
      'if (((((false ? (marker === 1) : marker) || true) === true))) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js');",
      'void baseline;',
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality logical-and false primitives with comma-selected boolean left values as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if ((((((0, marker === 1) && false) === false)))) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality logical-or true primitives with comma-selected boolean left values as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if ((((((0, marker === 1) || true) === true)))) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps strict-equality logical-and false primitives with comma-selected nonboolean left values conservative for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js');",
      'if ((((((0, marker) && false) === false)))) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js');",
      'void baseline;',
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps strict-equality logical-or true primitives with comma-selected nonboolean left values conservative for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js');",
      'if ((((((0, marker) || true) === true)))) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js');",
      'void baseline;',
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality logical-or true primitives with truthy-nonboolean-selected boolean left values as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if (((((1 && (marker === 1)) || true) === true))) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality logical-and false primitives with falsey-nonboolean-selected boolean left values as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if (((((0 || (marker === 1)) && false) === false))) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps strict-equality logical-or true primitives with truthy-nonboolean-selected nonboolean left values conservative for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js');",
      'if (((((1 && marker) || true) === true))) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js');",
      'void baseline;',
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps strict-equality logical-and false primitives with falsey-nonboolean-selected nonboolean left values conservative for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js');",
      'if (((((0 || marker) && false) === false))) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js');",
      'void baseline;',
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality logical-and false primitives with nested unknown-boolean left values as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if ((((((marker === 1) && true) && false) === false))) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality logical-or true primitives with nested unknown-boolean left values as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if ((((((marker === 1) || false) || true) === true))) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality logical-and false primitives with nested nullish-boolean left values as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if ((((((marker === 1) ?? false) && false) === false))) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality logical-or true primitives with nested nullish-boolean left values as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if ((((((marker === 1) ?? false) || true) === true))) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality logical-and false primitives with null-coalesced boolean-right left values as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if (((((null ?? (marker === 1)) && false) === false))) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality logical-or true primitives with null-coalesced boolean-right left values as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if (((((null ?? (marker === 1)) || true) === true))) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality logical-and false primitives with nullish-conditional-selected boolean left values as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if (((((((marker === 1 ? null : undefined) ?? (marker === 2)) && false) === false)))) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality logical-or true primitives with nullish-conditional-selected boolean left values as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if (((((((marker === 1 ? null : undefined) ?? (marker === 2)) || true) === true)))) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality logical-and false primitives with nullish-logical-selected boolean left values as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if ((((((marker === 1 ? null : undefined) && marker) ?? true) === true))) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps strict-equality logical-and false primitives with nullish-logical-selected mixed left values conservative for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js');",
      'if ((((((marker === 1 ? null : 0) && marker) ?? true) === true))) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js');",
      'void baseline;',
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats nullish-coalesced logical-or true-left predicates as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if (((marker || true) ?? false)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps nullish-coalesced logical-or null-right predicates conservative for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js');",
      'if (((marker || null) ?? false)) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js');",
      'void baseline;',
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats nullish-coalesced logical-and null-right false-default predicates as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if (((marker && null) ?? false)) {',
      '  reqAlias = require;',
      '} else {',
      '  reqAlias = () => undefined;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps nullish-coalesced logical-and null-right true-default predicates conservative for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js');",
      'if (((marker && null) ?? true)) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js');",
      'void baseline;',
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality logical-and false primitives with in-operator boolean-left values as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "if ((((('missing' in { safe: 1 }) && marker) === false))) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality logical-or true primitives with in-operator boolean-left values as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "if ((((('safe' in { safe: 1 }) || marker) === true))) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps strict-equality in direct-delete right operands conservative for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      "const baseline = require('./fixtures/guard-module.js');",
      "if ((((('safe' in (delete ({ safe: 1 }).safe)) === false)))) reqAlias = () => undefined;",
      "reqAlias('./fixtures/other-module.js');",
      'void baseline;',
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps strict-equality in nullish-selected delete right operands conservative for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      "const baseline = require('./fixtures/guard-module.js');",
      "if ((((('safe' in (null ?? delete ({ safe: 1 }).safe)) === false)))) reqAlias = () => undefined;",
      "reqAlias('./fixtures/other-module.js');",
      'void baseline;',
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps strict-equality in conditional-delete right operands conservative for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js');",
      "if ((((('safe' in (marker === 1 ? delete ({ safe: 1 }).safe : delete ({ guard: 1 }).guard)) === false)))) reqAlias = () => undefined;",
      "reqAlias('./fixtures/other-module.js');",
      'void baseline;',
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality logical-and false primitives with instanceof boolean-left values as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if ((((({}) instanceof Array) && marker) === false)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality logical-or true primitives with instanceof boolean-left values as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if ((((({}) instanceof Object) || marker) === true)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats nullish-coalesced logical-and instanceof false-left predicates as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if ((((({}) instanceof Array) && marker) ?? true)) {',
      '  reqAlias = require;',
      '} else {',
      '  reqAlias = () => undefined;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats nullish-coalesced logical-or instanceof true-left predicates as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if ((((({}) instanceof Object) || marker) ?? false)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality instanceof conditional true-selected boolean results as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'if ((((true ? !left : marker) instanceof Object) === false)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality instanceof conditional unknown-selected boolean results as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if (((((marker === 1 ? !left : !right) instanceof Object) === false))) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality instanceof nullish-coalesced conditional-negation operands as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if ((((((marker ? !left : !right) ?? (marker === 2 ? up : down)) instanceof Object) === false))) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps strict-equality instanceof conditional mixed-selected results conservative for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js');",
      'if (((((marker === 1 ? !left : right) instanceof Object) === false))) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js');",
      'void baseline;',
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps strict-equality instanceof nullish-coalesced mixed conditional operands conservative for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js');",
      'if ((((((marker ? !left : right) ?? (marker === 2 ? up : down)) instanceof Object) === false))) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js');",
      'void baseline;',
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality instanceof conditional-selected delete operands as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if (((((true ? delete ({ safe: 1 }).safe : marker) instanceof Object) === false))) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality instanceof conditional-delete unknown-selected operands as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if (((((marker === 1 ? delete ({ safe: 1 }).safe : delete ({ guard: 1 }).guard) instanceof Object) === false))) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality instanceof direct-delete operands as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'if ((((delete ({ safe: 1 }).safe) instanceof Object) === false)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality instanceof nullish-selected delete operands as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (((((null ?? delete ({ safe: 1 }).safe) instanceof Object) === false))) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps strict-equality instanceof nullish-mixed delete operands conservative for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = globalThis as any;',
      "const baseline = require('./fixtures/guard-module.js');",
      'if (((((marker ?? delete ({ safe: 1 }).safe) instanceof Object) === false))) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js');",
      'void baseline;',
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps strict-equality instanceof conditional mixed-delete operands conservative for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js');",
      'if (((((marker === 1 ? delete ({ safe: 1 }).safe : marker) instanceof Object) === false))) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js');",
      'void baseline;',
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality logical-and false primitives with typeof boolean-left values as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "if ((((typeof 1 === 'string') && marker) === false)) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality logical-or true primitives with typeof boolean-left values as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "if ((((typeof 1 === 'number') || marker) === true)) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality typeof logical-and false-selected boolean results as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "if (((typeof ((marker === 1) && false)) === 'boolean')) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality typeof logical-or true-selected boolean results as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "if (((typeof ((marker === 1) || true)) === 'boolean')) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality typeof conditional true-selected boolean results as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      "if (((typeof (true ? !left : marker)) === 'boolean')) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality typeof conditional unknown-selected boolean results as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "if (((typeof (marker === 1 ? !left : !right)) === 'boolean')) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality typeof conditional-selected delete results as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      "if (((typeof (true ? delete ({ safe: 1 }).safe : marker)) === 'boolean')) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality typeof conditional-delete unknown-selected results as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "if (((typeof (marker === 1 ? delete ({ safe: 1 }).safe : delete ({ guard: 1 }).guard)) === 'boolean')) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality typeof direct-delete results as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      "if (((typeof (delete ({ safe: 1 }).safe)) === 'boolean')) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality typeof nullish-selected delete results as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      "if (((typeof ((null ?? delete ({ safe: 1 }).safe))) === 'boolean')) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps strict-equality typeof nullish-mixed delete results conservative for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = globalThis as any;',
      "const baseline = require('./fixtures/guard-module.js');",
      "if (((typeof ((marker ?? delete ({ safe: 1 }).safe))) === 'boolean')) reqAlias = () => undefined;",
      "reqAlias('./fixtures/other-module.js');",
      'void baseline;',
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps strict-equality typeof conditional mixed-delete results conservative for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js');",
      "if (((typeof (marker === 1 ? delete ({ safe: 1 }).safe : right)) === 'boolean')) reqAlias = () => undefined;",
      "reqAlias('./fixtures/other-module.js');",
      'void baseline;',
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps strict-equality typeof conditional mixed-selected results conservative for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js');",
      "if (((typeof (marker === 1 ? !left : right)) === 'boolean')) reqAlias = () => undefined;",
      "reqAlias('./fixtures/other-module.js');",
      'void baseline;',
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps strict-equality typeof logical-and unknown-selected results conservative for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js');",
      "if (((typeof ((marker === 1) && marker)) === 'boolean')) reqAlias = () => undefined;",
      "reqAlias('./fixtures/other-module.js');",
      'void baseline;',
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps strict-equality typeof logical-or unknown-selected results conservative for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js');",
      "if (((typeof ((marker === 1) || marker)) === 'boolean')) reqAlias = () => undefined;",
      "reqAlias('./fixtures/other-module.js');",
      'void baseline;',
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality typeof nullish-coalesced conditional-negation boolean operands as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "if (((typeof (((marker ? !left : !right) ?? (marker === 2 ? !up : !down))) === 'boolean'))) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality typeof nullish-coalesced mixed conditional operands as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js');",
      "if (((typeof (((marker ? !left : !right) ?? (marker === 2 ? up : down))) === 'boolean'))) reqAlias = () => undefined;",
      "reqAlias('./fixtures/other-module.js');",
      'void baseline;',
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats nullish-coalesced logical-and typeof false-left predicates as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "if ((((typeof 1 === 'string') && marker) ?? true)) {",
      '  reqAlias = require;',
      '} else {',
      '  reqAlias = () => undefined;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats nullish-coalesced logical-or typeof true-left predicates as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "if ((((typeof 1 === 'number') || marker) ?? false)) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps nullish-coalesced typeof-and-false predicates conservative for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if ((((typeof marker) && false) ?? true)) {',
      '  reqAlias = require;',
      '} else {',
      '  reqAlias = () => undefined;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps nullish-coalesced typeof-and-unknown predicates conservative for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js');",
      'if ((((typeof marker) && marker) ?? true)) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js');",
      'void baseline;',
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps strict-equality logical-and false primitives with nullish-conditional-selected nonboolean left values conservative for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js');",
      'if (((((((marker === 1 ? null : undefined) ?? marker) && false) === false)))) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js');",
      'void baseline;',
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps strict-equality logical-or true primitives with nullish-conditional-selected nonboolean left values conservative for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js');",
      'if (((((((marker === 1 ? null : undefined) ?? marker) || true) === true)))) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js');",
      'void baseline;',
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps strict-equality logical-and false primitives with null-coalesced right-nonboolean-selected left values conservative for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js');",
      'if (((((null ?? marker) && false) === false))) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js');",
      'void baseline;',
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps strict-equality logical-or true primitives with null-coalesced right-nonboolean-selected left values conservative for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js');",
      'if (((((null ?? marker) || true) === true))) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js');",
      'void baseline;',
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps strict-equality logical-and false primitives with nested nullish-nonboolean left values conservative for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js');",
      'if ((((marker ?? false) && false) === false)) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js');",
      'void baseline;',
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps strict-equality logical-or true primitives with nested nullish-nonboolean left values conservative for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js');",
      'if ((((marker ?? false) || true) === true)) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js');",
      'void baseline;',
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality logical primitives with truthy non-primitive left values as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (((({}) && 2) === 2)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-inequality logical primitives with truthy non-primitive left values as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (((({}) && 2) !== 3)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps strict-comparison logical primitives with truthy non-primitive left unknown-right values conservative for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js');",
      'if (((({}) && marker) === 2)) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js');",
      'void baseline;',
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality non-primitive literal comparisons as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'if ((({} === 1))) {',
      '  reqAlias = require;',
      '} else {',
      '  reqAlias = () => undefined;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-inequality non-primitive literal comparisons as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'if ((({} !== 1))) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats loose-equality non-primitive nullish comparisons as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'if ((({} == null))) {',
      '  reqAlias = require;',
      '} else {',
      '  reqAlias = () => undefined;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats loose-inequality non-primitive nullish comparisons as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'if ((({} != null))) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps loose-comparison mixed non-primitive unknown operands conservative for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js');",
      'if (((marker === 1 ? {} : marker) == null)) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js');",
      'void baseline;',
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats loose-equality non-primitive comparisons as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'if ((({} == []))) {',
      '  reqAlias = require;',
      '} else {',
      '  reqAlias = () => undefined;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats loose-inequality non-primitive comparisons as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'if ((({} != []))) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-inequality wrapped non-primitive comparisons with matching unknown selectors as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if (((marker === 1 ? {} : []) !== (marker === 1 ? [] : {}))) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality wrapped non-primitive comparisons with matching unknown selectors as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if (((marker === 1 ? {} : []) === (marker === 1 ? [] : {}))) {',
      '  reqAlias = require;',
      '} else {',
      '  reqAlias = () => undefined;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats loose-inequality wrapped non-primitive comparisons with matching unknown selectors as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if (((marker === 1 ? {} : []) != (marker === 1 ? [] : {}))) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats loose-equality wrapped non-primitive comparisons with matching unknown selectors as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if (((marker === 1 ? {} : []) == (marker === 1 ? [] : {}))) {',
      '  reqAlias = require;',
      '} else {',
      '  reqAlias = () => undefined;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps wrapped non-primitive comparisons with differing unknown selectors conservative for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js');",
      'if (((marker === 1 ? {} : marker) != (marker === 1 ? [] : marker))) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js');",
      'void baseline;',
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps loose-equality wrapped non-primitive comparisons with differing unknown selectors conservative for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js');",
      'if (((marker === 1 ? {} : marker) == (marker === 1 ? [] : marker))) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js');",
      'void baseline;',
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality logical-or non-primitive primitives as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'if ((((0 || {}) === 1))) {',
      '  reqAlias = require;',
      '} else {',
      '  reqAlias = () => undefined;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-inequality conditional non-primitive primitives with matching unknown selectors as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if (((marker === 1 ? {} : []) !== 1)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps strict-comparison conditional non-primitive primitives with differing unknown selectors conservative for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js');",
      'if (((marker === 1 ? {} : 1) === 1)) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js');",
      'void baseline;',
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps strict-equality conditional primitives with differing unknown selectors conservative for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js');",
      'if ((marker === 1 ? 1 : 2) === 1) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js');",
      'void baseline;',
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality signed numeric primitives as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (((-1) === -1)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-inequality signed numeric primitives as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (((+1) !== 2)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality nested signed numeric primitives as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (((-(-1)) === 1)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-inequality nested signed numeric primitives as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (((+(+1)) !== 2)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality signed coercible primitives as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (((+true) === 1)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality signed string primitives as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (((+("1")) === 1)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-inequality signed coercible primitives as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (((-null) !== 1)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-inequality signed boolean primitives as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (((-(true)) !== 1)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality signed undefined NaN primitives as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (((+undefined) === 1)) {',
      '  reqAlias = require;',
      '} else {',
      '  reqAlias = () => undefined;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality signed NaN primitives as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (((+("not-a-number")) === 1)) {',
      '  reqAlias = require;',
      '} else {',
      '  reqAlias = () => undefined;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality comma primitives as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (((0, 1) === 1)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-inequality comma primitives as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (((0, 1) !== 2)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps strict-comparison comma unknown-right predicates conservative for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js');",
      'if (((0, marker) === 1)) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js');",
      'void baseline;',
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats loose-equality primitives as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      "if ((('1' == 1))) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats loose-inequality primitives as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      "if ((('1' != 2))) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps loose-comparison unknown operands conservative for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js');",
      'if (((marker == 1))) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js');",
      'void baseline;',
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality arithmetic primitives as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'if ((((1 + 2) * 3) === 9)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-inequality arithmetic primitives as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      "if (((('ab' + 'cd') !== 'xx'))) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps strict-comparison arithmetic unknown operands conservative for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js');",
      'if ((((marker + 1) === 2))) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js');",
      'void baseline;',
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality bitwise primitives as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'if ((((5 & 3) << 1) === 2)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-inequality bitwise primitives as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'if ((((5 ^ 1) >>> 1) !== 3)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps strict-comparison bitwise unknown operands conservative for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js');",
      'if ((((marker & 1) << 1) === 2)) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js');",
      'void baseline;',
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality comparison primitives as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'if ((((1 < 2) === true))) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-inequality comparison primitives as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'if ((((2 <= 1) !== true))) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps strict-comparison comparison unknown operands conservative for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js');",
      'if ((((marker < 2) === true))) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js');",
      'void baseline;',
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality signed bitwise-not primitives as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (((~1) === -2)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-inequality signed bitwise-not primitives as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (((~1) !== 1)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps strict-comparison signed bitwise-not unknown predicates conservative for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js');",
      'if (((~marker) === -2)) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js');",
      'void baseline;',
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps strict-comparison signed unknown predicates conservative for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js');",
      'if (((-marker) === -1)) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js');",
      'void baseline;',
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality negated primitive conditions as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'if ((!0) === true) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-inequality negated primitive conditions as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'if ((!1) !== false) {',
      '  reqAlias = require;',
      '} else {',
      '  reqAlias = () => undefined;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps strict-comparison negated unknown predicates conservative for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js');",
      'if ((!(marker === 1)) === true) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js');",
      'void baseline;',
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-inequality logical-and primitives as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if (((0 && marker) !== 1)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-inequality logical-or primitives as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if (((1 || marker) !== 2)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps strict-inequality logical primitives with unknown left values conservative for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js');",
      'if ((((marker === 1) && 2) !== 1)) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js');",
      'void baseline;',
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-inequality nullish primitives with null left values as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (((null ?? 1) !== 2)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-inequality nullish primitives with undefined left values as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (((void 0 ?? 1) !== 2)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-inequality nullish primitives with non-nullish left values as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if (((2 ?? marker) !== 1)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps strict-inequality nullish primitives with unknown left values conservative for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js');",
      'if ((((marker === 1) ?? 1) !== 2)) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js');",
      'void baseline;',
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-inequality conditional primitives with static selectors as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'if ((true ? 1 : 2) !== 2) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-inequality conditional primitives with matching unknown selectors as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if ((marker === 1 ? 1 : 1) !== 2) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps strict-inequality conditional primitives with differing unknown selectors conservative for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js');",
      'if ((marker === 1 ? 1 : 2) !== 2) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js');",
      'void baseline;',
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-inequality true conditions as true branches for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (1 !== 2) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-inequality false conditions as false branches for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (1 !== 1) {',
      '  reqAlias = require;',
      '} else {',
      '  reqAlias = () => undefined;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats logical-and false conditions as false branches for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (true && false) {',
      '  reqAlias = require;',
      '} else {',
      '  reqAlias = () => undefined;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats logical-or true conditions as true branches for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (false || true) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats logical-and short-circuit false conditions as false branches for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if (marker === 1 && false) {',
      '  reqAlias = require;',
      '} else {',
      '  reqAlias = () => undefined;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats logical-or short-circuit true conditions as true branches for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if (marker === 1 || true) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps logical-and true predicates unknown for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js');",
      'if (marker === 1 && true) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js');",
      'void baseline;',
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps logical-or false predicates unknown for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js');",
      'if (marker === 1 || false) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js');",
      'void baseline;',
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats conditional-expression true selectors as selected branches for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (true ? false : true) {',
      '  reqAlias = require;',
      '} else {',
      '  reqAlias = () => undefined;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats conditional-expression false selectors as selected branches for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (false ? false : true) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats conditional-expression unknown selectors with matching branches as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if (marker === 1 ? false : false) {',
      '  reqAlias = require;',
      '} else {',
      '  reqAlias = () => undefined;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats conditional-expression unknown selectors with matching true branches as deterministic for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if (marker === 1 ? true : true) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps conditional-expression unknown selectors with differing branches conservative for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js');",
      'if (marker === 1 ? true : false) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js');",
      'void baseline;',
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps conditional-expression selected unknown branches conservative for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js');",
      'if (true ? marker === 1 : false) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js');",
      'void baseline;',
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-inequality null-undefined conditions as true branches for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (null !== undefined) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('treats strict-equality void-undefined conditions as true branches for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (void 0 === undefined) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps strict-comparison identifier predicates unknown for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js');",
      'if (marker === 1) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps object-literal strict-comparison predicates unknown for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      "const baseline = require('./fixtures/guard-module.js');",
      'if ({ marker: 1 } === { marker: 1 }) {',
      '  reqAlias = () => undefined;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      'void baseline;',
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps possible branch require aliases in module specifiers for unknown if-else conditions', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (Math.random() > 0.5) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('clears require aliases in module specifiers when all unknown if branches overwrite to non-require values', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (Math.random() > 0.5) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = () => undefined;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('does not leak hoisted if-branch function alias shadowing to outer module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'if (true) {',
      "  reqAlias('./fixtures/other-module.js');",
      '  function reqAlias(_value: unknown) {',
      '    return _value;',
      '  }',
      '}',
      "const postIfCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('does not leak hoisted else-branch function alias shadowing to outer module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'if (false) {',
      '  void 0;',
      '} else {',
      "  reqAlias('./fixtures/other-module.js');",
      '  function reqAlias(_value: unknown) {',
      '    return _value;',
      '  }',
      '}',
      "const postElseCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('does not leak if-branch class alias shadowing before declaration to outer module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'if (true) {',
      "  reqAlias('./fixtures/other-module.js');",
      '  class reqAlias {}',
      '}',
      "const postIfCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('does not leak else-branch class alias shadowing before declaration to outer module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'if (false) {',
      '  void 0;',
      '} else {',
      "  reqAlias('./fixtures/other-module.js');",
      '  class reqAlias {}',
      '}',
      "const postElseCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('does not leak if-branch enum alias shadowing before declaration to outer module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'if (true) {',
      "  reqAlias('./fixtures/other-module.js');",
      '  enum reqAlias {',
      '    Marker = 0,',
      '  }',
      '}',
      "const postIfCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('does not leak else-branch enum alias shadowing before declaration to outer module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'if (false) {',
      '  void 0;',
      '} else {',
      "  reqAlias('./fixtures/other-module.js');",
      '  enum reqAlias {',
      '    Marker = 0,',
      '  }',
      '}',
      "const postElseCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('does not leak if-branch class alias declarations to outer module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'if (true) {',
      '  class reqAlias {}',
      "  reqAlias('./fixtures/other-module.js');",
      '}',
      "const postIfCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('does not leak else-branch class alias declarations to outer module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'if (false) {',
      '  void 0;',
      '} else {',
      '  class reqAlias {}',
      "  reqAlias('./fixtures/other-module.js');",
      '}',
      "const postElseCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('does not leak if-branch function alias declarations to outer module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'if (true) {',
      '  function reqAlias(_value: unknown) {',
      '    return _value;',
      '  }',
      "  reqAlias('./fixtures/other-module.js');",
      '}',
      "const postIfCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('does not leak else-branch function alias declarations to outer module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'if (false) {',
      '  void 0;',
      '} else {',
      '  function reqAlias(_value: unknown) {',
      '    return _value;',
      '  }',
      "  reqAlias('./fixtures/other-module.js');",
      '}',
      "const postElseCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('does not leak if-branch enum alias declarations to outer module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'if (true) {',
      '  enum reqAlias {',
      '    Marker = 0,',
      '  }',
      "  reqAlias('./fixtures/other-module.js');",
      '}',
      "const postIfCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('does not leak else-branch enum alias declarations to outer module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'if (false) {',
      '  void 0;',
      '} else {',
      '  enum reqAlias {',
      '    Marker = 0,',
      '  }',
      "  reqAlias('./fixtures/other-module.js');",
      '}',
      "const postElseCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('does not leak hoisted while-block function alias shadowing to outer module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'while (true) {',
      "  reqAlias('./fixtures/other-module.js');",
      '  function reqAlias(_value: unknown) {',
      '    return _value;',
      '  }',
      '  break;',
      '}',
      "const postWhileCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('does not leak hoisted do-while function alias shadowing to outer module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'do {',
      "  reqAlias('./fixtures/other-module.js');",
      '  function reqAlias(_value: unknown) {',
      '    return _value;',
      '  }',
      '} while (false);',
      "const postDoWhileCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('does not leak while-block class alias shadowing before declaration to outer module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'while (true) {',
      "  reqAlias('./fixtures/other-module.js');",
      '  class reqAlias {}',
      '  break;',
      '}',
      "const postWhileCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('does not leak do-while class alias shadowing before declaration to outer module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'do {',
      "  reqAlias('./fixtures/other-module.js');",
      '  class reqAlias {}',
      '} while (false);',
      "const postDoWhileCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('does not leak while-block class alias declarations to outer module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'while (true) {',
      '  class reqAlias {}',
      "  reqAlias('./fixtures/other-module.js');",
      '  break;',
      '}',
      "const postWhileCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('does not leak do-while class alias declarations to outer module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'do {',
      '  class reqAlias {}',
      "  reqAlias('./fixtures/other-module.js');",
      '} while (false);',
      "const postDoWhileCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('does not leak while-block function alias declarations to outer module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'while (true) {',
      '  function reqAlias(_value: unknown) {',
      '    return _value;',
      '  }',
      "  reqAlias('./fixtures/other-module.js');",
      '  break;',
      '}',
      "const postWhileCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('does not leak do-while function alias declarations to outer module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'do {',
      '  function reqAlias(_value: unknown) {',
      '    return _value;',
      '  }',
      "  reqAlias('./fixtures/other-module.js');",
      '} while (false);',
      "const postDoWhileCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('does not leak while-block enum alias shadowing before declaration to outer module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'while (true) {',
      "  reqAlias('./fixtures/other-module.js');",
      '  enum reqAlias {',
      '    Marker = 0,',
      '  }',
      '  break;',
      '}',
      "const postWhileCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('does not leak do-while enum alias shadowing before declaration to outer module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'do {',
      "  reqAlias('./fixtures/other-module.js');",
      '  enum reqAlias {',
      '    Marker = 0,',
      '  }',
      '} while (false);',
      "const postDoWhileCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('does not leak while-block enum alias declarations to outer module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'while (true) {',
      '  enum reqAlias {',
      '    Marker = 0,',
      '  }',
      "  reqAlias('./fixtures/other-module.js');",
      '  break;',
      '}',
      "const postWhileCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('does not leak do-while enum alias declarations to outer module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'do {',
      '  enum reqAlias {',
      '    Marker = 0,',
      '  }',
      "  reqAlias('./fixtures/other-module.js');",
      '} while (false);',
      "const postDoWhileCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('does not leak lexical for-loop enum alias shadowing before declaration to outer module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'for (const iteration of [1]) {',
      "  reqAlias('./fixtures/other-module.js');",
      '  enum reqAlias {',
      '    Marker = 0,',
      '  }',
      '  void iteration;',
      '}',
      "const postLoopCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('does not leak lexical for-loop enum alias declarations to outer module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'for (const iteration of [1]) {',
      '  enum reqAlias {',
      '    Marker = 0,',
      '  }',
      "  reqAlias('./fixtures/other-module.js');",
      '  void iteration;',
      '}',
      "const postLoopCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('does not leak lexical for-loop class alias shadowing before declaration to outer module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'for (const iteration of [1]) {',
      "  reqAlias('./fixtures/other-module.js');",
      '  class reqAlias {}',
      '  void iteration;',
      '}',
      "const postLoopCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('does not leak lexical for-loop class alias declarations to outer module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'for (const iteration of [1]) {',
      '  class reqAlias {}',
      "  reqAlias('./fixtures/other-module.js');",
      '  void iteration;',
      '}',
      "const postLoopCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('does not leak direct require shadowing across lexical for-of scopes', () => {
    const source = [
      'for (const require of [() => undefined]) {',
      "  require('./fixtures/other-module.js');",
      '}',
      "const postLoopCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('does not leak direct require shadowing across lexical for-in scopes', () => {
    const source = [
      'for (const require in { item: 1 }) {',
      "  require('./fixtures/other-module.js');",
      '}',
      "const postLoopCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('does not leak direct require shadowing across lexical for scopes', () => {
    const source = [
      'for (let require = () => undefined; ; ) {',
      "  require('./fixtures/other-module.js');",
      '  break;',
      '}',
      "const postLoopCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('does not treat binding-pattern shadowed require aliases as module specifier sources', () => {
    const source = [
      'const reqAlias = require;',
      '{',
      '  const { reqAlias } = { reqAlias: () => undefined };',
      "  reqAlias('./fixtures/other-module.js');",
      '}',
      "const postBlockCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('does not treat loop binding-pattern shadowed require aliases as module specifier sources', () => {
    const source = [
      'const reqAlias = require;',
      'for (const { reqAlias } of [{ reqAlias: () => undefined }]) {',
      "  reqAlias('./fixtures/other-module.js');",
      '}',
      "const postLoopCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('does not treat assignment-pattern shadowed require aliases as module specifier sources', () => {
    const source = [
      'let reqAlias = require;',
      '({ reqAlias } = { reqAlias: () => undefined });',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps require alias assignments made inside block scopes', () => {
    const source = [
      'let reqAlias: any;',
      '{',
      '  reqAlias = require;',
      '}',
      "const postBlockCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
  });

  it('does not leak block lexical alias shadowing before declaration to outer module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      '{',
      "  reqAlias('./fixtures/other-module.js');",
      '  const reqAlias = () => undefined;',
      '}',
      "const postBlockCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps block type-alias declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      '{',
      "  reqAlias('./fixtures/other-module.js');",
      '  type reqAlias = (_value: unknown) => unknown;',
      '}',
      "const postBlockCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps block interface declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      '{',
      "  reqAlias('./fixtures/other-module.js');",
      '  interface reqAlias {',
      '    value: string;',
      '  }',
      '}',
      "const postBlockCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps block ambient class declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      '{',
      "  reqAlias('./fixtures/other-module.js');",
      '  declare class reqAlias {}',
      '}',
      "const postBlockCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps block ambient enum declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      '{',
      "  reqAlias('./fixtures/other-module.js');",
      '  declare enum reqAlias {',
      '    Marker = 0,',
      '  }',
      '}',
      "const postBlockCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps block ambient function declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      '{',
      "  reqAlias('./fixtures/other-module.js');",
      '  declare function reqAlias(_path: string): unknown;',
      '}',
      "const postBlockCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps block ambient namespace declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      '{',
      "  reqAlias('./fixtures/other-module.js');",
      '  declare namespace reqAlias {',
      '    const marker: unknown;',
      '  }',
      '}',
      "const postBlockCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps block ambient module declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      '{',
      "  reqAlias('./fixtures/other-module.js');",
      '  declare module reqAlias {',
      '    const marker: unknown;',
      '  }',
      '}',
      "const postBlockCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps block ambient const declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      '{',
      "  reqAlias('./fixtures/other-module.js');",
      '  declare const reqAlias: (_path: string) => unknown;',
      '}',
      "const postBlockCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps block ambient let declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      '{',
      "  reqAlias('./fixtures/other-module.js');",
      '  declare let reqAlias: (_path: string) => unknown;',
      '}',
      "const postBlockCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps block ambient var declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      '{',
      "  reqAlias('./fixtures/other-module.js');",
      '  declare var reqAlias: (_path: string) => unknown;',
      '}',
      "const postBlockCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('does not leak hoisted block function alias shadowing to outer module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      '{',
      "  reqAlias('./fixtures/other-module.js');",
      '  function reqAlias(_value: unknown) {',
      '    return _value;',
      '  }',
      '}',
      "const postBlockCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('does not leak block class alias shadowing before declaration to outer module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      '{',
      "  reqAlias('./fixtures/other-module.js');",
      '  class reqAlias {}',
      '  void reqAlias;',
      '}',
      "const postBlockCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('does not leak block class alias declarations to outer module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      '{',
      '  class reqAlias {}',
      "  reqAlias('./fixtures/other-module.js');",
      '}',
      "const postBlockCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('does not leak block enum alias shadowing before declaration to outer module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      '{',
      "  reqAlias('./fixtures/other-module.js');",
      '  enum reqAlias {',
      '    Marker = 0,',
      '  }',
      '  void reqAlias;',
      '}',
      "const postBlockCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('does not leak block enum alias declarations to outer module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      '{',
      '  enum reqAlias {',
      '    Marker = 0,',
      '  }',
      "  reqAlias('./fixtures/other-module.js');",
      '}',
      "const postBlockCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('clears require alias assignments to non-require values inside block scopes', () => {
    const source = [
      'let reqAlias: any = require;',
      '{',
      '  reqAlias = () => undefined;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps require alias var declarations made inside block scopes', () => {
    const source = [
      '{',
      '  var reqAlias = require;',
      '}',
      "const postBlockCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
  });

  it('keeps require alias assignments made inside switch case scopes', () => {
    const source = [
      'let reqAlias: any;',
      'switch (1) {',
      '  case 1:',
      '    reqAlias = require;',
      '    break;',
      '}',
      "const postCaseCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
  });

  it('clears require alias assignments to non-require values inside switch case scopes', () => {
    const source = [
      'let reqAlias: any = require;',
      'switch (1) {',
      '  case 1:',
      '    reqAlias = () => undefined;',
      '    break;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps require alias var declarations made inside switch case scopes', () => {
    const source = [
      'switch (1) {',
      '  case 1:',
      '    var reqAlias = require;',
      "    reqAlias('./fixtures/guard-module.js');",
      '    break;',
      '}',
      "const postCaseCall = reqAlias('./fixtures/other-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('clears require alias var declarations to non-require values inside switch case scopes', () => {
    const source = [
      'switch (1) {',
      '  case 1:',
      '    var reqAlias = require;',
      "    reqAlias('./fixtures/guard-module.js');",
      '    reqAlias = () => undefined;',
      '    break;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('applies switch-case destructuring assignments to outer require aliases for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'switch (1) {',
      '  case 1:',
      '    ({ reqAlias } = { reqAlias: () => undefined });',
      '    break;',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('applies switch-case require assignments to outer aliases for module specifiers', () => {
    const source = [
      'let reqAlias: any = () => undefined;',
      'switch (1) {',
      '  case 1:',
      '    reqAlias = require;',
      '    break;',
      '}',
      "const postCaseCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
  });

  it('does not leak switch-case lexical alias declarations to outer module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'switch (1) {',
      '  case 1: {',
      '    const reqAlias = () => undefined;',
      "    reqAlias('./fixtures/other-module.js');",
      '    break;',
      '  }',
      '}',
      "const postCaseCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('does not leak switch-case lexical alias shadowing before declaration to outer module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'switch (1) {',
      '  case 1:',
      "    reqAlias('./fixtures/other-module.js');",
      '    const reqAlias = () => undefined;',
      '    break;',
      '  default:',
      '    break;',
      '}',
      "const postCaseCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps switch-case type-alias declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'switch (1) {',
      '  case 1:',
      "    reqAlias('./fixtures/other-module.js');",
      '    type reqAlias = (_value: unknown) => unknown;',
      '    break;',
      '  default:',
      '    break;',
      '}',
      "const postCaseCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps switch-case interface declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'switch (1) {',
      '  case 1:',
      "    reqAlias('./fixtures/other-module.js');",
      '    interface reqAlias {',
      '      value: string;',
      '    }',
      '    break;',
      '  default:',
      '    break;',
      '}',
      "const postCaseCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps switch-case ambient class declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'switch (1) {',
      '  case 1:',
      "    reqAlias('./fixtures/other-module.js');",
      '    declare class reqAlias {}',
      '    break;',
      '  default:',
      '    break;',
      '}',
      "const postCaseCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps switch-case ambient enum declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'switch (1) {',
      '  case 1:',
      "    reqAlias('./fixtures/other-module.js');",
      '    declare enum reqAlias {',
      '      Marker = 0,',
      '    }',
      '    break;',
      '  default:',
      '    break;',
      '}',
      "const postCaseCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps switch-case ambient function declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'switch (1) {',
      '  case 1:',
      "    reqAlias('./fixtures/other-module.js');",
      '    declare function reqAlias(_path: string): unknown;',
      '    break;',
      '  default:',
      '    break;',
      '}',
      "const postCaseCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps switch-case ambient namespace declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'switch (1) {',
      '  case 1:',
      "    reqAlias('./fixtures/other-module.js');",
      '    declare namespace reqAlias {',
      '      const marker: unknown;',
      '    }',
      '    break;',
      '  default:',
      '    break;',
      '}',
      "const postCaseCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps switch-case ambient module declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'switch (1) {',
      '  case 1:',
      "    reqAlias('./fixtures/other-module.js');",
      '    declare module reqAlias {',
      '      const marker: unknown;',
      '    }',
      '    break;',
      '  default:',
      '    break;',
      '}',
      "const postCaseCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps switch-case ambient const declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'switch (1) {',
      '  case 1:',
      "    reqAlias('./fixtures/other-module.js');",
      '    declare const reqAlias: (_path: string) => unknown;',
      '    break;',
      '  default:',
      '    break;',
      '}',
      "const postCaseCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps switch-case ambient let declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'switch (1) {',
      '  case 1:',
      "    reqAlias('./fixtures/other-module.js');",
      '    declare let reqAlias: (_path: string) => unknown;',
      '    break;',
      '  default:',
      '    break;',
      '}',
      "const postCaseCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps switch-case ambient var declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'switch (1) {',
      '  case 1:',
      "    reqAlias('./fixtures/other-module.js');",
      '    declare var reqAlias: (_path: string) => unknown;',
      '    break;',
      '  default:',
      '    break;',
      '}',
      "const postCaseCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('does not leak hoisted switch-case function alias shadowing to outer module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'switch (1) {',
      '  case 1:',
      "    reqAlias('./fixtures/other-module.js');",
      '    function reqAlias(_value: unknown) {',
      '      return _value;',
      '    }',
      '    break;',
      '  default:',
      '    break;',
      '}',
      "const postCaseCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('does not leak switch-case class alias declarations to outer module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'switch (1) {',
      '  case 1: {',
      '    class reqAlias {}',
      "    reqAlias('./fixtures/other-module.js');",
      '    break;',
      '  }',
      '}',
      "const postCaseCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('does not leak switch-case class alias shadowing before declaration to outer module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'switch (1) {',
      '  case 1:',
      "    reqAlias('./fixtures/other-module.js');",
      '    class reqAlias {}',
      '    break;',
      '  default:',
      '    break;',
      '}',
      "const postCaseCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('does not leak switch-case enum alias shadowing before declaration to outer module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'switch (1) {',
      '  case 1:',
      "    reqAlias('./fixtures/other-module.js');",
      '    enum reqAlias {',
      '      Marker = 0,',
      '    }',
      '    break;',
      '  default:',
      '    break;',
      '}',
      "const postCaseCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('does not leak switch-case enum alias declarations to outer module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'switch (1) {',
      '  case 1: {',
      '    enum reqAlias {',
      '      Marker = 0,',
      '    }',
      "    reqAlias('./fixtures/other-module.js');",
      '    break;',
      '  }',
      '}',
      "const postCaseCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('does not leak class static-block lexical alias declarations to outer module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'class ShadowContainer {',
      '  static {',
      '    const reqAlias = () => undefined;',
      "    reqAlias('./fixtures/other-module.js');",
      '  }',
      '}',
      "const postStaticCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('does not leak class static-block function declaration alias shadowing to outer module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'class ShadowContainer {',
      '  static {',
      '    function reqAlias(_value: unknown) {',
      '      return _value;',
      '    }',
      "    reqAlias('./fixtures/other-module.js');",
      '  }',
      '}',
      "const postStaticCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('does not leak class static-block class alias declarations to outer module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'class ShadowContainer {',
      '  static {',
      '    class reqAlias {}',
      "    reqAlias('./fixtures/other-module.js');",
      '  }',
      '}',
      "const postStaticCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('does not leak hoisted class static-block function alias shadowing to outer module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'class ShadowContainer {',
      '  static {',
      "    reqAlias('./fixtures/other-module.js');",
      '    function reqAlias(_value: unknown) {',
      '      return _value;',
      '    }',
      '  }',
      '}',
      "const postStaticCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('does not leak class static-block lexical alias shadowing before declaration to outer module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'class ShadowContainer {',
      '  static {',
      "    reqAlias('./fixtures/other-module.js');",
      '    const reqAlias = () => undefined;',
      '  }',
      '}',
      "const postStaticCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('does not leak class static-block class alias shadowing before declaration to outer module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'class ShadowContainer {',
      '  static {',
      "    reqAlias('./fixtures/other-module.js');",
      '    class reqAlias {}',
      '  }',
      '}',
      "const postStaticCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('does not leak class static-block enum alias shadowing before declaration to outer module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'class ShadowContainer {',
      '  static {',
      "    reqAlias('./fixtures/other-module.js');",
      '    enum reqAlias {',
      '      Marker = 0,',
      '    }',
      '  }',
      '}',
      "const postStaticCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('does not leak class static-block enum alias declarations to outer module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'class ShadowContainer {',
      '  static {',
      '    enum reqAlias {',
      '      Marker = 0,',
      '    }',
      "    reqAlias('./fixtures/other-module.js');",
      '  }',
      '}',
      "const postStaticCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps class static-block type-alias declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'class ShadowContainer {',
      '  static {',
      "    reqAlias('./fixtures/other-module.js');",
      '    type reqAlias = (_value: unknown) => unknown;',
      '  }',
      '}',
      "const postStaticCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps class static-block interface declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'class ShadowContainer {',
      '  static {',
      "    reqAlias('./fixtures/other-module.js');",
      '    interface reqAlias {',
      '      value: string;',
      '    }',
      '  }',
      '}',
      "const postStaticCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps class static-block ambient class declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'class ShadowContainer {',
      '  static {',
      "    reqAlias('./fixtures/other-module.js');",
      '    declare class reqAlias {}',
      '  }',
      '}',
      "const postStaticCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps class static-block ambient enum declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'class ShadowContainer {',
      '  static {',
      "    reqAlias('./fixtures/other-module.js');",
      '    declare enum reqAlias {',
      '      Marker = 0,',
      '    }',
      '  }',
      '}',
      "const postStaticCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps class static-block ambient function declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'class ShadowContainer {',
      '  static {',
      "    reqAlias('./fixtures/other-module.js');",
      '    declare function reqAlias(_path: string): unknown;',
      '  }',
      '}',
      "const postStaticCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps class static-block ambient namespace declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'class ShadowContainer {',
      '  static {',
      "    reqAlias('./fixtures/other-module.js');",
      '    declare namespace reqAlias {',
      '      const marker: unknown;',
      '    }',
      '  }',
      '}',
      "const postStaticCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps class static-block ambient module declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'class ShadowContainer {',
      '  static {',
      "    reqAlias('./fixtures/other-module.js');",
      '    declare module reqAlias {',
      '      const marker: unknown;',
      '    }',
      '  }',
      '}',
      "const postStaticCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps class static-block ambient const declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'class ShadowContainer {',
      '  static {',
      "    reqAlias('./fixtures/other-module.js');",
      '    declare const reqAlias: (_path: string) => unknown;',
      '  }',
      '}',
      "const postStaticCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps class static-block ambient let declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'class ShadowContainer {',
      '  static {',
      "    reqAlias('./fixtures/other-module.js');",
      '    declare let reqAlias: (_path: string) => unknown;',
      '  }',
      '}',
      "const postStaticCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps class static-block ambient var declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'class ShadowContainer {',
      '  static {',
      "    reqAlias('./fixtures/other-module.js');",
      '    declare var reqAlias: (_path: string) => unknown;',
      '  }',
      '}',
      "const postStaticCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('does not leak class static-block var alias shadowing to outer module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'class ShadowContainer {',
      '  static {',
      '    var reqAlias = () => undefined;',
      "    reqAlias('./fixtures/other-module.js');",
      '  }',
      '}',
      "const postStaticCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('does not leak nested class static-block var alias shadowing to outer module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'class ShadowContainer {',
      '  static {',
      '    if (true) {',
      '      var reqAlias = () => undefined;',
      "      reqAlias('./fixtures/other-module.js');",
      '    }',
      '  }',
      '}',
      "const postStaticCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('does not leak class static-block for-of var alias shadowing to outer module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'class ShadowContainer {',
      '  static {',
      '    for (var reqAlias of [() => undefined]) {',
      "      reqAlias('./fixtures/other-module.js');",
      '    }',
      '  }',
      '}',
      "const postStaticCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('does not leak class static-block for-in var alias shadowing to outer module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'class ShadowContainer {',
      '  static {',
      '    const aliases: Record<string, (value: unknown) => unknown> = { first: () => undefined };',
      '    for (var aliasKey in aliases) {',
      '      var reqAlias = aliases[aliasKey];',
      "      reqAlias('./fixtures/other-module.js');",
      '    }',
      '  }',
      '}',
      "const postStaticCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('does not leak class static-block switch-case var alias shadowing to outer module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'class ShadowContainer {',
      '  static {',
      '    switch (1) {',
      '      case 1:',
      '        var reqAlias = () => undefined;',
      "        reqAlias('./fixtures/other-module.js');",
      '        break;',
      '      default:',
      '        break;',
      '    }',
      '  }',
      '}',
      "const postStaticCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('does not leak class static-block for var alias shadowing to outer module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'class ShadowContainer {',
      '  static {',
      '    for (var i = 0; i < 1; i += 1) {',
      '      var reqAlias = () => undefined;',
      "      reqAlias('./fixtures/other-module.js');",
      '    }',
      '  }',
      '}',
      "const postStaticCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('does not leak class static-block do-while var alias shadowing to outer module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'class ShadowContainer {',
      '  static {',
      '    do {',
      '      var reqAlias = () => undefined;',
      "      reqAlias('./fixtures/other-module.js');",
      '      break;',
      '    } while (false);',
      '  }',
      '}',
      "const postStaticCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('does not leak class static-block while var alias shadowing to outer module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'class ShadowContainer {',
      '  static {',
      '    while (true) {',
      '      var reqAlias = () => undefined;',
      "      reqAlias('./fixtures/other-module.js');",
      '      break;',
      '    }',
      '  }',
      '}',
      "const postStaticCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('does not leak class static-block try-block var alias shadowing to outer module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'class ShadowContainer {',
      '  static {',
      '    try {',
      '      var reqAlias = () => undefined;',
      "      reqAlias('./fixtures/other-module.js');",
      '    } catch (error) {',
      '      void error;',
      '    }',
      '  }',
      '}',
      "const postStaticCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('does not leak class static-block catch-block var alias shadowing to outer module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'class ShadowContainer {',
      '  static {',
      '    try {',
      "      throw new Error('boom');",
      '    } catch (error) {',
      '      var reqAlias = () => undefined;',
      "      reqAlias('./fixtures/other-module.js');",
      '      void error;',
      '    }',
      '  }',
      '}',
      "const postStaticCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('does not leak class static-block finally-block var alias shadowing to outer module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'class ShadowContainer {',
      '  static {',
      '    try {',
      '      void 0;',
      '    } finally {',
      '      var reqAlias = () => undefined;',
      "      reqAlias('./fixtures/other-module.js');",
      '    }',
      '  }',
      '}',
      "const postStaticCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('applies class static-block assignments to outer require aliases for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'class ShadowContainer {',
      '  static {',
      '    reqAlias = () => undefined;',
      '  }',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('applies class static-block destructuring assignments to outer require aliases for module specifiers', () => {
    const source = [
      'let reqAlias: any = require;',
      'class ShadowContainer {',
      '  static {',
      '    ({ reqAlias } = { reqAlias: () => undefined });',
      '  }',
      '}',
      "reqAlias('./fixtures/other-module.js');",
      "const directCall = require('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('applies class static-block require assignments to outer aliases for module specifiers', () => {
    const source = [
      'let reqAlias: any;',
      'class ShadowContainer {',
      '  static {',
      '    reqAlias = require;',
      '  }',
      '}',
      "const postStaticCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
  });

  it('does not leak namespace lexical alias declarations to outer module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'namespace ShadowSpace {',
      '  const reqAlias = () => undefined;',
      "  reqAlias('./fixtures/other-module.js');",
      '}',
      "const postNamespaceCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('does not leak namespace lexical alias shadowing before declaration to outer module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'namespace ShadowSpace {',
      "  reqAlias('./fixtures/other-module.js');",
      '  const reqAlias = () => undefined;',
      '}',
      "const postNamespaceCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps namespace type-alias declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'namespace ShadowSpace {',
      "  reqAlias('./fixtures/other-module.js');",
      '  type reqAlias = (_value: unknown) => unknown;',
      '}',
      "const postNamespaceCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps namespace interface declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'namespace ShadowSpace {',
      "  reqAlias('./fixtures/other-module.js');",
      '  interface reqAlias {',
      '    value: string;',
      '  }',
      '}',
      "const postNamespaceCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps namespace ambient class declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'namespace ShadowNamespace {',
      "  reqAlias('./fixtures/other-module.js');",
      '  declare class reqAlias {}',
      '}',
      "const postNamespaceCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps namespace ambient enum declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'namespace ShadowNamespace {',
      "  reqAlias('./fixtures/other-module.js');",
      '  declare enum reqAlias {',
      '    Marker = 0,',
      '  }',
      '}',
      "const postNamespaceCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps namespace ambient function declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'namespace ShadowNamespace {',
      "  reqAlias('./fixtures/other-module.js');",
      '  declare function reqAlias(_path: string): unknown;',
      '}',
      "const postNamespaceCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps namespace ambient namespace declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'namespace ShadowNamespace {',
      "  reqAlias('./fixtures/other-module.js');",
      '  declare namespace reqAlias {',
      '    const marker: unknown;',
      '  }',
      '}',
      "const postNamespaceCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps namespace ambient module declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'namespace ShadowNamespace {',
      "  reqAlias('./fixtures/other-module.js');",
      '  declare module reqAlias {',
      '    const marker: unknown;',
      '  }',
      '}',
      "const postNamespaceCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps namespace ambient const declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'namespace ShadowNamespace {',
      "  reqAlias('./fixtures/other-module.js');",
      '  declare const reqAlias: (_path: string) => unknown;',
      '}',
      "const postNamespaceCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps namespace ambient let declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'namespace ShadowNamespace {',
      "  reqAlias('./fixtures/other-module.js');",
      '  declare let reqAlias: (_path: string) => unknown;',
      '}',
      "const postNamespaceCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps namespace ambient var declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'namespace ShadowNamespace {',
      "  reqAlias('./fixtures/other-module.js');",
      '  declare var reqAlias: (_path: string) => unknown;',
      '}',
      "const postNamespaceCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('does not leak hoisted namespace function alias shadowing to outer module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'namespace ShadowSpace {',
      "  reqAlias('./fixtures/other-module.js');",
      '  function reqAlias(_value: unknown) {',
      '    return _value;',
      '  }',
      '}',
      "const postNamespaceCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('does not leak namespace class alias shadowing before declaration to outer module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'namespace ShadowSpace {',
      "  reqAlias('./fixtures/other-module.js');",
      '  class reqAlias {}',
      '}',
      "const postNamespaceCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('does not leak namespace class alias declarations to outer module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'namespace ShadowSpace {',
      '  class reqAlias {}',
      "  reqAlias('./fixtures/other-module.js');",
      '}',
      "const postNamespaceCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('does not leak namespace enum alias shadowing before declaration to outer module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'namespace ShadowSpace {',
      "  reqAlias('./fixtures/other-module.js');",
      '  enum reqAlias {',
      '    Marker = 0,',
      '  }',
      '}',
      "const postNamespaceCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('does not leak namespace enum alias declarations to outer module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'namespace ShadowSpace {',
      '  enum reqAlias {',
      '    Marker = 0,',
      '  }',
      "  reqAlias('./fixtures/other-module.js');",
      '}',
      "const postNamespaceCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('does not leak labeled lexical alias declarations to outer module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'label: {',
      '  const reqAlias = () => undefined;',
      "  reqAlias('./fixtures/other-module.js');",
      '}',
      "const postLabelCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('does not leak labeled lexical alias shadowing before declaration to outer module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'label: {',
      "  reqAlias('./fixtures/other-module.js');",
      '  const reqAlias = () => undefined;',
      '}',
      "const postLabelCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps labeled type-alias declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'label: {',
      "  reqAlias('./fixtures/other-module.js');",
      '  type reqAlias = (_value: unknown) => unknown;',
      '}',
      "const postLabelCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps labeled interface declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'label: {',
      "  reqAlias('./fixtures/other-module.js');",
      '  interface reqAlias {',
      '    value: string;',
      '  }',
      '}',
      "const postLabelCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps labeled ambient class declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'label: {',
      "  reqAlias('./fixtures/other-module.js');",
      '  declare class reqAlias {}',
      '}',
      "const postLabelCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps labeled ambient enum declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'label: {',
      "  reqAlias('./fixtures/other-module.js');",
      '  declare enum reqAlias {',
      '    Marker = 0,',
      '  }',
      '}',
      "const postLabelCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps labeled ambient function declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'label: {',
      "  reqAlias('./fixtures/other-module.js');",
      '  declare function reqAlias(_path: string): unknown;',
      '}',
      "const postLabelCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps labeled ambient namespace declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'label: {',
      "  reqAlias('./fixtures/other-module.js');",
      '  declare namespace reqAlias {',
      '    const marker: unknown;',
      '  }',
      '}',
      "const postLabelCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps labeled ambient module declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'label: {',
      "  reqAlias('./fixtures/other-module.js');",
      '  declare module reqAlias {',
      '    const marker: unknown;',
      '  }',
      '}',
      "const postLabelCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps labeled ambient const declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'label: {',
      "  reqAlias('./fixtures/other-module.js');",
      '  declare const reqAlias: (_path: string) => unknown;',
      '}',
      "const postLabelCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps labeled ambient let declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'label: {',
      "  reqAlias('./fixtures/other-module.js');",
      '  declare let reqAlias: (_path: string) => unknown;',
      '}',
      "const postLabelCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps labeled ambient var declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'label: {',
      "  reqAlias('./fixtures/other-module.js');",
      '  declare var reqAlias: (_path: string) => unknown;',
      '}',
      "const postLabelCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('does not leak hoisted labeled function alias shadowing to outer module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'label: {',
      "  reqAlias('./fixtures/other-module.js');",
      '  function reqAlias(_value: unknown) {',
      '    return _value;',
      '  }',
      '}',
      "const postLabelCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('does not leak labeled class alias shadowing before declaration to outer module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'label: {',
      "  reqAlias('./fixtures/other-module.js');",
      '  class reqAlias {}',
      '}',
      "const postLabelCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('does not leak labeled class alias declarations to outer module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'label: {',
      '  class reqAlias {}',
      "  reqAlias('./fixtures/other-module.js');",
      '}',
      "const postLabelCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('does not leak labeled enum alias shadowing before declaration to outer module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'label: {',
      "  reqAlias('./fixtures/other-module.js');",
      '  enum reqAlias {',
      '    Marker = 0,',
      '  }',
      '}',
      "const postLabelCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('does not leak labeled enum alias declarations to outer module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      'label: {',
      '  enum reqAlias {',
      '    Marker = 0,',
      '  }',
      "  reqAlias('./fixtures/other-module.js');",
      '}',
      "const postLabelCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps labeled var alias declarations made inside block scopes', () => {
    const source = [
      'let reqAlias: any;',
      'label: {',
      '  var reqAlias = require;',
      '}',
      "const postLabelCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
  });

  it('does not treat top-level function declaration named require as module specifier source', () => {
    const source = [
      "const preShadowCall = require('./fixtures/guard-module.js');",
      'function require(_value: unknown) {',
      '  return _value;',
      '}',
      "const postShadowCall = require('./fixtures/other-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('does not treat top-level class declaration named require alias as module specifier source', () => {
    const source = [
      'const reqAlias = require;',
      "const preShadowCall = reqAlias('./fixtures/guard-module.js');",
      'class reqAlias {}',
      "const postShadowCall = reqAlias('./fixtures/other-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('does not treat top-level enum declaration named require alias as module specifier source', () => {
    const source = [
      'const reqAlias = require;',
      "const preShadowCall = reqAlias('./fixtures/guard-module.js');",
      'enum reqAlias { Primary = 1 }',
      "const postShadowCall = reqAlias('./fixtures/other-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps top-level ambient class declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      "const preAmbientCall = reqAlias('./fixtures/guard-module.js');",
      'declare class reqAlias {}',
      "const postAmbientCall = reqAlias('./fixtures/other-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps top-level ambient enum declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      "const preAmbientCall = reqAlias('./fixtures/guard-module.js');",
      'declare enum reqAlias {',
      '  Primary = 1,',
      '}',
      "const postAmbientCall = reqAlias('./fixtures/other-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps top-level ambient function declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      "const preAmbientCall = reqAlias('./fixtures/guard-module.js');",
      'declare function reqAlias(_value: unknown): unknown;',
      "const postAmbientCall = reqAlias('./fixtures/other-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps top-level ambient const declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      "const preAmbientCall = reqAlias('./fixtures/guard-module.js');",
      'declare const reqAlias: (_value: unknown) => unknown;',
      "const postAmbientCall = reqAlias('./fixtures/other-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps top-level ambient var declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      "const preAmbientCall = reqAlias('./fixtures/guard-module.js');",
      'declare var reqAlias: (_value: unknown) => unknown;',
      "const postAmbientCall = reqAlias('./fixtures/other-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps top-level ambient let declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      "const preAmbientCall = reqAlias('./fixtures/guard-module.js');",
      'declare let reqAlias: (_value: unknown) => unknown;',
      "const postAmbientCall = reqAlias('./fixtures/other-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps top-level ambient namespace declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      "const preAmbientCall = reqAlias('./fixtures/guard-module.js');",
      'declare namespace reqAlias {',
      '  const marker: unknown;',
      '}',
      "const postAmbientCall = reqAlias('./fixtures/other-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps top-level ambient module declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      "const preAmbientCall = reqAlias('./fixtures/guard-module.js');",
      'declare module reqAlias {',
      '  const marker: unknown;',
      '}',
      "const postAmbientCall = reqAlias('./fixtures/other-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps top-level type-alias declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      "const preTypeAliasCall = reqAlias('./fixtures/guard-module.js');",
      'type reqAlias = (_value: unknown) => unknown;',
      "const postTypeAliasCall = reqAlias('./fixtures/other-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('keeps top-level interface declarations from shadowing runtime require aliases in module specifiers', () => {
    const source = [
      'const reqAlias = require;',
      "const preInterfaceCall = reqAlias('./fixtures/guard-module.js');",
      'interface reqAlias {',
      '  marker: unknown;',
      '}',
      "const postInterfaceCall = reqAlias('./fixtures/other-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('does not treat block-scoped function shadowing of require alias as module specifier source', () => {
    const source = [
      'const reqAlias = require;',
      '{',
      '  function reqAlias(_value: unknown) {',
      '    return _value;',
      '  }',
      "  const innerCall = reqAlias('./fixtures/other-module.js');",
      '}',
      "const outerCall = reqAlias('./fixtures/guard-module.js');",
    ].join('\n');
    const moduleReferences = collectModuleSpecifierReferences(
      source,
      'fixture.ts',
    ).map((reference) => `${reference.source}@${reference.filePath}`);
    expect(moduleReferences).to.include(
      './fixtures/guard-module.js@fixture.ts',
    );
    expect(moduleReferences).to.not.include(
      './fixtures/other-module.js@fixture.ts',
    );
  });

  it('tracks default symbol references from namespace and require access', () => {
    const source = [
      "import * as infra from './fixtures/guard-module.js';",
      'const namespaceDefault = infra.default;',
      "const namespaceElementDefault = infra['default'];",
      "const requireDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('tracks default symbol references from dynamic import aliases', () => {
    const source = [
      "let infraModule: any = await import('./fixtures/guard-module.js');",
      'infraModule = infraModule;',
      'const dynamicDefault = infraModule.default;',
      "const dynamicElementDefault = infraModule['default'];",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('tracks default symbol references through assertion wrappers', () => {
    const source = [
      "import * as infra from './fixtures/guard-module.js';",
      'const asAlias = infra as unknown;',
      'const typeAssertionAlias = <unknown>infra;',
      'const nonNullAlias = asAlias!;',
      'const satisfiesAlias = infra satisfies Record<string, unknown>;',
      'const fromAsAlias = asAlias.default;',
      "const fromTypeAssertionAlias = typeAssertionAlias['default'];",
      'const fromNonNullAlias = nonNullAlias.default;',
      'const fromSatisfiesAlias = satisfiesAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('tracks default symbol references through comma operator wrappers', () => {
    const source = [
      "const commaAlias = (0, require('./fixtures/guard-module.js'));",
      'const commaDefault = commaAlias.default;',
      "const inlineCommaDefault = (0, require('./fixtures/guard-module.js'))['default'];",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('tracks default symbol references through comma-wrapped require call targets', () => {
    const source = [
      "const callTargetAlias = (0, require)('./fixtures/guard-module.js');",
      'const callTargetDefault = callTargetAlias.default;',
      "const inlineCallTargetDefault = (0, require)('./fixtures/guard-module.js')['default'];",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('tracks default symbol references through aliased require call targets', () => {
    const source = [
      'let reqAlias: any = require;',
      "const aliasTarget = reqAlias('./fixtures/guard-module.js');",
      'const aliasDefault = aliasTarget.default;',
      'reqAlias = reqAlias;',
      "const wrappedAliasDefault = (0, reqAlias)('./fixtures/guard-module.js')['default'];",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('tracks default symbol references through logical-assignment require aliases', () => {
    const source = [
      'let reqAlias: any;',
      'reqAlias ||= require;',
      "const orAssignedDefault = reqAlias('./fixtures/guard-module.js').default;",
      'reqAlias &&= require;',
      "const andAssignedDefault = reqAlias('./fixtures/guard-module.js')['default'];",
      'reqAlias ??= require;',
      "const nullishAssignedDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('tracks default symbol references for aliases across shadowed scopes', () => {
    const source = [
      "import * as sdk from './fixtures/guard-module.js';",
      '{',
      "  const sdk = require('./fixtures/other-module.js');",
      '  const innerDefault = sdk.default;',
      '}',
      'const outerDefault = sdk.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('does not leak symbol-source aliases across function parameter shadows', () => {
    const source = [
      'const reqAlias = require;',
      'function run(reqAlias: any) {',
      "  return reqAlias('./fixtures/other-module.js').default;",
      '}',
      "const outerDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('keeps function-scope type-alias declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'function run() {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  type reqAlias = (_value: unknown) => unknown;',
      '}',
      'run();',
      "const outerDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps function-scope interface declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'function run() {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  interface reqAlias {',
      '    value: string;',
      '  }',
      '}',
      'run();',
      "const outerDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps function-scope ambient class declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'function run() {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  declare class reqAlias {}',
      '}',
      'run();',
      "const outerDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps function-scope ambient enum declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'function run() {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  declare enum reqAlias {',
      '    Marker = 0,',
      '  }',
      '}',
      'run();',
      "const outerDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps function-scope ambient function declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'function run() {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  declare function reqAlias(_path: string): unknown;',
      '}',
      'run();',
      "const outerDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps function-scope ambient namespace declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'function run() {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  declare namespace reqAlias {',
      '    const marker: unknown;',
      '  }',
      '}',
      'run();',
      "const outerDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps function-scope ambient module declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'function run() {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  declare module reqAlias {',
      '    const marker: unknown;',
      '  }',
      '}',
      'run();',
      "const outerDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps function-scope ambient const declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'function run() {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  declare const reqAlias: (_path: string) => unknown;',
      '}',
      'run();',
      "const outerDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps function-scope ambient let declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'function run() {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  declare let reqAlias: (_path: string) => unknown;',
      '}',
      'run();',
      "const outerDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps function-scope ambient var declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'function run() {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  declare var reqAlias: (_path: string) => unknown;',
      '}',
      'run();',
      "const outerDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('does not leak function-scope enum alias shadowing before declaration to outer symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'function run() {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  enum reqAlias {',
      '    Marker = 0,',
      '  }',
      '}',
      'run();',
      "const outerDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('does not leak function-scope enum alias declarations to outer symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'function run() {',
      '  enum reqAlias {',
      '    Marker = 0,',
      '  }',
      "  reqAlias('./fixtures/other-module.js').default;",
      '}',
      'run();',
      "const outerDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('does not leak function-scope class alias shadowing before declaration to outer symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'function run() {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  class reqAlias {}',
      '}',
      'run();',
      "const outerDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('does not leak function-scope class alias declarations to outer symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'function run() {',
      '  class reqAlias {}',
      "  reqAlias('./fixtures/other-module.js').default;",
      '}',
      'run();',
      "const outerDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('keeps function-scope type-alias declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'function run() {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  type moduleAlias = { inner: unknown };',
      '  void preDeclarationSymbol;',
      '}',
      'run();',
      'const outerDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps function-scope interface declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'function run() {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  interface moduleAlias {',
      '    inner: unknown;',
      '  }',
      '  void preDeclarationSymbol;',
      '}',
      'run();',
      'const outerDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps function-scope ambient class declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'function run() {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  declare class moduleAlias {}',
      '  void preDeclarationSymbol;',
      '}',
      'run();',
      'const outerDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps function-scope ambient enum declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'function run() {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  declare enum moduleAlias {',
      '    Marker = 0,',
      '  }',
      '  void preDeclarationSymbol;',
      '}',
      'run();',
      'const outerDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps function-scope ambient function declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'function run() {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  declare function moduleAlias(_path: string): unknown;',
      '  void preDeclarationSymbol;',
      '}',
      'run();',
      'const outerDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps function-scope ambient namespace declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'function run() {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  declare namespace moduleAlias {',
      '    const marker: unknown;',
      '  }',
      '  void preDeclarationSymbol;',
      '}',
      'run();',
      'const outerDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps function-scope ambient module declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'function run() {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  declare module moduleAlias {',
      '    const marker: unknown;',
      '  }',
      '  void preDeclarationSymbol;',
      '}',
      'run();',
      'const outerDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps function-scope ambient const declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'function run() {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  declare const moduleAlias: { inner: unknown };',
      '  void preDeclarationSymbol;',
      '}',
      'run();',
      'const outerDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps function-scope ambient let declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'function run() {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  declare let moduleAlias: { inner: unknown };',
      '  void preDeclarationSymbol;',
      '}',
      'run();',
      'const outerDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps function-scope ambient var declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'function run() {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  declare var moduleAlias: { inner: unknown };',
      '  void preDeclarationSymbol;',
      '}',
      'run();',
      'const outerDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('does not leak function-scope enum module-source alias shadowing before declaration to outer symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'function run() {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  enum moduleAlias {',
      '    Marker = 0,',
      '  }',
      '  void preDeclarationSymbol;',
      '}',
      'run();',
      'const outerDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('inner@./fixtures/guard-module.js');
  });

  it('does not leak function-scope enum module-source alias declarations to outer symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'function run() {',
      '  enum moduleAlias {',
      '    Marker = 0,',
      '  }',
      '  const postDeclarationSymbol = moduleAlias.inner;',
      '  void postDeclarationSymbol;',
      '}',
      'run();',
      'const outerDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('inner@./fixtures/guard-module.js');
  });

  it('does not leak function-scope class module-source alias shadowing before declaration to outer symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'function run() {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  class moduleAlias {}',
      '  void preDeclarationSymbol;',
      '}',
      'run();',
      'const outerDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('inner@./fixtures/guard-module.js');
  });

  it('does not leak function-scope class module-source alias declarations to outer symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'function run() {',
      '  class moduleAlias {}',
      '  const postDeclarationSymbol = moduleAlias.inner;',
      '  void postDeclarationSymbol;',
      '}',
      'run();',
      'const outerDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('inner@./fixtures/guard-module.js');
  });

  it('keeps symbol-source detection when require is ambient-declared as variable', () => {
    const source = [
      'declare const require: unknown;',
      "const ambientDeclaredDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('keeps symbol-source detection when require is ambient-declared as function', () => {
    const source = [
      'declare function require(path: string): unknown;',
      "const ambientDeclaredDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('keeps symbol-source detection when require is ambient-declared as class', () => {
    const source = [
      'declare class require {}',
      "const ambientDeclaredDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('keeps symbol-source detection when require is ambient-declared as enum', () => {
    const source = [
      'declare enum require {',
      '  Marker = 0,',
      '}',
      "const ambientDeclaredDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('keeps symbol-source detection when require is ambient-declared as namespace', () => {
    const source = [
      'declare namespace require {',
      '  const marker: unknown;',
      '}',
      "const ambientDeclaredDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('keeps symbol-source detection when require is ambient-declared as module', () => {
    const source = [
      'declare module require {',
      '  const marker: unknown;',
      '}',
      "const ambientDeclaredDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('keeps symbol-source detection when require is ambient-declared as let', () => {
    const source = [
      'declare let require: (path: string) => unknown;',
      "const ambientDeclaredDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('keeps symbol-source detection when require is ambient-declared as var', () => {
    const source = [
      'declare var require: (path: string) => unknown;',
      "const ambientDeclaredDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('keeps symbol-source detection when require has a type-alias declaration', () => {
    const source = [
      'type require = (path: string) => unknown;',
      "const ambientDeclaredDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('keeps symbol-source detection when require has an interface declaration', () => {
    const source = [
      'interface require {',
      '  (path: string): unknown;',
      '}',
      "const ambientDeclaredDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('does not treat shadowed require parameter default access as module-sourced', () => {
    const source = [
      "const outerDefault = require('./fixtures/guard-module.js').default;",
      'function run(require: any) {',
      "  return require('./fixtures/other-module.js').default;",
      '}',
      'void outerDefault;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('keeps try-block ambient class declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'try {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  declare class reqAlias {}',
      '} catch {}',
      "const postTryDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps try-block ambient enum declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'try {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  declare enum reqAlias {',
      '    Marker = 0,',
      '  }',
      '} catch {}',
      "const postTryDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps try-block ambient function declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'try {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  declare function reqAlias(path: string): unknown;',
      '} catch {}',
      "const postTryDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps try-block ambient namespace declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'try {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  declare namespace reqAlias {',
      '    const marker: unknown;',
      '  }',
      '} catch {}',
      "const postTryDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps try-block ambient module declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'try {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  declare module reqAlias {',
      '    const marker: unknown;',
      '  }',
      '} catch {}',
      "const postTryDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps try-block type-alias declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'try {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  type reqAlias = (_path: string) => unknown;',
      '} catch {}',
      "const postTryDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps try-block interface declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'try {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  interface reqAlias {',
      '    (_path: string): unknown;',
      '  }',
      '} catch {}',
      "const postTryDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps finally-block ambient class declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'try {} finally {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  declare class reqAlias {}',
      '}',
      "const postFinallyDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps finally-block ambient enum declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'try {} finally {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  declare enum reqAlias {',
      '    Marker = 0,',
      '  }',
      '}',
      "const postFinallyDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps finally-block ambient function declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'try {} finally {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  declare function reqAlias(path: string): unknown;',
      '}',
      "const postFinallyDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps finally-block ambient namespace declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'try {} finally {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  declare namespace reqAlias {',
      '    const marker: unknown;',
      '  }',
      '}',
      "const postFinallyDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps finally-block ambient module declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'try {} finally {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  declare module reqAlias {',
      '    const marker: unknown;',
      '  }',
      '}',
      "const postFinallyDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps finally-block type-alias declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'try {} finally {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  type reqAlias = (_path: string) => unknown;',
      '}',
      "const postFinallyDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps finally-block interface declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'try {} finally {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  interface reqAlias {',
      '    (_path: string): unknown;',
      '  }',
      '}',
      "const postFinallyDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps try-block ambient const declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'try {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  declare const reqAlias: (_path: string) => unknown;',
      '} catch {}',
      "const postTryDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps try-block ambient let declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'try {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  declare let reqAlias: (_path: string) => unknown;',
      '} catch {}',
      "const postTryDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps try-block ambient var declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'try {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  declare var reqAlias: (_path: string) => unknown;',
      '} catch {}',
      "const postTryDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps finally-block ambient const declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'try {} finally {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  declare const reqAlias: (_path: string) => unknown;',
      '}',
      "const postFinallyDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps finally-block ambient let declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'try {} finally {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  declare let reqAlias: (_path: string) => unknown;',
      '}',
      "const postFinallyDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps finally-block ambient var declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'try {} finally {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  declare var reqAlias: (_path: string) => unknown;',
      '}',
      "const postFinallyDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('does not leak symbol-source shadowing across catch clause scopes', () => {
    const source = [
      'try {',
      "  throw new Error('boom');",
      '} catch (require) {',
      "  require('./fixtures/other-module.js').default;",
      '}',
      "const postCatchDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('does not leak catch-block lexical alias declarations to outer symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'try {',
      "  throw new Error('boom');",
      '} catch (error) {',
      '  const reqAlias = () => undefined;',
      "  reqAlias('./fixtures/other-module.js').default;",
      '}',
      "const postCatchDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('does not leak catch-block lexical alias shadowing before declaration to outer symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'try {',
      "  throw new Error('boom');",
      '} catch (error) {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  const reqAlias = () => undefined;',
      '  void error;',
      '}',
      "const postCatchDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('keeps catch-block type-alias declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'try {',
      "  throw new Error('boom');",
      '} catch (error) {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  type reqAlias = (_value: unknown) => unknown;',
      '  void error;',
      '}',
      "const postCatchDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps catch-block interface declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'try {',
      "  throw new Error('boom');",
      '} catch (error) {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  interface reqAlias {',
      '    value: string;',
      '  }',
      '  void error;',
      '}',
      "const postCatchDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps catch-block ambient class declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'try {',
      '  throw new Error("boom");',
      '} catch (_error) {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  declare class reqAlias {}',
      '}',
      "const postCatchDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps catch-block ambient enum declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'try {',
      '  throw new Error("boom");',
      '} catch (_error) {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  declare enum reqAlias {',
      '    Marker = 0,',
      '  }',
      '}',
      "const postCatchDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps catch-block ambient function declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'try {',
      '  throw new Error("boom");',
      '} catch (_error) {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  declare function reqAlias(_path: string): unknown;',
      '}',
      "const postCatchDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps catch-block ambient namespace declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'try {',
      '  throw new Error("boom");',
      '} catch (_error) {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  declare namespace reqAlias {',
      '    const marker: unknown;',
      '  }',
      '}',
      "const postCatchDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps catch-block ambient module declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'try {',
      '  throw new Error("boom");',
      '} catch (_error) {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  declare module reqAlias {',
      '    const marker: unknown;',
      '  }',
      '}',
      "const postCatchDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps catch-block ambient const declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'try {',
      '  throw new Error("boom");',
      '} catch (_error) {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  declare const reqAlias: (_path: string) => unknown;',
      '}',
      "const postCatchDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps catch-block ambient let declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'try {',
      '  throw new Error("boom");',
      '} catch (_error) {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  declare let reqAlias: (_path: string) => unknown;',
      '}',
      "const postCatchDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps catch-block ambient var declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'try {',
      '  throw new Error("boom");',
      '} catch (_error) {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  declare var reqAlias: (_path: string) => unknown;',
      '}',
      "const postCatchDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('does not leak hoisted catch-block function alias shadowing to outer symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'try {',
      "  throw new Error('boom');",
      '} catch (error) {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  function reqAlias(_value: unknown) {',
      '    return _value;',
      '  }',
      '  void error;',
      '}',
      "const postCatchDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('does not leak catch-block class alias declarations to outer symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'try {',
      "  throw new Error('boom');",
      '} catch (error) {',
      '  class reqAlias {}',
      "  reqAlias('./fixtures/other-module.js').default;",
      '}',
      "const postCatchDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('does not leak catch-block class alias shadowing before declaration to outer symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'try {',
      "  throw new Error('boom');",
      '} catch (error) {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  class reqAlias {}',
      '  void error;',
      '}',
      "const postCatchDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('does not leak catch-block enum alias shadowing before declaration to outer symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'try {',
      "  throw new Error('boom');",
      '} catch (error) {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  enum reqAlias {',
      '    Marker = 0,',
      '  }',
      '  void error;',
      '}',
      "const postCatchDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('does not leak catch-block enum alias declarations to outer symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'try {',
      "  throw new Error('boom');",
      '} catch (error) {',
      '  enum reqAlias {',
      '    Marker = 0,',
      '  }',
      "  reqAlias('./fixtures/other-module.js').default;",
      '}',
      "const postCatchDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('does not leak catch binding-pattern require shadowing to outer symbol sources', () => {
    const source = [
      "const outerDefault = require('./fixtures/guard-module.js').default;",
      'try {',
      '  throw { require: () => undefined };',
      '} catch ({ require }) {',
      "  require('./fixtures/other-module.js').default;",
      '}',
      'void outerDefault;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('does not leak catch binding-pattern alias shadowing to outer symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'try {',
      '  throw { reqAlias: () => undefined };',
      '} catch ({ reqAlias }) {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '}',
      "const postCatchDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('does not leak nested catch binding-pattern require shadowing to outer symbol sources', () => {
    const source = [
      "const outerDefault = require('./fixtures/guard-module.js').default;",
      'try {',
      '  throw { nested: { require: () => undefined } };',
      '} catch ({ nested: { require } }) {',
      "  require('./fixtures/other-module.js').default;",
      '}',
      'void outerDefault;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('does not leak nested catch binding-pattern alias shadowing to outer symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'try {',
      '  throw { nested: { reqAlias: () => undefined } };',
      '} catch ({ nested: { reqAlias } }) {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '}',
      "const postCatchDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('keeps module-source alias var declarations made inside catch block scopes', () => {
    const source = [
      'let moduleAlias: any;',
      'try {',
      "  throw new Error('boom');",
      '} catch (error) {',
      "  var moduleAlias = require('./fixtures/guard-module.js');",
      '}',
      'const postCatchDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('clears module-source alias var declarations to non-module values inside catch block scopes', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'try {',
      "  throw new Error('boom');",
      '} catch (error) {',
      "  var moduleAlias = { default: 'not-a-module' };",
      '}',
      'const shadowedDefault = moduleAlias.default;',
      "const directDefault = require('./fixtures/guard-module.js').default;",
      'void shadowedDefault;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(
      references.filter(
        (reference) => reference === 'default@./fixtures/guard-module.js',
      ).length,
    ).to.equal(1);
  });

  it('does not leak catch-block lexical module-source alias shadowing before declaration to outer symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'try {',
      "  throw new Error('boom');",
      '} catch (error) {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  const moduleAlias = { inner: preDeclarationSymbol };',
      '  void moduleAlias;',
      '  void error;',
      '}',
      'const postCatchDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('inner@./fixtures/guard-module.js');
  });

  it('keeps try-block ambient class declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'try {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  declare class moduleAlias {}',
      '  void preDeclarationSymbol;',
      '} catch {}',
      'const postTryDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps try-block ambient enum declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'try {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  declare enum moduleAlias {',
      '    Marker = 0,',
      '  }',
      '  void preDeclarationSymbol;',
      '} catch {}',
      'const postTryDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps try-block ambient function declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'try {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  declare function moduleAlias(path: string): unknown;',
      '  void preDeclarationSymbol;',
      '} catch {}',
      'const postTryDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps try-block ambient namespace declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'try {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  declare namespace moduleAlias {',
      '    const marker: unknown;',
      '  }',
      '  void preDeclarationSymbol;',
      '} catch {}',
      'const postTryDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps try-block ambient module declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'try {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  declare module moduleAlias {',
      '    const marker: unknown;',
      '  }',
      '  void preDeclarationSymbol;',
      '} catch {}',
      'const postTryDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps try-block type-alias declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'try {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  type moduleAlias = { inner: unknown };',
      '  void preDeclarationSymbol;',
      '} catch {}',
      'const postTryDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps try-block interface declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'try {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  interface moduleAlias {',
      '    inner: unknown;',
      '  }',
      '  void preDeclarationSymbol;',
      '} catch {}',
      'const postTryDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps finally-block ambient class declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'try {} finally {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  declare class moduleAlias {}',
      '  void preDeclarationSymbol;',
      '}',
      'const postFinallyDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps finally-block ambient enum declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'try {} finally {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  declare enum moduleAlias {',
      '    Marker = 0,',
      '  }',
      '  void preDeclarationSymbol;',
      '}',
      'const postFinallyDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps finally-block ambient function declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'try {} finally {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  declare function moduleAlias(path: string): unknown;',
      '  void preDeclarationSymbol;',
      '}',
      'const postFinallyDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps finally-block ambient namespace declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'try {} finally {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  declare namespace moduleAlias {',
      '    const marker: unknown;',
      '  }',
      '  void preDeclarationSymbol;',
      '}',
      'const postFinallyDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps finally-block ambient module declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'try {} finally {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  declare module moduleAlias {',
      '    const marker: unknown;',
      '  }',
      '  void preDeclarationSymbol;',
      '}',
      'const postFinallyDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps finally-block type-alias declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'try {} finally {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  type moduleAlias = { inner: unknown };',
      '  void preDeclarationSymbol;',
      '}',
      'const postFinallyDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps finally-block interface declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'try {} finally {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  interface moduleAlias {',
      '    inner: unknown;',
      '  }',
      '  void preDeclarationSymbol;',
      '}',
      'const postFinallyDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps try-block ambient const declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'try {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  declare const moduleAlias: { inner: unknown };',
      '  void preDeclarationSymbol;',
      '} catch {}',
      'const postTryDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps try-block ambient let declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'try {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  declare let moduleAlias: { inner: unknown };',
      '  void preDeclarationSymbol;',
      '} catch {}',
      'const postTryDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps try-block ambient var declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'try {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  declare var moduleAlias: { inner: unknown };',
      '  void preDeclarationSymbol;',
      '} catch {}',
      'const postTryDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps finally-block ambient const declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'try {} finally {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  declare const moduleAlias: { inner: unknown };',
      '  void preDeclarationSymbol;',
      '}',
      'const postFinallyDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps finally-block ambient let declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'try {} finally {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  declare let moduleAlias: { inner: unknown };',
      '  void preDeclarationSymbol;',
      '}',
      'const postFinallyDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps finally-block ambient var declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'try {} finally {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  declare var moduleAlias: { inner: unknown };',
      '  void preDeclarationSymbol;',
      '}',
      'const postFinallyDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps catch-block type-alias declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'try {',
      "  throw new Error('boom');",
      '} catch (error) {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  type moduleAlias = { inner: unknown };',
      '  void preDeclarationSymbol;',
      '  void error;',
      '}',
      'const postCatchDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps catch-block interface declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'try {',
      "  throw new Error('boom');",
      '} catch (error) {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  interface moduleAlias {',
      '    inner: unknown;',
      '  }',
      '  void preDeclarationSymbol;',
      '  void error;',
      '}',
      'const postCatchDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps catch-block ambient class declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'try {',
      '  throw new Error("boom");',
      '} catch (_error) {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  declare class moduleAlias {}',
      '  void preDeclarationSymbol;',
      '}',
      'const postCatchDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps catch-block ambient enum declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'try {',
      '  throw new Error("boom");',
      '} catch (_error) {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  declare enum moduleAlias {',
      '    Marker = 0,',
      '  }',
      '  void preDeclarationSymbol;',
      '}',
      'const postCatchDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps catch-block ambient function declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'try {',
      '  throw new Error("boom");',
      '} catch (_error) {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  declare function moduleAlias(_path: string): unknown;',
      '  void preDeclarationSymbol;',
      '}',
      'const postCatchDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps catch-block ambient namespace declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'try {',
      '  throw new Error("boom");',
      '} catch (_error) {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  declare namespace moduleAlias {',
      '    const marker: unknown;',
      '  }',
      '  void preDeclarationSymbol;',
      '}',
      'const postCatchDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps catch-block ambient module declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'try {',
      '  throw new Error("boom");',
      '} catch (_error) {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  declare module moduleAlias {',
      '    const marker: unknown;',
      '  }',
      '  void preDeclarationSymbol;',
      '}',
      'const postCatchDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps catch-block ambient const declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'try {',
      '  throw new Error("boom");',
      '} catch (_error) {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  declare const moduleAlias: { inner: unknown };',
      '  void preDeclarationSymbol;',
      '}',
      'const postCatchDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps catch-block ambient let declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'try {',
      '  throw new Error("boom");',
      '} catch (_error) {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  declare let moduleAlias: { inner: unknown };',
      '  void preDeclarationSymbol;',
      '}',
      'const postCatchDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps catch-block ambient var declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'try {',
      '  throw new Error("boom");',
      '} catch (_error) {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  declare var moduleAlias: { inner: unknown };',
      '  void preDeclarationSymbol;',
      '}',
      'const postCatchDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('does not leak hoisted catch-block function module-source alias shadowing to outer symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'try {',
      "  throw new Error('boom');",
      '} catch (error) {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  function moduleAlias(_value: unknown) {',
      '    return _value;',
      '  }',
      '  void preDeclarationSymbol;',
      '  void error;',
      '}',
      'const postCatchDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('inner@./fixtures/guard-module.js');
  });

  it('does not leak catch-block class module-source alias shadowing before declaration to outer symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'try {',
      "  throw new Error('boom');",
      '} catch (error) {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  class moduleAlias {}',
      '  void preDeclarationSymbol;',
      '  void error;',
      '}',
      'const postCatchDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('inner@./fixtures/guard-module.js');
  });

  it('does not leak catch-block class module-source alias declarations to outer symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'try {',
      "  throw new Error('boom');",
      '} catch (error) {',
      '  class moduleAlias {}',
      '  const postDeclarationSymbol = moduleAlias.inner;',
      '  void postDeclarationSymbol;',
      '  void error;',
      '}',
      'const postCatchDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('inner@./fixtures/guard-module.js');
  });

  it('does not leak catch-block enum module-source alias shadowing before declaration to outer symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'try {',
      "  throw new Error('boom');",
      '} catch (error) {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  enum moduleAlias {',
      '    Marker = 0,',
      '  }',
      '  void preDeclarationSymbol;',
      '  void error;',
      '}',
      'const postCatchDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('inner@./fixtures/guard-module.js');
  });

  it('does not leak catch-block enum module-source alias declarations to outer symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'try {',
      "  throw new Error('boom');",
      '} catch (error) {',
      '  enum moduleAlias {',
      '    Marker = 0,',
      '  }',
      '  const postDeclarationSymbol = moduleAlias.inner;',
      '  void postDeclarationSymbol;',
      '  void error;',
      '}',
      'const postCatchDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('inner@./fixtures/guard-module.js');
  });

  it('does not leak symbol-source shadowing across lexical for-loop scopes', () => {
    const source = [
      'const reqAlias = require;',
      'for (const reqAlias of [() => undefined]) {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '}',
      "const postLoopDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('keeps lexical for-loop type-alias declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'for (const iteration of [1]) {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  type reqAlias = (_value: unknown) => unknown;',
      '  void iteration;',
      '}',
      "const postLoopDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps lexical for-loop interface declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'for (const iteration of [1]) {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  interface reqAlias {',
      '    value: string;',
      '  }',
      '  void iteration;',
      '}',
      "const postLoopDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps lexical for-loop ambient class declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'for (const iteration of [1]) {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  declare class reqAlias {}',
      '  void iteration;',
      '}',
      "const postLoopDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps lexical for-loop ambient enum declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'for (const iteration of [1]) {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  declare enum reqAlias {',
      '    Marker = 0,',
      '  }',
      '  void iteration;',
      '}',
      "const postLoopDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps lexical for-loop ambient function declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'for (const iteration of [1]) {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  declare function reqAlias(_path: string): unknown;',
      '  void iteration;',
      '}',
      "const postLoopDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps lexical for-loop ambient namespace declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'for (const iteration of [1]) {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  declare namespace reqAlias {',
      '    const marker: unknown;',
      '  }',
      '  void iteration;',
      '}',
      "const postLoopDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps lexical for-loop ambient module declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'for (const iteration of [1]) {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  declare module reqAlias {',
      '    const marker: unknown;',
      '  }',
      '  void iteration;',
      '}',
      "const postLoopDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps lexical for-loop ambient const declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'for (const iteration of [1]) {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  declare const reqAlias: (_path: string) => unknown;',
      '  void iteration;',
      '}',
      "const postLoopDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps lexical for-loop ambient let declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'for (const iteration of [1]) {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  declare let reqAlias: (_path: string) => unknown;',
      '  void iteration;',
      '}',
      "const postLoopDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps lexical for-loop ambient var declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'for (const iteration of [1]) {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  declare var reqAlias: (_path: string) => unknown;',
      '  void iteration;',
      '}',
      "const postLoopDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps while-block type-alias declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'while (true) {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  type reqAlias = (_path: string) => unknown;',
      '  break;',
      '}',
      "const postWhileDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps while-block interface declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'while (true) {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  interface reqAlias {',
      '    value: string;',
      '  }',
      '  break;',
      '}',
      "const postWhileDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps while-block ambient class declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'while (true) {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  declare class reqAlias {}',
      '  break;',
      '}',
      "const postWhileDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps while-block ambient enum declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'while (true) {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  declare enum reqAlias {',
      '    Marker = 0,',
      '  }',
      '  break;',
      '}',
      "const postWhileDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps while-block ambient function declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'while (true) {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  declare function reqAlias(_path: string): unknown;',
      '  break;',
      '}',
      "const postWhileDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps while-block ambient namespace declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'while (true) {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  declare namespace reqAlias {',
      '    const marker: unknown;',
      '  }',
      '  break;',
      '}',
      "const postWhileDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps while-block ambient module declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'while (true) {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  declare module reqAlias {',
      '    const marker: unknown;',
      '  }',
      '  break;',
      '}',
      "const postWhileDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps while-block ambient const declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'while (true) {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  declare const reqAlias: (_path: string) => unknown;',
      '  break;',
      '}',
      "const postWhileDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps while-block ambient let declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'while (true) {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  declare let reqAlias: (_path: string) => unknown;',
      '  break;',
      '}',
      "const postWhileDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps while-block ambient var declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'while (true) {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  declare var reqAlias: (_path: string) => unknown;',
      '  break;',
      '}',
      "const postWhileDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps do-while type-alias declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'do {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  type reqAlias = (_path: string) => unknown;',
      '} while (false);',
      "const postDoWhileDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps do-while interface declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'do {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  interface reqAlias {',
      '    value: string;',
      '  }',
      '} while (false);',
      "const postDoWhileDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps do-while ambient class declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'do {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  declare class reqAlias {}',
      '} while (false);',
      "const postDoWhileDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps do-while ambient enum declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'do {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  declare enum reqAlias {',
      '    Marker = 0,',
      '  }',
      '} while (false);',
      "const postDoWhileDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps do-while ambient function declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'do {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  declare function reqAlias(_path: string): unknown;',
      '} while (false);',
      "const postDoWhileDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps do-while ambient namespace declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'do {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  declare namespace reqAlias {',
      '    const marker: unknown;',
      '  }',
      '} while (false);',
      "const postDoWhileDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps do-while ambient module declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'do {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  declare module reqAlias {',
      '    const marker: unknown;',
      '  }',
      '} while (false);',
      "const postDoWhileDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps do-while ambient const declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'do {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  declare const reqAlias: (_path: string) => unknown;',
      '} while (false);',
      "const postDoWhileDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps do-while ambient let declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'do {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  declare let reqAlias: (_path: string) => unknown;',
      '} while (false);',
      "const postDoWhileDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps do-while ambient var declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'do {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  declare var reqAlias: (_path: string) => unknown;',
      '} while (false);',
      "const postDoWhileDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('does not leak direct require symbol-source shadowing across while scopes', () => {
    const source = [
      'while (true) {',
      '  const require = () => undefined;',
      "  require('./fixtures/other-module.js').default;",
      '  break;',
      '}',
      "const postWhileDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('does not leak direct require symbol-source shadowing across do-while scopes', () => {
    const source = [
      'do {',
      '  const require = () => undefined;',
      "  require('./fixtures/other-module.js').default;",
      '} while (false);',
      "const postDoWhileDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('does not leak while-block lexical alias shadowing before declaration to outer symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'while (true) {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  const reqAlias = () => undefined;',
      '  break;',
      '}',
      "const postWhileDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('does not leak do-while lexical alias shadowing before declaration to outer symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'do {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  const reqAlias = () => undefined;',
      '} while (false);',
      "const postDoWhileDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('does not leak direct require symbol-source shadowing across if-branch scopes', () => {
    const source = [
      'if (true) {',
      '  const require = () => undefined;',
      "  require('./fixtures/other-module.js').default;",
      '}',
      "const postIfDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('does not leak direct require symbol-source shadowing across else-branch scopes', () => {
    const source = [
      'if (false) {',
      '  void 0;',
      '} else {',
      '  const require = () => undefined;',
      "  require('./fixtures/other-module.js').default;",
      '}',
      "const postElseDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('does not leak if-branch lexical alias shadowing before declaration to outer symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'if (true) {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  const reqAlias = () => undefined;',
      '}',
      "const postIfDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('does not leak else-branch lexical alias shadowing before declaration to outer symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'if (false) {',
      '  void 0;',
      '} else {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  const reqAlias = () => undefined;',
      '}',
      "const postElseDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('keeps if-branch type-alias declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'if (true) {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  type reqAlias = (_path: string) => unknown;',
      '}',
      "const postIfDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps else-branch type-alias declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'if (false) {',
      '  void 0;',
      '} else {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  type reqAlias = (_path: string) => unknown;',
      '}',
      "const postElseDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps if-branch interface declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'if (true) {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  interface reqAlias {',
      '    value: string;',
      '  }',
      '}',
      "const postIfDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps else-branch interface declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'if (false) {',
      '  void 0;',
      '} else {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  interface reqAlias {',
      '    value: string;',
      '  }',
      '}',
      "const postElseDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps if-branch ambient class declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'if (true) {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  declare class reqAlias {}',
      '}',
      "const postIfDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps else-branch ambient class declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'if (false) {',
      '  void 0;',
      '} else {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  declare class reqAlias {}',
      '}',
      "const postElseDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps if-branch ambient enum declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'if (true) {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  declare enum reqAlias {',
      '    Marker = 0,',
      '  }',
      '}',
      "const postIfDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps else-branch ambient enum declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'if (false) {',
      '  void 0;',
      '} else {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  declare enum reqAlias {',
      '    Marker = 0,',
      '  }',
      '}',
      "const postElseDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps if-branch ambient function declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'if (true) {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  declare function reqAlias(_path: string): unknown;',
      '}',
      "const postIfDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps else-branch ambient function declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'if (false) {',
      '  void 0;',
      '} else {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  declare function reqAlias(_path: string): unknown;',
      '}',
      "const postElseDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps if-branch ambient namespace declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'if (true) {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  declare namespace reqAlias {',
      '    const marker: unknown;',
      '  }',
      '}',
      "const postIfDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps else-branch ambient namespace declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'if (false) {',
      '  void 0;',
      '} else {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  declare namespace reqAlias {',
      '    const marker: unknown;',
      '  }',
      '}',
      "const postElseDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps if-branch ambient module declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'if (true) {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  declare module reqAlias {',
      '    const marker: unknown;',
      '  }',
      '}',
      "const postIfDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps else-branch ambient module declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'if (false) {',
      '  void 0;',
      '} else {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  declare module reqAlias {',
      '    const marker: unknown;',
      '  }',
      '}',
      "const postElseDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps if-branch ambient const declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'if (true) {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  declare const reqAlias: (_path: string) => unknown;',
      '}',
      "const postIfDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps else-branch ambient const declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'if (false) {',
      '  void 0;',
      '} else {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  declare const reqAlias: (_path: string) => unknown;',
      '}',
      "const postElseDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps if-branch ambient let declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'if (true) {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  declare let reqAlias: (_path: string) => unknown;',
      '}',
      "const postIfDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps else-branch ambient let declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'if (false) {',
      '  void 0;',
      '} else {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  declare let reqAlias: (_path: string) => unknown;',
      '}',
      "const postElseDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps if-branch ambient var declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'if (true) {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  declare var reqAlias: (_path: string) => unknown;',
      '}',
      "const postIfDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps else-branch ambient var declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'if (false) {',
      '  void 0;',
      '} else {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  declare var reqAlias: (_path: string) => unknown;',
      '}',
      "const postElseDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps if-branch var alias declarations made inside block scopes in symbol sources', () => {
    const source = [
      'if (true) {',
      '  var reqAlias = require;',
      "  reqAlias('./fixtures/guard-module.js').default;",
      '}',
      "const postIfDefault = reqAlias('./fixtures/other-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps else-branch var alias declarations made inside block scopes in symbol sources', () => {
    const source = [
      'if (false) {',
      '  void 0;',
      '} else {',
      '  var reqAlias = require;',
      "  reqAlias('./fixtures/guard-module.js').default;",
      '}',
      "const postElseDefault = reqAlias('./fixtures/other-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('clears if-branch var alias declarations to non-require values inside block scopes in symbol sources', () => {
    const source = [
      'if (true) {',
      '  var reqAlias = require;',
      "  reqAlias('./fixtures/guard-module.js').default;",
      '  reqAlias = () => undefined;',
      '}',
      "const postIfDefault = reqAlias('./fixtures/other-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('clears else-branch var alias declarations to non-require values inside block scopes in symbol sources', () => {
    const source = [
      'if (false) {',
      '  void 0;',
      '} else {',
      '  var reqAlias = require;',
      "  reqAlias('./fixtures/guard-module.js').default;",
      '  reqAlias = () => undefined;',
      '}',
      "const postElseDefault = reqAlias('./fixtures/other-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('applies if-branch assignments to outer require aliases for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (true) {',
      '  reqAlias = () => undefined;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('applies else-branch assignments to outer require aliases for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (false) {',
      '  void 0;',
      '} else {',
      '  reqAlias = () => undefined;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('applies if-branch destructuring assignments to outer require aliases for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (true) {',
      '  ({ reqAlias } = { reqAlias: () => undefined });',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('applies else-branch destructuring assignments to outer require aliases for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (false) {',
      '  void 0;',
      '} else {',
      '  ({ reqAlias } = { reqAlias: () => undefined });',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('applies if-branch require assignments to outer aliases for symbol sources', () => {
    const source = [
      'let reqAlias: any;',
      'if (true) {',
      '  reqAlias = require;',
      '}',
      "const postIfDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('applies else-branch require assignments to outer aliases for symbol sources', () => {
    const source = [
      'let reqAlias: any;',
      'if (false) {',
      '  void 0;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "const postElseDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('keeps possible branch require aliases in symbol sources for unknown if conditions', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (Math.random() > 0.5) {',
      '  reqAlias = () => undefined;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps possible then-branch require aliases in symbol sources for unknown if conditions without else', () => {
    const source = [
      'let reqAlias: any = () => undefined;',
      'if (Math.random() > 0.5) {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('treats !false conditions as true branches for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (!false) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats !true conditions as false branches for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (!true) {',
      '  reqAlias = require;',
      '} else {',
      '  reqAlias = () => undefined;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats numeric truthy conditions as true branches for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (1) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats object and array literal truthy conditions as true branches for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (({} && [])) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats nullish-coalescing literal right conditions as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'if ((null ?? {})) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats signed truthy primitive conditions as true branches for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (+true) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats signed NaN conditions as false branches for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (+undefined) {',
      '  reqAlias = require;',
      '} else {',
      '  reqAlias = () => undefined;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats empty-string falsy conditions as false branches for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      "if ('') {",
      '  reqAlias = require;',
      '} else {',
      '  reqAlias = () => undefined;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('keeps signed unknown conditions conservative for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js').default;",
      'if (+marker) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js').default;",
      'void baseline;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality void primitives as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if (((void marker) === undefined)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-inequality void primitives as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if (((void marker) !== undefined)) {',
      '  reqAlias = require;',
      '} else {',
      '  reqAlias = () => undefined;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats void conditions as false branches for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if (void marker) {',
      '  reqAlias = require;',
      '} else {',
      '  reqAlias = () => undefined;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality typeof primitives as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      "if (((typeof (1 + 2)) === 'number')) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-inequality typeof primitives as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      "if (((typeof (1 + 2)) !== 'string')) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('keeps strict-comparison typeof unknown predicates conservative for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js').default;",
      "if (((typeof marker) === 'number')) reqAlias = () => undefined;",
      "reqAlias('./fixtures/other-module.js').default;",
      'void baseline;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality typeof object literals as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      "if (((typeof ({ value: 1 })) === 'object')) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-inequality typeof function expressions as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      "if (((typeof (() => 1)) !== 'object')) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-comparison wrapped typeof predicates with matching unknown selectors as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "if (((typeof (marker === 1 ? { safe: 1 } : [])) === 'object')) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-comparison wrapped negative typeof predicates with matching unknown selectors as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "if (((typeof (marker === 1 ? (() => 1) : (class WrappedType {}))) !== 'object')) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('keeps strict-comparison wrapped typeof predicates with differing unknown selectors conservative for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js').default;",
      "if (((typeof (marker === 1 ? { safe: 1 } : (() => 1))) === 'object')) reqAlias = () => undefined;",
      "reqAlias('./fixtures/other-module.js').default;",
      'void baseline;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality delete primitives as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (((delete (1)) === true)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-inequality delete primitives as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (((delete (1)) !== false)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('keeps strict-comparison delete unknown predicates conservative for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = globalThis as any;',
      "const baseline = require('./fixtures/guard-module.js').default;",
      'if (((delete marker.value) === true)) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js').default;",
      'void baseline;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality template primitives as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      "if ((`${'safe'}-${1}` === 'safe-1')) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-inequality template primitives as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      "if ((`${'safe'}-${1}` !== 'safe-2')) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('keeps strict-comparison template unknown predicates conservative for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js').default;",
      "if ((`${marker}` === '1')) reqAlias = () => undefined;",
      "reqAlias('./fixtures/other-module.js').default;",
      'void baseline;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality in primitives as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      "if ((('safe' in { safe: 1 }) === true)) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-inequality in primitives as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      "if ((('safe' in { guard: 1 }) !== true)) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality inherited object-prototype in predicates as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      "if ((('toString' in {}) === true)) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-inequality null-prototype in predicates as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      "if ((('toString' in { __proto__: null }) !== true)) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('keeps strict-comparison unknown prototype-override predicates conservative for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = globalThis as any;',
      "const baseline = require('./fixtures/guard-module.js').default;",
      "if ((('toString' in { __proto__: marker }) === true)) reqAlias = () => undefined;",
      "reqAlias('./fixtures/other-module.js').default;",
      'void baseline;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('treats strict-comparison wrapped prototype-overrides with matching unknown selectors as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "if ((('safe' in { __proto__: marker === 1 ? { safe: 1 } : { safe: 2 } }) === true)) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('keeps strict-comparison wrapped prototype-overrides with differing unknown selectors conservative for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js').default;",
      "if ((('safe' in { __proto__: marker === 1 ? { safe: 1 } : { guard: 1 } }) === true)) reqAlias = () => undefined;",
      "reqAlias('./fixtures/other-module.js').default;",
      'void baseline;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('treats strict-comparison nullish-coalesced conditional-negation prototype-overrides as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "if ((('toString' in { __proto__: ((marker ? !left : !right) ?? (marker === 2 ? !up : !down)) }) === true)) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-comparison nullish-coalesced mixed prototype-overrides as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js').default;",
      "if ((('toString' in { __proto__: ((marker ? !left : !right) ?? (marker === 2 ? up : down)) }) === true)) reqAlias = () => undefined;",
      "reqAlias('./fixtures/other-module.js').default;",
      'void baseline;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-comparison nullish-coalesced boolean-comparison prototype-overrides as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "if ((('toString' in { __proto__: ((marker === 1) ?? { safe: 1 }) }) === true)) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('keeps strict-comparison nullish-coalesced marker prototype-overrides conservative for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = globalThis as any;',
      "const baseline = require('./fixtures/guard-module.js').default;",
      "if ((('toString' in { __proto__: (marker ?? { safe: 1 }) }) === true)) reqAlias = () => undefined;",
      "reqAlias('./fixtures/other-module.js').default;",
      'void baseline;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality inherited array-prototype in predicates as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      "if ((('map' in ['safe']) === true)) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality function-prototype in predicates as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      "if ((('call' in (() => 1)) === true)) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-inequality arrow-prototype-key in predicates as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      "if ((('prototype' in (() => 1)) !== true)) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality regexp-prototype in predicates as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      "if ((('test' in /safe/) === true)) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality class-static-member in predicates as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      "if ((('safe' in (class { static safe = 1 })) === true)) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('keeps strict-comparison class-static-block predicates conservative for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = globalThis as any;',
      "const baseline = require('./fixtures/guard-module.js').default;",
      "if ((('safe' in (class { static { if (marker) (this as any).safe = 1; } })) === true)) reqAlias = () => undefined;",
      "reqAlias('./fixtures/other-module.js').default;",
      'void baseline;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('treats strict-comparison class-static-block prototype-key predicates as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = globalThis as any;',
      "if ((('prototype' in (class { static { if (marker) (this as any).safe = 1; } })) === true)) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-comparison class-static-known-key with static-block predicates as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = globalThis as any;',
      "if ((('safe' in (class { static safe = 1; static { if (marker) (this as any).extra = 1; } })) === true)) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-comparison class-known-static with unknown-computed-static predicates as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = globalThis as any;',
      "if ((('safe' in (class { static safe = 1; static [marker] = 1; })) === true)) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('keeps strict-comparison class-unknown-computed-static predicates conservative for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = globalThis as any;',
      "const baseline = require('./fixtures/guard-module.js').default;",
      "if ((('safe' in (class { static [marker] = 1; })) === true)) reqAlias = () => undefined;",
      "reqAlias('./fixtures/other-module.js').default;",
      'void baseline;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality in array primitives as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      "if (((('0' in ['safe']) === true))) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-inequality in sparse-array primitives as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      "if (((('0' in [, 'safe']) !== true))) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality in spread-array length predicates as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const rest = globalThis as any;',
      "if (((('length' in ['safe', ...rest]) === true))) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality in spread-array pre-spread index predicates as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const rest = globalThis as any;',
      "if (((('0' in ['safe', ...rest]) === true))) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('keeps strict-comparison in spread-array post-spread predicates conservative for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const rest = globalThis as any;',
      "const baseline = require('./fixtures/guard-module.js').default;",
      "if (((('2' in ['safe', ...rest]) === true))) reqAlias = () => undefined;",
      "reqAlias('./fixtures/other-module.js').default;",
      'void baseline;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('treats wrapped in array predicates with matching unknown selectors as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "if (((('0' in (marker === 1 ? ['safe'] : ['guard'])) === true))) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats wrapped negative in array predicates with matching unknown selectors as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "if (((('0' in (marker === 1 ? [, 'safe'] : [, 'guard'])) !== true))) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('keeps strict-comparison wrapped in array predicates with differing unknown selectors conservative for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js').default;",
      "if (((('0' in (marker === 1 ? ['safe'] : [, 'safe'])) === true))) reqAlias = () => undefined;",
      "reqAlias('./fixtures/other-module.js').default;",
      'void baseline;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps strict-comparison in unknown predicates conservative for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = globalThis as any;',
      "const baseline = require('./fixtures/guard-module.js').default;",
      "if ((('safe' in marker) === true)) reqAlias = () => undefined;",
      "reqAlias('./fixtures/other-module.js').default;",
      'void baseline;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('treats wrapped in predicates with matching unknown selectors as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "if ((('safe' in (marker === 1 ? { safe: 1 } : { safe: 2 })) === true)) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats wrapped negative in predicates with matching unknown selectors as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "if ((('safe' in (marker === 1 ? { guard: 1 } : { guard: 2 })) !== true)) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('keeps wrapped in predicates with differing unknown selectors conservative for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js').default;",
      "if ((('safe' in (marker === 1 ? { safe: 1 } : { guard: 1 })) === true)) reqAlias = () => undefined;",
      "reqAlias('./fixtures/other-module.js').default;",
      'void baseline;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality instanceof primitives as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (((({}) instanceof Object) === true)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-inequality instanceof primitives as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (((({}) instanceof Array) !== true)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('keeps strict-comparison instanceof unknown predicates conservative for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = globalThis as any;',
      "const baseline = require('./fixtures/guard-module.js').default;",
      'if (((marker instanceof Object) === true)) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js').default;",
      'void baseline;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('treats strict-comparison wrapped instanceof predicates with matching unknown selectors as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if ((((marker === 1 ? {} : []) instanceof Object) === true)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-comparison wrapped instanceof predicates with matching unknown selectors as deterministic for negative cases in symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if ((((marker === 1 ? {} : {}) instanceof Array) !== true)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('keeps strict-comparison wrapped instanceof predicates with differing unknown selectors conservative for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js').default;",
      'if ((((marker === 1 ? {} : []) instanceof Array) === true)) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js').default;",
      'void baseline;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('treats relational true conditions as true branches for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (((1 + 2) > 2)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats relational false conditions as false branches for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      "if ((('ab' + 'cd') < 'aa')) {",
      '  reqAlias = require;',
      '} else {',
      '  reqAlias = () => undefined;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('keeps relational unknown conditions conservative for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js').default;",
      'if (((marker + 1) > 2)) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js').default;",
      'void baseline;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality true conditions as true branches for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (1 === 1) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality false conditions as false branches for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (1 === 2) {',
      '  reqAlias = require;',
      '} else {',
      '  reqAlias = () => undefined;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality conditional primitives with static selectors as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'if ((true ? 1 : 2) === 1) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality logical-and primitives as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if (((0 && marker) === 0)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality logical-or primitives as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if (((1 || marker) === 1)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality nullish primitives with null left values as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (((null ?? 1) === 1)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality nullish primitives with undefined left values as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (((undefined ?? 1) === 1)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality nullish primitives with non-nullish left values as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if (((2 ?? marker) === 2)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality conditional primitives with matching unknown selectors as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if ((marker === 1 ? 1 : 1) === 1) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('keeps strict-equality nullish primitives with unknown left values conservative for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js').default;",
      'if ((((marker === 1) ?? 1) === true)) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js').default;",
      'void baseline;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps strict-equality logical primitives with unknown left values conservative for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js').default;",
      'if ((((marker === 1) && 2) === 2)) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js').default;",
      'void baseline;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality logical-and false primitives with unknown-boolean left values as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if ((((marker === 1) && false) === false)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality logical-or true primitives with unknown-boolean left values as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if ((((marker === 1) || true) === true)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality logical-and false primitives with conditional-selected boolean left values as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if (((((true ? (marker === 1) : marker) && false) === false))) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality logical-or true primitives with conditional-selected boolean left values as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if (((((false ? marker : (marker === 1)) || true) === true))) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality logical-and false primitives with conditional-selected delete boolean left values as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if (((((true ? delete ({ safe: 1 }).safe : marker) && false) === false))) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality logical-or true primitives with conditional-selected delete boolean left values as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if (((((false ? marker : delete ({ safe: 1 }).safe) || true) === true))) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality direct-delete true predicates as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (((delete ({ safe: 1 }).safe) === true)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality direct-delete array-length false predicates as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (((delete ([] as any).length) === false)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality direct-delete object-element true predicates as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      "if (((delete ({ safe: 1 })['safe']) === true)) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality direct-delete array-element-length false predicates as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      "if (((delete ([] as any)['length']) === false)) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality direct-delete array-element-numeric true predicates as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (((delete ([] as any)[0]) === true)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality direct-delete array-element-template-length false predicates as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      "if (((delete ([] as any)[`len${'gth'}`]) === false)) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality direct-delete array-element-conditional-same-length predicates as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "if (((delete ([] as any)[marker === 1 ? 'length' : 'length']) === false)) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality direct-delete array-element-nullish-length predicates as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      "if (((delete ([] as any)[null ?? 'length']) === false)) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality direct-delete array-element-nullish-conditional-fallback-length predicates as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "if (((delete ([] as any)[((marker === 1 ? 'length' : undefined) ?? 'length')]) === false)) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('keeps strict-equality direct-delete array-element-nullish-conditional-mixed-fallback predicates conservative for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js').default;",
      "if (((delete ([] as any)[((marker === 1 ? 'length' : undefined) ?? 'safe')]) === false)) reqAlias = () => undefined;",
      "reqAlias('./fixtures/other-module.js').default;",
      'void baseline;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality direct-delete array-element-nullish-logical-null-fallback-length predicates as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "if (((delete ([] as any)[(((marker === 1 && 'length') || null) ?? 'length')]) === false)) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('keeps strict-equality direct-delete array-element-nullish-logical-null-mixed-fallback predicates conservative for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js').default;",
      "if (((delete ([] as any)[(((marker === 1 && 'length') || null) ?? 'safe')]) === false)) reqAlias = () => undefined;",
      "reqAlias('./fixtures/other-module.js').default;",
      'void baseline;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality direct-delete array-element-logical-same-length predicates as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "if (((delete ([] as any)[((marker === 1 && 'length') || 'length')]) === false)) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('keeps strict-equality direct-delete array-element-logical-mixed-key predicates conservative for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js').default;",
      "if (((delete ([] as any)[((marker === 1 && 'length') || 'safe')]) === false)) reqAlias = () => undefined;",
      "reqAlias('./fixtures/other-module.js').default;",
      'void baseline;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality direct-delete array-element-conditional-numeric-nonlength predicates as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if (((delete ([] as any)[marker === 1 ? 0 : 1]) === true)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality direct-delete array-element-mixed-nullish-numeric predicates as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if (((delete ([] as any)[(marker === 1 ? null : 0) ?? 1]) === true)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('keeps strict-equality direct-delete array-element-conditional-mixed-key predicates conservative for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js').default;",
      "if (((delete ([] as any)[marker === 1 ? 'length' : 'safe']) === false)) reqAlias = () => undefined;",
      "reqAlias('./fixtures/other-module.js').default;",
      'void baseline;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps strict-equality direct-delete array-element-dynamic-key predicates conservative for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js').default;",
      'if (((delete ([] as any)[marker]) === false)) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js').default;",
      'void baseline;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps strict-equality direct-delete unknown-target-element predicates conservative for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = globalThis as any;',
      "const baseline = require('./fixtures/guard-module.js').default;",
      "if (((delete marker['safe']) === true)) reqAlias = () => undefined;",
      "reqAlias('./fixtures/other-module.js').default;",
      'void baseline;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps strict-equality direct-delete unknown-target predicates conservative for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = globalThis as any;',
      "const baseline = require('./fixtures/guard-module.js').default;",
      'if (((delete marker.safe) === true)) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js').default;",
      'void baseline;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality direct-delete primitive-boolean targets as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (((delete ((false as any).safe) === true)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('keeps strict-equality direct-delete primitive-string-length targets conservative for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      "const baseline = require('./fixtures/guard-module.js').default;",
      "if (((delete (('abc' as any).length) === false)) reqAlias = () => undefined;",
      "reqAlias('./fixtures/other-module.js').default;",
      'void baseline;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality direct-delete new-date-target predicates as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (((delete ((new Date() as any).safe) === true)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality direct-delete new-regexp-target predicates as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      "if (((delete ((new RegExp('safe') as any).source) === true)) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality direct-delete new-array-element predicates as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (((delete ((new Array() as any)[0]) === true)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality direct-delete new-function-nonprototype predicates as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (((delete ((new Function() as any).safe) === true)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality direct-delete new-string-nonlength predicates as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      "if (((delete ((new String('safe') as any).tag) === true)) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('keeps strict-equality direct-delete new-array-length-target predicates conservative for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      "const baseline = require('./fixtures/guard-module.js').default;",
      'if (((delete ((new Array() as any).length) === false)) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js').default;",
      'void baseline;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps strict-equality direct-delete new-string-length-target predicates conservative for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      "const baseline = require('./fixtures/guard-module.js').default;",
      "if (((delete ((new String('safe') as any).length) === false)) reqAlias = () => undefined;",
      "reqAlias('./fixtures/other-module.js').default;",
      'void baseline;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality direct-delete conditional-known-new-constructor-target predicates as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if (((delete ((new ((marker === 1 ? Date : RegExp) as any)() as any).safe) === true)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality direct-delete globalthis-new-constructor-target predicates as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (((delete ((new ((globalThis as any).Date)() as any).safe) === true)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality direct-delete globalthis-element-new-constructor-target predicates as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      "if (((delete ((new ((globalThis as any)['Date'])() as any).safe) === true)) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality direct-delete self-element-new-constructor-target predicates as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      "if (((delete ((new ((self as any)['Date'])() as any).safe) === true)) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality direct-delete conditional-global-qualifier-new-constructor-target predicates as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if (((delete ((new (((marker === 1 ? globalThis : self) as any).Date)() as any).safe) === true)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality direct-delete nullish-global-qualifier-new-constructor-target predicates as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (((delete ((new ((((null as any) ?? globalThis) as any).Date)() as any).safe) === true)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('keeps strict-equality direct-delete conditional-mixed-new-constructor-length predicates conservative for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js').default;",
      'if (((delete ((new ((marker === 1 ? Array : Date) as any)() as any).length) === false)) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js').default;",
      'void baseline;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps strict-equality direct-delete conditional-mixed-element-new-constructor-length predicates conservative for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js').default;",
      "if (((delete ((new ((globalThis as any)[marker === 1 ? 'Array' : 'Date'])() as any).length) === false)) reqAlias = () => undefined;",
      "reqAlias('./fixtures/other-module.js').default;",
      'void baseline;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps strict-equality direct-delete conditional-mixed-global-qualifier-new-constructor-target predicates conservative for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'const fallback = {} as any;',
      "const baseline = require('./fixtures/guard-module.js').default;",
      'if (((delete ((new (((marker === 1 ? globalThis : fallback) as any).Date)() as any).safe) === true)) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js').default;",
      'void baseline;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps strict-equality direct-delete mixed-nullish-global-qualifier-new-constructor-target predicates conservative for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'const fallback = {} as any;',
      "const baseline = require('./fixtures/guard-module.js').default;",
      'if (((delete ((new ((((marker === 1 ? null : fallback) ?? globalThis) as any).Date)() as any).safe) === true)) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js').default;",
      'void baseline;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps strict-equality direct-delete new-function-prototype-target predicates conservative for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      "const baseline = require('./fixtures/guard-module.js').default;",
      'if (((delete ((new Function() as any).prototype) === false)) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js').default;",
      'void baseline;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality direct-delete regexp-target predicates as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (((delete ((/safe/ as any).source) === true)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('keeps strict-equality direct-delete mixed regexp-target predicates conservative for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'const fallback = globalThis as any;',
      "const baseline = require('./fixtures/guard-module.js').default;",
      'if (((delete ((marker === 1 ? (/safe/ as any) : fallback).source) === true)) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js').default;",
      'void baseline;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality direct-delete function-target nonprototype predicates as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (((delete (((function () {}) as any).safe) === true)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('keeps strict-equality direct-delete function-target prototype predicates conservative for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      "const baseline = require('./fixtures/guard-module.js').default;",
      'if (((delete (((function () {}) as any).prototype) === false)) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js').default;",
      'void baseline;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality direct-delete class-target nonprototype predicates as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (((delete (((class {}) as any).safe) === true)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('keeps strict-equality direct-delete class-target prototype predicates conservative for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      "const baseline = require('./fixtures/guard-module.js').default;",
      'if (((delete (((class {}) as any).prototype) === false)) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js').default;",
      'void baseline;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality direct-delete arrow-target prototype predicates as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (((delete (((() => {}) as any).prototype) === true)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality direct-delete conditional-object-target predicates as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if (((delete (marker === 1 ? { safe: 1 } : { guard: 1 }).safe) === true)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality direct-delete nullish-array-length-target predicates as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (((delete ((null ?? []) as any).length) === false)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality direct-delete logical-or object-target predicates as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (((delete (((false && (globalThis as any)) || { safe: 1 }).safe) === true)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality direct-delete logical-and array-length-target predicates as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (((delete (((true && ([] as any))).length) === false)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality direct-delete comma array-length-target predicates as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (((delete (((globalThis as any), ([] as any)).length) === false)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality direct-delete conditional-object-element-target predicates as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "if (((delete ((marker === 1 ? { safe: 1 } : { guard: 1 })['safe'])) === true)) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality direct-delete nullish-array-element-length-target predicates as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      "if (((delete (((null ?? []) as any)['length']) === false)) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality direct-delete logical-or object-element-target predicates as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      "if (((delete ((((false && (globalThis as any)) || { safe: 1 })['safe'])) === true)) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('keeps strict-equality direct-delete mixed logical-element-target predicates conservative for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'const fallback = globalThis as any;',
      "const baseline = require('./fixtures/guard-module.js').default;",
      "if (((delete (((((marker === 1) && fallback) || { safe: 1 })['safe'])) === true)) reqAlias = () => undefined;",
      "reqAlias('./fixtures/other-module.js').default;",
      'void baseline;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps strict-equality direct-delete mixed logical-target predicates conservative for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'const fallback = globalThis as any;',
      "const baseline = require('./fixtures/guard-module.js').default;",
      'if (((delete ((((marker === 1) && fallback) || { safe: 1 }).safe) === true)) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js').default;",
      'void baseline;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps strict-equality direct-delete mixed conditional-target predicates conservative for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'const fallback = globalThis as any;',
      "const baseline = require('./fixtures/guard-module.js').default;",
      'if (((delete (marker === 1 ? { safe: 1 } : fallback).safe) === true)) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js').default;",
      'void baseline;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps strict-equality logical-and false primitives with conditional-selected nonboolean left values conservative for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js').default;",
      'if (((((true ? marker : (marker === 1)) && false) === false))) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js').default;",
      'void baseline;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps strict-equality logical-or true primitives with conditional-selected nonboolean left values conservative for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js').default;",
      'if (((((false ? (marker === 1) : marker) || true) === true))) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js').default;",
      'void baseline;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality logical-and false primitives with comma-selected boolean left values as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if ((((((0, marker === 1) && false) === false)))) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality logical-or true primitives with comma-selected boolean left values as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if ((((((0, marker === 1) || true) === true)))) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('keeps strict-equality logical-and false primitives with comma-selected nonboolean left values conservative for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js').default;",
      'if ((((((0, marker) && false) === false)))) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js').default;",
      'void baseline;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps strict-equality logical-or true primitives with comma-selected nonboolean left values conservative for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js').default;",
      'if ((((((0, marker) || true) === true)))) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js').default;",
      'void baseline;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality logical-or true primitives with truthy-nonboolean-selected boolean left values as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if (((((1 && (marker === 1)) || true) === true))) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality logical-and false primitives with falsey-nonboolean-selected boolean left values as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if (((((0 || (marker === 1)) && false) === false))) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('keeps strict-equality logical-or true primitives with truthy-nonboolean-selected nonboolean left values conservative for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js').default;",
      'if (((((1 && marker) || true) === true))) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js').default;",
      'void baseline;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps strict-equality logical-and false primitives with falsey-nonboolean-selected nonboolean left values conservative for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js').default;",
      'if (((((0 || marker) && false) === false))) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js').default;",
      'void baseline;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality logical-and false primitives with nested unknown-boolean left values as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if ((((((marker === 1) && true) && false) === false))) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality logical-or true primitives with nested unknown-boolean left values as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if ((((((marker === 1) || false) || true) === true))) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality logical-and false primitives with nested nullish-boolean left values as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if ((((((marker === 1) ?? false) && false) === false))) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality logical-or true primitives with nested nullish-boolean left values as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if ((((((marker === 1) ?? false) || true) === true))) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality logical-and false primitives with null-coalesced boolean-right left values as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if (((((null ?? (marker === 1)) && false) === false))) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality logical-or true primitives with null-coalesced boolean-right left values as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if (((((null ?? (marker === 1)) || true) === true))) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality logical-and false primitives with nullish-conditional-selected boolean left values as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if (((((((marker === 1 ? null : undefined) ?? (marker === 2)) && false) === false)))) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality logical-or true primitives with nullish-conditional-selected boolean left values as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if (((((((marker === 1 ? null : undefined) ?? (marker === 2)) || true) === true)))) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality logical-and false primitives with nullish-logical-selected boolean left values as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if ((((((marker === 1 ? null : undefined) && marker) ?? true) === true))) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('keeps strict-equality logical-and false primitives with nullish-logical-selected mixed left values conservative for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js').default;",
      'if ((((((marker === 1 ? null : 0) && marker) ?? true) === true))) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js').default;",
      'void baseline;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('treats nullish-coalesced logical-or true-left predicates as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if (((marker || true) ?? false)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('keeps nullish-coalesced logical-or null-right predicates conservative for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js').default;",
      'if (((marker || null) ?? false)) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js').default;",
      'void baseline;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('treats nullish-coalesced logical-and null-right false-default predicates as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if (((marker && null) ?? false)) {',
      '  reqAlias = require;',
      '} else {',
      '  reqAlias = () => undefined;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('keeps nullish-coalesced logical-and null-right true-default predicates conservative for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js').default;",
      'if (((marker && null) ?? true)) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js').default;",
      'void baseline;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality logical-and false primitives with in-operator boolean-left values as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "if ((((('missing' in { safe: 1 }) && marker) === false))) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality logical-or true primitives with in-operator boolean-left values as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "if ((((('safe' in { safe: 1 }) || marker) === true))) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('keeps strict-equality in direct-delete right operands conservative for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      "const baseline = require('./fixtures/guard-module.js').default;",
      "if ((((('safe' in (delete ({ safe: 1 }).safe)) === false)))) reqAlias = () => undefined;",
      "reqAlias('./fixtures/other-module.js').default;",
      'void baseline;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps strict-equality in nullish-selected delete right operands conservative for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      "const baseline = require('./fixtures/guard-module.js').default;",
      "if ((((('safe' in (null ?? delete ({ safe: 1 }).safe)) === false)))) reqAlias = () => undefined;",
      "reqAlias('./fixtures/other-module.js').default;",
      'void baseline;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps strict-equality in conditional-delete right operands conservative for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js').default;",
      "if ((((('safe' in (marker === 1 ? delete ({ safe: 1 }).safe : delete ({ guard: 1 }).guard)) === false)))) reqAlias = () => undefined;",
      "reqAlias('./fixtures/other-module.js').default;",
      'void baseline;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality logical-and false primitives with instanceof boolean-left values as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if ((((({}) instanceof Array) && marker) === false)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality logical-or true primitives with instanceof boolean-left values as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if ((((({}) instanceof Object) || marker) === true)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats nullish-coalesced logical-and instanceof false-left predicates as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if ((((({}) instanceof Array) && marker) ?? true)) {',
      '  reqAlias = require;',
      '} else {',
      '  reqAlias = () => undefined;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats nullish-coalesced logical-or instanceof true-left predicates as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if ((((({}) instanceof Object) || marker) ?? false)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality instanceof conditional true-selected boolean results as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'if ((((true ? !left : marker) instanceof Object) === false)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality instanceof conditional unknown-selected boolean results as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if (((((marker === 1 ? !left : !right) instanceof Object) === false))) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality instanceof nullish-coalesced conditional-negation operands as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if ((((((marker ? !left : !right) ?? (marker === 2 ? up : down)) instanceof Object) === false))) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('keeps strict-equality instanceof conditional mixed-selected results conservative for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js').default;",
      'if (((((marker === 1 ? !left : right) instanceof Object) === false))) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js').default;",
      'void baseline;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps strict-equality instanceof nullish-coalesced mixed conditional operands conservative for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js').default;",
      'if ((((((marker ? !left : right) ?? (marker === 2 ? up : down)) instanceof Object) === false))) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js').default;",
      'void baseline;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality instanceof conditional-selected delete operands as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if (((((true ? delete ({ safe: 1 }).safe : marker) instanceof Object) === false))) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality instanceof conditional-delete unknown-selected operands as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if (((((marker === 1 ? delete ({ safe: 1 }).safe : delete ({ guard: 1 }).guard) instanceof Object) === false))) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality instanceof direct-delete operands as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'if ((((delete ({ safe: 1 }).safe) instanceof Object) === false)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality instanceof nullish-selected delete operands as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (((((null ?? delete ({ safe: 1 }).safe) instanceof Object) === false))) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('keeps strict-equality instanceof nullish-mixed delete operands conservative for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = globalThis as any;',
      "const baseline = require('./fixtures/guard-module.js').default;",
      'if (((((marker ?? delete ({ safe: 1 }).safe) instanceof Object) === false))) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js').default;",
      'void baseline;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps strict-equality instanceof conditional mixed-delete operands conservative for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js').default;",
      'if (((((marker === 1 ? delete ({ safe: 1 }).safe : marker) instanceof Object) === false))) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js').default;",
      'void baseline;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality logical-and false primitives with typeof boolean-left values as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "if ((((typeof 1 === 'string') && marker) === false)) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality logical-or true primitives with typeof boolean-left values as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "if ((((typeof 1 === 'number') || marker) === true)) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality typeof logical-and false-selected boolean results as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "if (((typeof ((marker === 1) && false)) === 'boolean')) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality typeof logical-or true-selected boolean results as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "if (((typeof ((marker === 1) || true)) === 'boolean')) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality typeof conditional true-selected boolean results as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      "if (((typeof (true ? !left : marker)) === 'boolean')) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality typeof conditional unknown-selected boolean results as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "if (((typeof (marker === 1 ? !left : !right)) === 'boolean')) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality typeof conditional-selected delete results as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      "if (((typeof (true ? delete ({ safe: 1 }).safe : marker)) === 'boolean')) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality typeof conditional-delete unknown-selected results as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "if (((typeof (marker === 1 ? delete ({ safe: 1 }).safe : delete ({ guard: 1 }).guard)) === 'boolean')) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality typeof direct-delete results as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      "if (((typeof (delete ({ safe: 1 }).safe)) === 'boolean')) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality typeof nullish-selected delete results as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      "if (((typeof ((null ?? delete ({ safe: 1 }).safe))) === 'boolean')) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('keeps strict-equality typeof nullish-mixed delete results conservative for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = globalThis as any;',
      "const baseline = require('./fixtures/guard-module.js').default;",
      "if (((typeof ((marker ?? delete ({ safe: 1 }).safe))) === 'boolean')) reqAlias = () => undefined;",
      "reqAlias('./fixtures/other-module.js').default;",
      'void baseline;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps strict-equality typeof conditional mixed-delete results conservative for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js').default;",
      "if (((typeof (marker === 1 ? delete ({ safe: 1 }).safe : right)) === 'boolean')) reqAlias = () => undefined;",
      "reqAlias('./fixtures/other-module.js').default;",
      'void baseline;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps strict-equality typeof conditional mixed-selected results conservative for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js').default;",
      "if (((typeof (marker === 1 ? !left : right)) === 'boolean')) reqAlias = () => undefined;",
      "reqAlias('./fixtures/other-module.js').default;",
      'void baseline;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps strict-equality typeof logical-and unknown-selected results conservative for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js').default;",
      "if (((typeof ((marker === 1) && marker)) === 'boolean')) reqAlias = () => undefined;",
      "reqAlias('./fixtures/other-module.js').default;",
      'void baseline;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps strict-equality typeof logical-or unknown-selected results conservative for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js').default;",
      "if (((typeof ((marker === 1) || marker)) === 'boolean')) reqAlias = () => undefined;",
      "reqAlias('./fixtures/other-module.js').default;",
      'void baseline;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality typeof nullish-coalesced conditional-negation boolean operands as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "if (((typeof (((marker ? !left : !right) ?? (marker === 2 ? !up : !down))) === 'boolean'))) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality typeof nullish-coalesced mixed conditional operands as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js').default;",
      "if (((typeof (((marker ? !left : !right) ?? (marker === 2 ? up : down))) === 'boolean'))) reqAlias = () => undefined;",
      "reqAlias('./fixtures/other-module.js').default;",
      'void baseline;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats nullish-coalesced logical-and typeof false-left predicates as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "if ((((typeof 1 === 'string') && marker) ?? true)) {",
      '  reqAlias = require;',
      '} else {',
      '  reqAlias = () => undefined;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats nullish-coalesced logical-or typeof true-left predicates as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "if ((((typeof 1 === 'number') || marker) ?? false)) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('keeps nullish-coalesced typeof-and-false predicates conservative for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if ((((typeof marker) && false) ?? true)) {',
      '  reqAlias = require;',
      '} else {',
      '  reqAlias = () => undefined;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps nullish-coalesced typeof-and-unknown predicates conservative for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js').default;",
      'if ((((typeof marker) && marker) ?? true)) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js').default;",
      'void baseline;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps strict-equality logical-and false primitives with nullish-conditional-selected nonboolean left values conservative for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js').default;",
      'if (((((((marker === 1 ? null : undefined) ?? marker) && false) === false)))) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js').default;",
      'void baseline;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps strict-equality logical-or true primitives with nullish-conditional-selected nonboolean left values conservative for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js').default;",
      'if (((((((marker === 1 ? null : undefined) ?? marker) || true) === true)))) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js').default;",
      'void baseline;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps strict-equality logical-and false primitives with null-coalesced right-nonboolean-selected left values conservative for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js').default;",
      'if (((((null ?? marker) && false) === false))) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js').default;",
      'void baseline;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps strict-equality logical-or true primitives with null-coalesced right-nonboolean-selected left values conservative for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js').default;",
      'if (((((null ?? marker) || true) === true))) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js').default;",
      'void baseline;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps strict-equality logical-and false primitives with nested nullish-nonboolean left values conservative for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js').default;",
      'if ((((marker ?? false) && false) === false)) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js').default;",
      'void baseline;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps strict-equality logical-or true primitives with nested nullish-nonboolean left values conservative for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js').default;",
      'if ((((marker ?? false) || true) === true)) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js').default;",
      'void baseline;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality logical primitives with truthy non-primitive left values as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (((({}) && 2) === 2)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-inequality logical primitives with truthy non-primitive left values as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (((({}) && 2) !== 3)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('keeps strict-comparison logical primitives with truthy non-primitive left unknown-right values conservative for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js').default;",
      'if (((({}) && marker) === 2)) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js').default;",
      'void baseline;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality non-primitive literal comparisons as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'if ((({} === 1))) {',
      '  reqAlias = require;',
      '} else {',
      '  reqAlias = () => undefined;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-inequality non-primitive literal comparisons as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'if ((({} !== 1))) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats loose-equality non-primitive nullish comparisons as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'if ((({} == null))) {',
      '  reqAlias = require;',
      '} else {',
      '  reqAlias = () => undefined;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats loose-inequality non-primitive nullish comparisons as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'if ((({} != null))) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('keeps loose-comparison mixed non-primitive unknown operands conservative for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js').default;",
      'if (((marker === 1 ? {} : marker) == null)) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js').default;",
      'void baseline;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('treats loose-equality non-primitive comparisons as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'if ((({} == []))) {',
      '  reqAlias = require;',
      '} else {',
      '  reqAlias = () => undefined;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats loose-inequality non-primitive comparisons as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'if ((({} != []))) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-inequality wrapped non-primitive comparisons with matching unknown selectors as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if (((marker === 1 ? {} : []) !== (marker === 1 ? [] : {}))) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality wrapped non-primitive comparisons with matching unknown selectors as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if (((marker === 1 ? {} : []) === (marker === 1 ? [] : {}))) {',
      '  reqAlias = require;',
      '} else {',
      '  reqAlias = () => undefined;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats loose-inequality wrapped non-primitive comparisons with matching unknown selectors as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if (((marker === 1 ? {} : []) != (marker === 1 ? [] : {}))) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats loose-equality wrapped non-primitive comparisons with matching unknown selectors as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if (((marker === 1 ? {} : []) == (marker === 1 ? [] : {}))) {',
      '  reqAlias = require;',
      '} else {',
      '  reqAlias = () => undefined;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('keeps wrapped non-primitive comparisons with differing unknown selectors conservative for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js').default;",
      'if (((marker === 1 ? {} : marker) != (marker === 1 ? [] : marker))) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js').default;",
      'void baseline;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps loose-equality wrapped non-primitive comparisons with differing unknown selectors conservative for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js').default;",
      'if (((marker === 1 ? {} : marker) == (marker === 1 ? [] : marker))) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js').default;",
      'void baseline;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality logical-or non-primitive primitives as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'if ((((0 || {}) === 1))) {',
      '  reqAlias = require;',
      '} else {',
      '  reqAlias = () => undefined;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-inequality conditional non-primitive primitives with matching unknown selectors as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if (((marker === 1 ? {} : []) !== 1)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('keeps strict-comparison conditional non-primitive primitives with differing unknown selectors conservative for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js').default;",
      'if (((marker === 1 ? {} : 1) === 1)) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js').default;",
      'void baseline;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps strict-equality conditional primitives with differing unknown selectors conservative for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js').default;",
      'if ((marker === 1 ? 1 : 2) === 1) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js').default;",
      'void baseline;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality negated primitive conditions as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'if ((!0) === true) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-inequality negated primitive conditions as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'if ((!1) !== false) {',
      '  reqAlias = require;',
      '} else {',
      '  reqAlias = () => undefined;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('keeps strict-comparison negated unknown predicates conservative for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js').default;",
      'if ((!(marker === 1)) === true) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js').default;",
      'void baseline;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('treats strict-inequality logical-and primitives as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if (((0 && marker) !== 1)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-inequality logical-or primitives as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if (((1 || marker) !== 2)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('keeps strict-inequality logical primitives with unknown left values conservative for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js').default;",
      'if ((((marker === 1) && 2) !== 1)) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js').default;",
      'void baseline;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('treats strict-inequality nullish primitives with null left values as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (((null ?? 1) !== 2)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-inequality nullish primitives with undefined left values as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (((void 0 ?? 1) !== 2)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-inequality nullish primitives with non-nullish left values as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if (((2 ?? marker) !== 1)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('keeps strict-inequality nullish primitives with unknown left values conservative for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js').default;",
      'if ((((marker === 1) ?? 1) !== 2)) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js').default;",
      'void baseline;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('treats strict-inequality conditional primitives with static selectors as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'if ((true ? 1 : 2) !== 2) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-inequality conditional primitives with matching unknown selectors as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if ((marker === 1 ? 1 : 1) !== 2) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('keeps strict-inequality conditional primitives with differing unknown selectors conservative for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js').default;",
      'if ((marker === 1 ? 1 : 2) !== 2) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js').default;",
      'void baseline;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality signed numeric primitives as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (((-1) === -1)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-inequality signed numeric primitives as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (((+1) !== 2)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality nested signed numeric primitives as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (((-(-1)) === 1)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-inequality nested signed numeric primitives as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (((+(+1)) !== 2)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality signed coercible primitives as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (((+true) === 1)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality signed string primitives as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (((+("1")) === 1)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-inequality signed coercible primitives as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (((-null) !== 1)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-inequality signed boolean primitives as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (((-(true)) !== 1)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality signed undefined NaN primitives as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (((+undefined) === 1)) {',
      '  reqAlias = require;',
      '} else {',
      '  reqAlias = () => undefined;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality signed NaN primitives as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (((+("not-a-number")) === 1)) {',
      '  reqAlias = require;',
      '} else {',
      '  reqAlias = () => undefined;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality comma primitives as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (((0, 1) === 1)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-inequality comma primitives as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (((0, 1) !== 2)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('keeps strict-comparison comma unknown-right predicates conservative for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js').default;",
      'if (((0, marker) === 1)) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js').default;",
      'void baseline;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('treats loose-equality primitives as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      "if ((('1' == 1))) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats loose-inequality primitives as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      "if ((('1' != 2))) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('keeps loose-comparison unknown operands conservative for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js').default;",
      'if (((marker == 1))) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js').default;",
      'void baseline;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality arithmetic primitives as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'if ((((1 + 2) * 3) === 9)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-inequality arithmetic primitives as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      "if (((('ab' + 'cd') !== 'xx'))) {",
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('keeps strict-comparison arithmetic unknown operands conservative for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js').default;",
      'if ((((marker + 1) === 2))) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js').default;",
      'void baseline;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality bitwise primitives as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'if ((((5 & 3) << 1) === 2)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-inequality bitwise primitives as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'if ((((5 ^ 1) >>> 1) !== 3)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('keeps strict-comparison bitwise unknown operands conservative for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js').default;",
      'if ((((marker & 1) << 1) === 2)) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js').default;",
      'void baseline;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality comparison primitives as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'if ((((1 < 2) === true))) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-inequality comparison primitives as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'if ((((2 <= 1) !== true))) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('keeps strict-comparison comparison unknown operands conservative for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js').default;",
      'if ((((marker < 2) === true))) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js').default;",
      'void baseline;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality signed bitwise-not primitives as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (((~1) === -2)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-inequality signed bitwise-not primitives as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (((~1) !== 1)) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('keeps strict-comparison signed bitwise-not unknown predicates conservative for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js').default;",
      'if (((~marker) === -2)) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js').default;",
      'void baseline;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps strict-comparison signed unknown predicates conservative for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js').default;",
      'if (((-marker) === -1)) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js').default;",
      'void baseline;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('treats strict-inequality true conditions as true branches for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (1 !== 2) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-inequality false conditions as false branches for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (1 !== 1) {',
      '  reqAlias = require;',
      '} else {',
      '  reqAlias = () => undefined;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats logical-and false conditions as false branches for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (true && false) {',
      '  reqAlias = require;',
      '} else {',
      '  reqAlias = () => undefined;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats logical-or true conditions as true branches for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (false || true) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats logical-and short-circuit false conditions as false branches for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if (marker === 1 && false) {',
      '  reqAlias = require;',
      '} else {',
      '  reqAlias = () => undefined;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats logical-or short-circuit true conditions as true branches for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if (marker === 1 || true) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('keeps logical-and true predicates unknown for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js').default;",
      'if (marker === 1 && true) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js').default;",
      'void baseline;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps logical-or false predicates unknown for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js').default;",
      'if (marker === 1 || false) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js').default;",
      'void baseline;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('treats conditional-expression true selectors as selected branches for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (true ? false : true) {',
      '  reqAlias = require;',
      '} else {',
      '  reqAlias = () => undefined;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats conditional-expression false selectors as selected branches for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (false ? false : true) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats conditional-expression unknown selectors with matching branches as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if (marker === 1 ? false : false) {',
      '  reqAlias = require;',
      '} else {',
      '  reqAlias = () => undefined;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats conditional-expression unknown selectors with matching true branches as deterministic for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      'if (marker === 1 ? true : true) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('keeps conditional-expression unknown selectors with differing branches conservative for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js').default;",
      'if (marker === 1 ? true : false) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js').default;",
      'void baseline;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps conditional-expression selected unknown branches conservative for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js').default;",
      'if (true ? marker === 1 : false) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js').default;",
      'void baseline;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('treats strict-inequality null-undefined conditions as true branches for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (null !== undefined) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality void-undefined conditions as true branches for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (void 0 === undefined) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('keeps strict-comparison identifier predicates unknown for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'const marker = Math.random();',
      "const baseline = require('./fixtures/guard-module.js').default;",
      'if (marker === 1) reqAlias = () => undefined;',
      "reqAlias('./fixtures/other-module.js').default;",
      'void baseline;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps object-literal strict-comparison predicates unknown for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      "const baseline = require('./fixtures/guard-module.js').default;",
      'if ({ marker: 1 } === { marker: 1 }) {',
      '  reqAlias = () => undefined;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      'void baseline;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps possible branch require aliases in symbol sources for unknown if-else conditions', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (Math.random() > 0.5) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = require;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('clears require aliases in symbol sources when all unknown if branches overwrite to non-require values', () => {
    const source = [
      'let reqAlias: any = require;',
      'if (Math.random() > 0.5) {',
      '  reqAlias = () => undefined;',
      '} else {',
      '  reqAlias = () => undefined;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('does not leak hoisted if-branch function alias shadowing to outer symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'if (true) {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  function reqAlias(_value: unknown) {',
      '    return _value;',
      '  }',
      '}',
      "const postIfDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('does not leak hoisted else-branch function alias shadowing to outer symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'if (false) {',
      '  void 0;',
      '} else {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  function reqAlias(_value: unknown) {',
      '    return _value;',
      '  }',
      '}',
      "const postElseDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('does not leak if-branch class alias shadowing before declaration to outer symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'if (true) {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  class reqAlias {}',
      '}',
      "const postIfDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('does not leak else-branch class alias shadowing before declaration to outer symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'if (false) {',
      '  void 0;',
      '} else {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  class reqAlias {}',
      '}',
      "const postElseDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('does not leak if-branch enum alias shadowing before declaration to outer symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'if (true) {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  enum reqAlias {',
      '    Marker = 0,',
      '  }',
      '}',
      "const postIfDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('does not leak else-branch enum alias shadowing before declaration to outer symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'if (false) {',
      '  void 0;',
      '} else {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  enum reqAlias {',
      '    Marker = 0,',
      '  }',
      '}',
      "const postElseDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('does not leak if-branch class alias declarations to outer symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'if (true) {',
      '  class reqAlias {}',
      "  reqAlias('./fixtures/other-module.js').default;",
      '}',
      "const postIfDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('does not leak else-branch class alias declarations to outer symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'if (false) {',
      '  void 0;',
      '} else {',
      '  class reqAlias {}',
      "  reqAlias('./fixtures/other-module.js').default;",
      '}',
      "const postElseDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('does not leak if-branch function alias declarations to outer symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'if (true) {',
      '  function reqAlias(_value: unknown) {',
      '    return _value;',
      '  }',
      "  reqAlias('./fixtures/other-module.js').default;",
      '}',
      "const postIfDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('does not leak else-branch function alias declarations to outer symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'if (false) {',
      '  void 0;',
      '} else {',
      '  function reqAlias(_value: unknown) {',
      '    return _value;',
      '  }',
      "  reqAlias('./fixtures/other-module.js').default;",
      '}',
      "const postElseDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('does not leak if-branch enum alias declarations to outer symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'if (true) {',
      '  enum reqAlias {',
      '    Marker = 0,',
      '  }',
      "  reqAlias('./fixtures/other-module.js').default;",
      '}',
      "const postIfDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('does not leak else-branch enum alias declarations to outer symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'if (false) {',
      '  void 0;',
      '} else {',
      '  enum reqAlias {',
      '    Marker = 0,',
      '  }',
      "  reqAlias('./fixtures/other-module.js').default;",
      '}',
      "const postElseDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('does not leak hoisted while-block function alias shadowing to outer symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'while (true) {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  function reqAlias(_value: unknown) {',
      '    return _value;',
      '  }',
      '  break;',
      '}',
      "const postWhileDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('does not leak hoisted do-while function alias shadowing to outer symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'do {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  function reqAlias(_value: unknown) {',
      '    return _value;',
      '  }',
      '} while (false);',
      "const postDoWhileDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('does not leak while-block class alias shadowing before declaration to outer symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'while (true) {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  class reqAlias {}',
      '  break;',
      '}',
      "const postWhileDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('does not leak do-while class alias shadowing before declaration to outer symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'do {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  class reqAlias {}',
      '} while (false);',
      "const postDoWhileDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('does not leak while-block class alias declarations to outer symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'while (true) {',
      '  class reqAlias {}',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  break;',
      '}',
      "const postWhileDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('does not leak do-while class alias declarations to outer symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'do {',
      '  class reqAlias {}',
      "  reqAlias('./fixtures/other-module.js').default;",
      '} while (false);',
      "const postDoWhileDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('does not leak while-block function alias declarations to outer symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'while (true) {',
      '  function reqAlias(_value: unknown) {',
      '    return _value;',
      '  }',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  break;',
      '}',
      "const postWhileDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('does not leak do-while function alias declarations to outer symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'do {',
      '  function reqAlias(_value: unknown) {',
      '    return _value;',
      '  }',
      "  reqAlias('./fixtures/other-module.js').default;",
      '} while (false);',
      "const postDoWhileDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('does not leak while-block enum alias shadowing before declaration to outer symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'while (true) {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  enum reqAlias {',
      '    Marker = 0,',
      '  }',
      '  break;',
      '}',
      "const postWhileDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('does not leak do-while enum alias shadowing before declaration to outer symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'do {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  enum reqAlias {',
      '    Marker = 0,',
      '  }',
      '} while (false);',
      "const postDoWhileDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('does not leak while-block enum alias declarations to outer symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'while (true) {',
      '  enum reqAlias {',
      '    Marker = 0,',
      '  }',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  break;',
      '}',
      "const postWhileDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('does not leak do-while enum alias declarations to outer symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'do {',
      '  enum reqAlias {',
      '    Marker = 0,',
      '  }',
      "  reqAlias('./fixtures/other-module.js').default;",
      '} while (false);',
      "const postDoWhileDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('does not leak lexical for-loop enum alias shadowing before declaration to outer symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'for (const iteration of [1]) {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  enum reqAlias {',
      '    Marker = 0,',
      '  }',
      '  void iteration;',
      '}',
      "const postLoopDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('does not leak lexical for-loop enum alias declarations to outer symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'for (const iteration of [1]) {',
      '  enum reqAlias {',
      '    Marker = 0,',
      '  }',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  void iteration;',
      '}',
      "const postLoopDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('does not leak lexical for-loop class alias shadowing before declaration to outer symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'for (const iteration of [1]) {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  class reqAlias {}',
      '  void iteration;',
      '}',
      "const postLoopDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('does not leak lexical for-loop class alias declarations to outer symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'for (const iteration of [1]) {',
      '  class reqAlias {}',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  void iteration;',
      '}',
      "const postLoopDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('keeps lexical for-loop type-alias declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'for (const iteration of [1]) {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  type moduleAlias = { inner: unknown };',
      '  void preDeclarationSymbol;',
      '  void iteration;',
      '}',
      'const postLoopDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps lexical for-loop interface declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'for (const iteration of [1]) {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  interface moduleAlias {',
      '    inner: unknown;',
      '  }',
      '  void preDeclarationSymbol;',
      '  void iteration;',
      '}',
      'const postLoopDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps lexical for-loop ambient class declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'for (const iteration of [1]) {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  declare class moduleAlias {}',
      '  void preDeclarationSymbol;',
      '  void iteration;',
      '}',
      'const postLoopDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps lexical for-loop ambient enum declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'for (const iteration of [1]) {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  declare enum moduleAlias {',
      '    Marker = 0,',
      '  }',
      '  void preDeclarationSymbol;',
      '  void iteration;',
      '}',
      'const postLoopDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps lexical for-loop ambient function declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'for (const iteration of [1]) {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  declare function moduleAlias(_path: string): unknown;',
      '  void preDeclarationSymbol;',
      '  void iteration;',
      '}',
      'const postLoopDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps lexical for-loop ambient namespace declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'for (const iteration of [1]) {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  declare namespace moduleAlias {',
      '    const marker: unknown;',
      '  }',
      '  void preDeclarationSymbol;',
      '  void iteration;',
      '}',
      'const postLoopDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps lexical for-loop ambient module declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'for (const iteration of [1]) {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  declare module moduleAlias {',
      '    const marker: unknown;',
      '  }',
      '  void preDeclarationSymbol;',
      '  void iteration;',
      '}',
      'const postLoopDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps lexical for-loop ambient const declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'for (const iteration of [1]) {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  declare const moduleAlias: { inner: unknown };',
      '  void preDeclarationSymbol;',
      '  void iteration;',
      '}',
      'const postLoopDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps lexical for-loop ambient let declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'for (const iteration of [1]) {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  declare let moduleAlias: { inner: unknown };',
      '  void preDeclarationSymbol;',
      '  void iteration;',
      '}',
      'const postLoopDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps lexical for-loop ambient var declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'for (const iteration of [1]) {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  declare var moduleAlias: { inner: unknown };',
      '  void preDeclarationSymbol;',
      '  void iteration;',
      '}',
      'const postLoopDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps while-block type-alias declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'while (true) {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  type moduleAlias = { inner: unknown };',
      '  void preDeclarationSymbol;',
      '  break;',
      '}',
      'const postWhileDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps while-block interface declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'while (true) {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  interface moduleAlias {',
      '    inner: unknown;',
      '  }',
      '  void preDeclarationSymbol;',
      '  break;',
      '}',
      'const postWhileDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps while-block ambient class declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'while (true) {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  declare class moduleAlias {}',
      '  void preDeclarationSymbol;',
      '  break;',
      '}',
      'const postWhileDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps while-block ambient enum declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'while (true) {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  declare enum moduleAlias {',
      '    Marker = 0,',
      '  }',
      '  void preDeclarationSymbol;',
      '  break;',
      '}',
      'const postWhileDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps while-block ambient function declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'while (true) {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  declare function moduleAlias(_path: string): unknown;',
      '  void preDeclarationSymbol;',
      '  break;',
      '}',
      'const postWhileDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps while-block ambient namespace declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'while (true) {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  declare namespace moduleAlias {',
      '    const marker: unknown;',
      '  }',
      '  void preDeclarationSymbol;',
      '  break;',
      '}',
      'const postWhileDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps while-block ambient module declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'while (true) {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  declare module moduleAlias {',
      '    const marker: unknown;',
      '  }',
      '  void preDeclarationSymbol;',
      '  break;',
      '}',
      'const postWhileDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps while-block ambient const declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'while (true) {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  declare const moduleAlias: { inner: unknown };',
      '  void preDeclarationSymbol;',
      '  break;',
      '}',
      'const postWhileDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps while-block ambient let declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'while (true) {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  declare let moduleAlias: { inner: unknown };',
      '  void preDeclarationSymbol;',
      '  break;',
      '}',
      'const postWhileDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps while-block ambient var declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'while (true) {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  declare var moduleAlias: { inner: unknown };',
      '  void preDeclarationSymbol;',
      '  break;',
      '}',
      'const postWhileDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps do-while type-alias declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'do {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  type moduleAlias = { inner: unknown };',
      '  void preDeclarationSymbol;',
      '} while (false);',
      'const postDoWhileDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps do-while interface declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'do {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  interface moduleAlias {',
      '    inner: unknown;',
      '  }',
      '  void preDeclarationSymbol;',
      '} while (false);',
      'const postDoWhileDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps do-while ambient class declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'do {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  declare class moduleAlias {}',
      '  void preDeclarationSymbol;',
      '} while (false);',
      'const postDoWhileDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps do-while ambient enum declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'do {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  declare enum moduleAlias {',
      '    Marker = 0,',
      '  }',
      '  void preDeclarationSymbol;',
      '} while (false);',
      'const postDoWhileDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps do-while ambient function declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'do {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  declare function moduleAlias(_path: string): unknown;',
      '  void preDeclarationSymbol;',
      '} while (false);',
      'const postDoWhileDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps do-while ambient namespace declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'do {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  declare namespace moduleAlias {',
      '    const marker: unknown;',
      '  }',
      '  void preDeclarationSymbol;',
      '} while (false);',
      'const postDoWhileDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps do-while ambient module declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'do {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  declare module moduleAlias {',
      '    const marker: unknown;',
      '  }',
      '  void preDeclarationSymbol;',
      '} while (false);',
      'const postDoWhileDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps do-while ambient const declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'do {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  declare const moduleAlias: { inner: unknown };',
      '  void preDeclarationSymbol;',
      '} while (false);',
      'const postDoWhileDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps do-while ambient let declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'do {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  declare let moduleAlias: { inner: unknown };',
      '  void preDeclarationSymbol;',
      '} while (false);',
      'const postDoWhileDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps do-while ambient var declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'do {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  declare var moduleAlias: { inner: unknown };',
      '  void preDeclarationSymbol;',
      '} while (false);',
      'const postDoWhileDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('does not leak while-block lexical module-source alias shadowing before declaration to outer symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'while (true) {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  const moduleAlias = { inner: preDeclarationSymbol };',
      '  void moduleAlias;',
      '  break;',
      '}',
      'const postWhileDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('inner@./fixtures/guard-module.js');
  });

  it('does not leak do-while lexical module-source alias shadowing before declaration to outer symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'do {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  const moduleAlias = { inner: preDeclarationSymbol };',
      '  void moduleAlias;',
      '} while (false);',
      'const postDoWhileDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('inner@./fixtures/guard-module.js');
  });

  it('does not leak while-block class module-source alias shadowing before declaration to outer symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'while (true) {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  class moduleAlias {}',
      '  void preDeclarationSymbol;',
      '  break;',
      '}',
      'const postWhileDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('inner@./fixtures/guard-module.js');
  });

  it('does not leak do-while class module-source alias shadowing before declaration to outer symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'do {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  class moduleAlias {}',
      '  void preDeclarationSymbol;',
      '} while (false);',
      'const postDoWhileDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('inner@./fixtures/guard-module.js');
  });

  it('does not leak if-branch lexical module-source alias shadowing before declaration to outer symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if (true) {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  const moduleAlias = { inner: preDeclarationSymbol };',
      '  void moduleAlias;',
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('inner@./fixtures/guard-module.js');
  });

  it('does not leak else-branch lexical module-source alias shadowing before declaration to outer symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if (false) {',
      '  void 0;',
      '} else {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  const moduleAlias = { inner: preDeclarationSymbol };',
      '  void moduleAlias;',
      '}',
      'const postElseDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('inner@./fixtures/guard-module.js');
  });

  it('keeps if-branch type-alias declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if (true) {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  type moduleAlias = { inner: unknown };',
      '  void preDeclarationSymbol;',
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps else-branch type-alias declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if (false) {',
      '  void 0;',
      '} else {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  type moduleAlias = { inner: unknown };',
      '  void preDeclarationSymbol;',
      '}',
      'const postElseDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps if-branch interface declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if (true) {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  interface moduleAlias {',
      '    inner: unknown;',
      '  }',
      '  void preDeclarationSymbol;',
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps else-branch interface declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if (false) {',
      '  void 0;',
      '} else {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  interface moduleAlias {',
      '    inner: unknown;',
      '  }',
      '  void preDeclarationSymbol;',
      '}',
      'const postElseDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps if-branch ambient class declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if (true) {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  declare class moduleAlias {}',
      '  void preDeclarationSymbol;',
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps else-branch ambient class declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if (false) {',
      '  void 0;',
      '} else {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  declare class moduleAlias {}',
      '  void preDeclarationSymbol;',
      '}',
      'const postElseDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps if-branch ambient enum declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if (true) {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  declare enum moduleAlias {',
      '    Marker = 0,',
      '  }',
      '  void preDeclarationSymbol;',
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps else-branch ambient enum declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if (false) {',
      '  void 0;',
      '} else {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  declare enum moduleAlias {',
      '    Marker = 0,',
      '  }',
      '  void preDeclarationSymbol;',
      '}',
      'const postElseDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps if-branch ambient function declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if (true) {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  declare function moduleAlias(_path: string): unknown;',
      '  void preDeclarationSymbol;',
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps else-branch ambient function declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if (false) {',
      '  void 0;',
      '} else {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  declare function moduleAlias(_path: string): unknown;',
      '  void preDeclarationSymbol;',
      '}',
      'const postElseDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps if-branch ambient namespace declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if (true) {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  declare namespace moduleAlias {',
      '    const marker: unknown;',
      '  }',
      '  void preDeclarationSymbol;',
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps else-branch ambient namespace declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if (false) {',
      '  void 0;',
      '} else {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  declare namespace moduleAlias {',
      '    const marker: unknown;',
      '  }',
      '  void preDeclarationSymbol;',
      '}',
      'const postElseDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps if-branch ambient module declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if (true) {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  declare module moduleAlias {',
      '    const marker: unknown;',
      '  }',
      '  void preDeclarationSymbol;',
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps else-branch ambient module declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if (false) {',
      '  void 0;',
      '} else {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  declare module moduleAlias {',
      '    const marker: unknown;',
      '  }',
      '  void preDeclarationSymbol;',
      '}',
      'const postElseDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps if-branch ambient const declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if (true) {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  declare const moduleAlias: { inner: unknown };',
      '  void preDeclarationSymbol;',
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps else-branch ambient const declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if (false) {',
      '  void 0;',
      '} else {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  declare const moduleAlias: { inner: unknown };',
      '  void preDeclarationSymbol;',
      '}',
      'const postElseDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps if-branch ambient let declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if (true) {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  declare let moduleAlias: { inner: unknown };',
      '  void preDeclarationSymbol;',
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps else-branch ambient let declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if (false) {',
      '  void 0;',
      '} else {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  declare let moduleAlias: { inner: unknown };',
      '  void preDeclarationSymbol;',
      '}',
      'const postElseDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps if-branch ambient var declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if (true) {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  declare var moduleAlias: { inner: unknown };',
      '  void preDeclarationSymbol;',
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps else-branch ambient var declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if (false) {',
      '  void 0;',
      '} else {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  declare var moduleAlias: { inner: unknown };',
      '  void preDeclarationSymbol;',
      '}',
      'const postElseDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps if-branch var module-source alias declarations made inside block scopes', () => {
    const source = [
      'if (true) {',
      "  var moduleAlias: any = require('./fixtures/guard-module.js');",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('keeps else-branch var module-source alias declarations made inside block scopes', () => {
    const source = [
      'if (false) {',
      '  void 0;',
      '} else {',
      "  var moduleAlias: any = require('./fixtures/guard-module.js');",
      '}',
      'const postElseDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('clears if-branch var module-source alias declarations to non-module values inside block scopes', () => {
    const source = [
      "const fallbackDefault = require('./fixtures/other-module.js').default;",
      'if (true) {',
      "  var moduleAlias: any = require('./fixtures/guard-module.js');",
      '  moduleAlias = { default: fallbackDefault };',
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('clears else-branch var module-source alias declarations to non-module values inside block scopes', () => {
    const source = [
      "const fallbackDefault = require('./fixtures/other-module.js').default;",
      'if (false) {',
      '  void 0;',
      '} else {',
      "  var moduleAlias: any = require('./fixtures/guard-module.js');",
      '  moduleAlias = { default: fallbackDefault };',
      '}',
      'const postElseDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('applies if-branch assignments to outer module-source aliases for symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      "const fallbackDefault = require('./fixtures/other-module.js').default;",
      'if (true) {',
      '  moduleAlias = { default: fallbackDefault };',
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('applies else-branch assignments to outer module-source aliases for symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      "const fallbackDefault = require('./fixtures/other-module.js').default;",
      'if (false) {',
      '  void 0;',
      '} else {',
      '  moduleAlias = { default: fallbackDefault };',
      '}',
      'const postElseDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('applies if-branch destructuring assignments to outer module-source aliases for symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      "const fallbackDefault = require('./fixtures/other-module.js').default;",
      'if (true) {',
      '  ({ moduleAlias } = { moduleAlias: { default: fallbackDefault } });',
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('applies else-branch destructuring assignments to outer module-source aliases for symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      "const fallbackDefault = require('./fixtures/other-module.js').default;",
      'if (false) {',
      '  void 0;',
      '} else {',
      '  ({ moduleAlias } = { moduleAlias: { default: fallbackDefault } });',
      '}',
      'const postElseDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('applies if-branch require assignments to outer module-source aliases for symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if (true) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('applies else-branch require assignments to outer module-source aliases for symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if (false) {',
      '  void 0;',
      '} else {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '}',
      'const postElseDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('keeps possible branch module-source aliases in symbol sources for unknown if conditions', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if (Math.random() > 0.5) {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('keeps possible then-branch module-source aliases in symbol sources for unknown if conditions without else', () => {
    const source = [
      "let moduleAlias: any = { default: 'not-a-module' };",
      'if (Math.random() > 0.5) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '}',
      'const postIfDefault = moduleAlias.default;',
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('treats !false conditions as true branches for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if (!false) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats !true conditions as false branches for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if (!true) {',
      "  moduleAlias = { default: 'not-a-module' };",
      '} else {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats numeric truthy conditions as true branches for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if (1) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats object and array literal truthy conditions as true branches for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if (({} && [])) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats nullish-coalescing literal right conditions as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if ((null ?? {})) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats signed truthy primitive conditions as true branches for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if (+true) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats signed NaN conditions as false branches for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if (+undefined) {',
      "  moduleAlias = { default: 'not-a-module' };",
      '} else {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats empty-string falsy conditions as false branches for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      "if ('') {",
      "  moduleAlias = { default: 'not-a-module' };",
      '} else {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('keeps signed unknown conditions conservative for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      "if (+marker) moduleAlias = { default: 'not-a-module' };",
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality void primitives as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      'if (((void marker) === undefined)) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-inequality void primitives as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      'if (((void marker) !== 0)) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats void conditions as false branches for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      'if (void marker) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = require('./fixtures/guard-module.js');",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality typeof primitives as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      "if (((typeof (1 + 2)) === 'number')) {",
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-inequality typeof primitives as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      "if (((typeof (1 + 2)) !== 'string')) {",
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('keeps strict-comparison typeof unknown predicates conservative for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      "if (((typeof marker) === 'number')) moduleAlias = { default: 'not-a-module' };",
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality typeof object literals as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      "if (((typeof ({ value: 1 })) === 'object')) {",
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-inequality typeof function expressions as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      "if (((typeof (() => 1)) !== 'object')) {",
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-comparison wrapped typeof predicates with matching unknown selectors as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      "if (((typeof (marker === 1 ? { safe: 1 } : [])) === 'object')) {",
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-comparison wrapped negative typeof predicates with matching unknown selectors as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      "if (((typeof (marker === 1 ? (() => 1) : (class WrappedType {}))) !== 'object')) {",
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('keeps strict-comparison wrapped typeof predicates with differing unknown selectors conservative for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      "if (((typeof (marker === 1 ? { safe: 1 } : (() => 1))) === 'object')) moduleAlias = { default: 'not-a-module' };",
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality delete primitives as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if (((delete (1)) === true)) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-inequality delete primitives as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if (((delete (1)) !== false)) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('keeps strict-comparison delete unknown predicates conservative for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = globalThis as any;',
      "if (((delete marker.value) === true)) moduleAlias = { default: 'not-a-module' };",
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality template primitives as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      "if ((`${'safe'}-${1}` === 'safe-1')) {",
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-inequality template primitives as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      "if ((`${'safe'}-${1}` !== 'safe-2')) {",
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('keeps strict-comparison template unknown predicates conservative for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      "if ((`${marker}` === '1')) moduleAlias = { default: 'not-a-module' };",
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality in primitives as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      "if ((('safe' in { safe: 1 }) === true)) {",
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-inequality in primitives as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      "if ((('safe' in { guard: 1 }) !== true)) {",
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality inherited object-prototype in predicates as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      "if ((('toString' in {}) === true)) {",
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-inequality null-prototype in predicates as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      "if ((('toString' in { __proto__: null }) !== true)) {",
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('keeps strict-comparison unknown prototype-override predicates conservative for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = globalThis as any;',
      "if ((('toString' in { __proto__: marker }) === true)) moduleAlias = { default: 'not-a-module' };",
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-comparison wrapped prototype-overrides with matching unknown selectors as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      "if ((('safe' in { __proto__: marker === 1 ? { safe: 1 } : { safe: 2 } }) === true)) {",
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('keeps strict-comparison wrapped prototype-overrides with differing unknown selectors conservative for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      "if ((('safe' in { __proto__: marker === 1 ? { safe: 1 } : { guard: 1 } }) === true)) moduleAlias = { default: 'not-a-module' };",
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-comparison nullish-coalesced conditional-negation prototype-overrides as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      "if ((('toString' in { __proto__: ((marker ? !left : !right) ?? (marker === 2 ? !up : !down)) }) === true)) {",
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-comparison nullish-coalesced mixed prototype-overrides as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      "if ((('toString' in { __proto__: ((marker ? !left : !right) ?? (marker === 2 ? up : down)) }) === true)) moduleAlias = { default: 'not-a-module' };",
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.have.length(0);
  });

  it('treats strict-comparison nullish-coalesced boolean-comparison prototype-overrides as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      "if ((('toString' in { __proto__: ((marker === 1) ?? { safe: 1 }) }) === true)) {",
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('keeps strict-comparison nullish-coalesced marker prototype-overrides conservative for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = globalThis as any;',
      "if ((('toString' in { __proto__: (marker ?? { safe: 1 }) }) === true)) moduleAlias = { default: 'not-a-module' };",
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality inherited array-prototype in predicates as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      "if ((('map' in ['safe']) === true)) {",
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality function-prototype in predicates as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      "if ((('call' in (() => 1)) === true)) {",
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-inequality arrow-prototype-key in predicates as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      "if ((('prototype' in (() => 1)) !== true)) {",
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality regexp-prototype in predicates as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      "if ((('test' in /safe/) === true)) {",
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality class-static-member in predicates as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      "if ((('safe' in (class { static safe = 1 })) === true)) {",
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('keeps strict-comparison class-static-block predicates conservative for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = globalThis as any;',
      "if ((('safe' in (class { static { if (marker) (this as any).safe = 1; } })) === true)) moduleAlias = { default: 'not-a-module' };",
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-comparison class-static-block prototype-key predicates as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = globalThis as any;',
      "if ((('prototype' in (class { static { if (marker) (this as any).safe = 1; } })) === true)) {",
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-comparison class-static-known-key with static-block predicates as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = globalThis as any;',
      "if ((('safe' in (class { static safe = 1; static { if (marker) (this as any).extra = 1; } })) === true)) {",
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-comparison class-known-static with unknown-computed-static predicates as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = globalThis as any;',
      "if ((('safe' in (class { static safe = 1; static [marker] = 1; })) === true)) {",
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('keeps strict-comparison class-unknown-computed-static predicates conservative for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = globalThis as any;',
      "if ((('safe' in (class { static [marker] = 1; })) === true)) moduleAlias = { default: 'not-a-module' };",
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality in array primitives as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      "if (((('0' in ['safe']) === true))) {",
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-inequality in sparse-array primitives as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      "if (((('0' in [, 'safe']) !== true))) {",
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality in spread-array length predicates as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const rest = globalThis as any;',
      "if (((('length' in ['safe', ...rest]) === true))) {",
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality in spread-array pre-spread index predicates as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const rest = globalThis as any;',
      "if (((('0' in ['safe', ...rest]) === true))) {",
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('keeps strict-comparison in spread-array post-spread predicates conservative for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const rest = globalThis as any;',
      "if (((('2' in ['safe', ...rest]) === true))) moduleAlias = { default: 'not-a-module' };",
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('treats wrapped in array predicates with matching unknown selectors as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      "if (((('0' in (marker === 1 ? ['safe'] : ['guard'])) === true))) {",
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats wrapped negative in array predicates with matching unknown selectors as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      "if (((('0' in (marker === 1 ? [, 'safe'] : [, 'guard'])) !== true))) {",
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('keeps strict-comparison wrapped in array predicates with differing unknown selectors conservative for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      "if (((('0' in (marker === 1 ? ['safe'] : [, 'safe'])) === true))) moduleAlias = { default: 'not-a-module' };",
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('keeps strict-comparison in unknown predicates conservative for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = globalThis as any;',
      "if ((('safe' in marker) === true)) moduleAlias = { default: 'not-a-module' };",
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('treats wrapped in predicates with matching unknown selectors as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      "if ((('safe' in (marker === 1 ? { safe: 1 } : { safe: 2 })) === true)) {",
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats wrapped negative in predicates with matching unknown selectors as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      "if ((('safe' in (marker === 1 ? { guard: 1 } : { guard: 2 })) !== true)) {",
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('keeps wrapped in predicates with differing unknown selectors conservative for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      "if ((('safe' in (marker === 1 ? { safe: 1 } : { guard: 1 })) === true)) moduleAlias = { default: 'not-a-module' };",
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality instanceof primitives as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if ((([] instanceof Array) === true)) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-inequality instanceof primitives as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if ((([] instanceof Function) !== true)) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('keeps strict-comparison instanceof unknown predicates conservative for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = globalThis as any;',
      "if (((marker instanceof Object) === true)) moduleAlias = { default: 'not-a-module' };",
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-comparison wrapped instanceof predicates with matching unknown selectors as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      'if ((((marker === 1 ? {} : []) instanceof Object) === true)) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-comparison wrapped instanceof predicates with matching unknown selectors as deterministic for negative cases in module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      'if ((((marker === 1 ? {} : {}) instanceof Array) !== true)) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('keeps strict-comparison wrapped instanceof predicates with differing unknown selectors conservative for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      "if ((((marker === 1 ? {} : []) instanceof Array) === true)) moduleAlias = { default: 'not-a-module' };",
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('treats relational true conditions as true branches for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if (((1 + 2) > 2)) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats relational false conditions as false branches for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      "if ((('ab' + 'cd') < 'aa')) {",
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = require('./fixtures/guard-module.js');",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.not.include('default@./fixtures/other-module.js');
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('keeps relational unknown conditions conservative for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      "if (((marker + 1) > 2)) moduleAlias = { default: 'not-a-module' };",
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality true conditions as true branches for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if (1 === 1) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality false conditions as false branches for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if (1 === 2) {',
      "  moduleAlias = { default: 'not-a-module' };",
      '} else {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality conditional primitives with static selectors as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if ((true ? 1 : 2) === 1) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality logical-and primitives as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      'if (((0 && marker) === 0)) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality logical-or primitives as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      'if (((1 || marker) === 1)) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality nullish primitives with null left values as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if (((null ?? 1) === 1)) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality nullish primitives with undefined left values as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if (((undefined ?? 1) === 1)) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality nullish primitives with non-nullish left values as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      'if (((2 ?? marker) === 2)) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality conditional primitives with matching unknown selectors as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      'if ((marker === 1 ? 1 : 1) === 1) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('keeps strict-equality nullish primitives with unknown left values conservative for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      "if ((((marker === 1) ?? 1) === true)) moduleAlias = { default: 'not-a-module' };",
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('keeps strict-equality conditional primitives with differing unknown selectors conservative for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      "if ((marker === 1 ? 1 : 2) === 1) moduleAlias = { default: 'not-a-module' };",
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('keeps strict-equality logical primitives with unknown left values conservative for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      "if ((((marker === 1) && 2) === 2)) moduleAlias = { default: 'not-a-module' };",
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality logical-and false primitives with unknown-boolean left values as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      'if ((((marker === 1) && false) === false)) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality logical-or true primitives with unknown-boolean left values as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      'if ((((marker === 1) || true) === true)) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality logical-and false primitives with conditional-selected boolean left values as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      'if (((((true ? (marker === 1) : marker) && false) === false))) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality logical-or true primitives with conditional-selected boolean left values as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      'if (((((false ? marker : (marker === 1)) || true) === true))) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality logical-and false primitives with conditional-selected delete boolean left values as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      'if (((((true ? delete ({ safe: 1 }).safe : marker) && false) === false))) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality logical-or true primitives with conditional-selected delete boolean left values as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      'if (((((false ? marker : delete ({ safe: 1 }).safe) || true) === true))) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality direct-delete true predicates as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if (((delete ({ safe: 1 }).safe) === true)) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality direct-delete array-length false predicates as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if (((delete ([] as any).length) === false)) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality direct-delete object-element true predicates as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      "if (((delete ({ safe: 1 })['safe']) === true)) {",
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality direct-delete array-element-length false predicates as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      "if (((delete ([] as any)['length']) === false)) {",
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality direct-delete array-element-numeric true predicates as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if (((delete ([] as any)[0]) === true)) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality direct-delete array-element-template-length false predicates as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      "if (((delete ([] as any)[`len${'gth'}`]) === false)) {",
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality direct-delete array-element-conditional-same-length predicates as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      "if (((delete ([] as any)[marker === 1 ? 'length' : 'length']) === false)) {",
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality direct-delete array-element-nullish-length predicates as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      "if (((delete ([] as any)[null ?? 'length']) === false)) {",
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality direct-delete array-element-nullish-conditional-fallback-length predicates as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      "if (((delete ([] as any)[((marker === 1 ? 'length' : undefined) ?? 'length')]) === false)) {",
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('keeps strict-equality direct-delete array-element-nullish-conditional-mixed-fallback predicates conservative for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      "if (((delete ([] as any)[((marker === 1 ? 'length' : undefined) ?? 'safe')]) === false)) moduleAlias = { default: 'not-a-module' };",
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality direct-delete array-element-nullish-logical-null-fallback-length predicates as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      "if (((delete ([] as any)[(((marker === 1 && 'length') || null) ?? 'length')]) === false)) {",
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('keeps strict-equality direct-delete array-element-nullish-logical-null-mixed-fallback predicates conservative for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      "if (((delete ([] as any)[(((marker === 1 && 'length') || null) ?? 'safe')]) === false)) moduleAlias = { default: 'not-a-module' };",
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality direct-delete array-element-logical-same-length predicates as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      "if (((delete ([] as any)[((marker === 1 && 'length') || 'length')]) === false)) {",
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('keeps strict-equality direct-delete array-element-logical-mixed-key predicates conservative for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      "if (((delete ([] as any)[((marker === 1 && 'length') || 'safe')]) === false)) moduleAlias = { default: 'not-a-module' };",
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality direct-delete array-element-conditional-numeric-nonlength predicates as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      'if (((delete ([] as any)[marker === 1 ? 0 : 1]) === true)) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality direct-delete array-element-mixed-nullish-numeric predicates as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      'if (((delete ([] as any)[(marker === 1 ? null : 0) ?? 1]) === true)) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('keeps strict-equality direct-delete array-element-conditional-mixed-key predicates conservative for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      "if (((delete ([] as any)[marker === 1 ? 'length' : 'safe']) === false)) moduleAlias = { default: 'not-a-module' };",
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('keeps strict-equality direct-delete array-element-dynamic-key predicates conservative for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      "if (((delete ([] as any)[marker]) === false)) moduleAlias = { default: 'not-a-module' };",
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('keeps strict-equality direct-delete unknown-target-element predicates conservative for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = globalThis as any;',
      "if (((delete marker['safe']) === true)) moduleAlias = { default: 'not-a-module' };",
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('keeps strict-equality direct-delete unknown-target predicates conservative for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = globalThis as any;',
      "if (((delete marker.safe) === true)) moduleAlias = { default: 'not-a-module' };",
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality direct-delete primitive-boolean targets as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if (((delete ((false as any).safe) === true)) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('keeps strict-equality direct-delete primitive-string-length targets conservative for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      "if (((delete (('abc' as any).length) === false)) moduleAlias = { default: 'not-a-module' };",
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality direct-delete new-date-target predicates as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if (((delete ((new Date() as any).safe) === true)) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality direct-delete new-regexp-target predicates as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      "if (((delete ((new RegExp('safe') as any).source) === true)) {",
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality direct-delete new-array-element predicates as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if (((delete ((new Array() as any)[0]) === true)) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality direct-delete new-function-nonprototype predicates as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if (((delete ((new Function() as any).safe) === true)) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality direct-delete new-string-nonlength predicates as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      "if (((delete ((new String('safe') as any).tag) === true)) {",
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('keeps strict-equality direct-delete new-array-length-target predicates conservative for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      "if (((delete ((new Array() as any).length) === false)) moduleAlias = { default: 'not-a-module' };",
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('keeps strict-equality direct-delete new-string-length-target predicates conservative for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      "if (((delete ((new String('safe') as any).length) === false)) moduleAlias = { default: 'not-a-module' };",
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality direct-delete conditional-known-new-constructor-target predicates as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      'if (((delete ((new ((marker === 1 ? Date : RegExp) as any)() as any).safe) === true)) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality direct-delete globalthis-new-constructor-target predicates as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if (((delete ((new ((globalThis as any).Date)() as any).safe) === true)) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality direct-delete globalthis-element-new-constructor-target predicates as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      "if (((delete ((new ((globalThis as any)['Date'])() as any).safe) === true)) {",
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality direct-delete self-element-new-constructor-target predicates as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      "if (((delete ((new ((self as any)['Date'])() as any).safe) === true)) {",
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality direct-delete conditional-global-qualifier-new-constructor-target predicates as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      'if (((delete ((new (((marker === 1 ? globalThis : self) as any).Date)() as any).safe) === true)) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality direct-delete nullish-global-qualifier-new-constructor-target predicates as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if (((delete ((new ((((null as any) ?? globalThis) as any).Date)() as any).safe) === true)) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('keeps strict-equality direct-delete conditional-mixed-new-constructor-length predicates conservative for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      "if (((delete ((new ((marker === 1 ? Array : Date) as any)() as any).length) === false)) moduleAlias = { default: 'not-a-module' };",
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('keeps strict-equality direct-delete conditional-mixed-element-new-constructor-length predicates conservative for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      "if (((delete ((new ((globalThis as any)[marker === 1 ? 'Array' : 'Date'])() as any).length) === false)) moduleAlias = { default: 'not-a-module' };",
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('keeps strict-equality direct-delete conditional-mixed-global-qualifier-new-constructor-target predicates conservative for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      'const fallback = {} as any;',
      "if (((delete ((new (((marker === 1 ? globalThis : fallback) as any).Date)() as any).safe) === true)) moduleAlias = { default: 'not-a-module' };",
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('keeps strict-equality direct-delete mixed-nullish-global-qualifier-new-constructor-target predicates conservative for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      'const fallback = {} as any;',
      "if (((delete ((new ((((marker === 1 ? null : fallback) ?? globalThis) as any).Date)() as any).safe) === true)) moduleAlias = { default: 'not-a-module' };",
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('keeps strict-equality direct-delete new-function-prototype-target predicates conservative for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      "if (((delete ((new Function() as any).prototype) === false)) moduleAlias = { default: 'not-a-module' };",
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality direct-delete regexp-target predicates as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if (((delete ((/safe/ as any).source) === true)) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('keeps strict-equality direct-delete mixed regexp-target predicates conservative for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      'const fallback = globalThis as any;',
      "if (((delete ((marker === 1 ? (/safe/ as any) : fallback).source) === true)) moduleAlias = { default: 'not-a-module' };",
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality direct-delete function-target nonprototype predicates as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if (((delete (((function () {}) as any).safe) === true)) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('keeps strict-equality direct-delete function-target prototype predicates conservative for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      "if (((delete (((function () {}) as any).prototype) === false)) moduleAlias = { default: 'not-a-module' };",
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality direct-delete class-target nonprototype predicates as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if (((delete (((class {}) as any).safe) === true)) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('keeps strict-equality direct-delete class-target prototype predicates conservative for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      "if (((delete (((class {}) as any).prototype) === false)) moduleAlias = { default: 'not-a-module' };",
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality direct-delete arrow-target prototype predicates as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if (((delete (((() => {}) as any).prototype) === true)) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality direct-delete conditional-object-target predicates as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      'if (((delete (marker === 1 ? { safe: 1 } : { guard: 1 }).safe) === true)) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality direct-delete nullish-array-length-target predicates as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if (((delete ((null ?? []) as any).length) === false)) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality direct-delete logical-or object-target predicates as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if (((delete (((false && (globalThis as any)) || { safe: 1 }).safe) === true)) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality direct-delete logical-and array-length-target predicates as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if (((delete (((true && ([] as any))).length) === false)) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality direct-delete comma array-length-target predicates as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if (((delete (((globalThis as any), ([] as any)).length) === false)) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality direct-delete conditional-object-element-target predicates as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      "if (((delete ((marker === 1 ? { safe: 1 } : { guard: 1 })['safe'])) === true)) {",
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality direct-delete nullish-array-element-length-target predicates as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      "if (((delete (((null ?? []) as any)['length']) === false)) {",
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality direct-delete logical-or object-element-target predicates as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      "if (((delete ((((false && (globalThis as any)) || { safe: 1 })['safe'])) === true)) {",
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('keeps strict-equality direct-delete mixed logical-element-target predicates conservative for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      'const fallback = globalThis as any;',
      "if (((delete (((((marker === 1) && fallback) || { safe: 1 })['safe'])) === true)) moduleAlias = { default: 'not-a-module' };",
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('keeps strict-equality direct-delete mixed logical-target predicates conservative for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      'const fallback = globalThis as any;',
      "if (((delete ((((marker === 1) && fallback) || { safe: 1 }).safe) === true)) moduleAlias = { default: 'not-a-module' };",
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('keeps strict-equality direct-delete mixed conditional-target predicates conservative for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      'const fallback = globalThis as any;',
      "if (((delete (marker === 1 ? { safe: 1 } : fallback).safe) === true)) moduleAlias = { default: 'not-a-module' };",
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('keeps strict-equality logical-and false primitives with conditional-selected nonboolean left values conservative for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      "if (((((true ? marker : (marker === 1)) && false) === false))) moduleAlias = { default: 'not-a-module' };",
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('keeps strict-equality logical-or true primitives with conditional-selected nonboolean left values conservative for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      "if (((((false ? (marker === 1) : marker) || true) === true))) moduleAlias = { default: 'not-a-module' };",
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality logical-and false primitives with comma-selected boolean left values as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      'if ((((((0, marker === 1) && false) === false)))) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality logical-or true primitives with comma-selected boolean left values as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      'if ((((((0, marker === 1) || true) === true)))) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('keeps strict-equality logical-and false primitives with comma-selected nonboolean left values conservative for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      "if ((((((0, marker) && false) === false)))) moduleAlias = { default: 'not-a-module' };",
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('keeps strict-equality logical-or true primitives with comma-selected nonboolean left values conservative for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      "if ((((((0, marker) || true) === true)))) moduleAlias = { default: 'not-a-module' };",
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality logical-or true primitives with truthy-nonboolean-selected boolean left values as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      'if (((((1 && (marker === 1)) || true) === true))) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality logical-and false primitives with falsey-nonboolean-selected boolean left values as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      'if (((((0 || (marker === 1)) && false) === false))) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('keeps strict-equality logical-or true primitives with truthy-nonboolean-selected nonboolean left values conservative for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      "if (((((1 && marker) || true) === true))) moduleAlias = require('./fixtures/other-module.js');",
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps strict-equality logical-and false primitives with falsey-nonboolean-selected nonboolean left values conservative for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      "if (((((0 || marker) && false) === false))) moduleAlias = require('./fixtures/other-module.js');",
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('treats strict-equality logical-and false primitives with nested unknown-boolean left values as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      'if ((((((marker === 1) && true) && false) === false))) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality logical-or true primitives with nested unknown-boolean left values as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      'if ((((((marker === 1) || false) || true) === true))) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality logical-and false primitives with nested nullish-boolean left values as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      'if ((((((marker === 1) ?? false) && false) === false))) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality logical-or true primitives with nested nullish-boolean left values as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      'if ((((((marker === 1) ?? false) || true) === true))) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality logical-and false primitives with null-coalesced boolean-right left values as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      'if (((((null ?? (marker === 1)) && false) === false))) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality logical-or true primitives with null-coalesced boolean-right left values as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      'if (((((null ?? (marker === 1)) || true) === true))) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality logical-and false primitives with nullish-conditional-selected boolean left values as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      'if (((((((marker === 1 ? null : undefined) ?? (marker === 2)) && false) === false)))) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality logical-or true primitives with nullish-conditional-selected boolean left values as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      'if (((((((marker === 1 ? null : undefined) ?? (marker === 2)) || true) === true)))) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality logical-and false primitives with nullish-logical-selected boolean left values as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      'if ((((((marker === 1 ? null : undefined) && marker) ?? true) === true))) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('keeps strict-equality logical-and false primitives with nullish-logical-selected mixed left values conservative for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      "if ((((((marker === 1 ? null : 0) && marker) ?? true) === true))) moduleAlias = { default: 'not-a-module' };",
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('treats nullish-coalesced logical-or true-left predicates as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      'if (((marker || true) ?? false)) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('keeps nullish-coalesced logical-or null-right predicates conservative for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      "if (((marker || null) ?? false)) moduleAlias = { default: 'not-a-module' };",
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('treats nullish-coalesced logical-and null-right false-default predicates as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      'if (((marker && null) ?? false)) {',
      "  moduleAlias = { default: 'not-a-module' };",
      '} else {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('keeps nullish-coalesced logical-and null-right true-default predicates conservative for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      "if (((marker && null) ?? true)) moduleAlias = { default: 'not-a-module' };",
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality logical-and false primitives with in-operator boolean-left values as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      "if ((((('missing' in { safe: 1 }) && marker) === false))) {",
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality logical-or true primitives with in-operator boolean-left values as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      "if ((((('safe' in { safe: 1 }) || marker) === true))) {",
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('keeps strict-equality in direct-delete right operands conservative for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      "if ((((('safe' in (delete ({ safe: 1 }).safe)) === false)))) moduleAlias = { default: 'not-a-module' };",
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('keeps strict-equality in nullish-selected delete right operands conservative for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      "if ((((('safe' in (null ?? delete ({ safe: 1 }).safe)) === false)))) moduleAlias = { default: 'not-a-module' };",
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('keeps strict-equality in conditional-delete right operands conservative for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      "if ((((('safe' in (marker === 1 ? delete ({ safe: 1 }).safe : delete ({ guard: 1 }).guard)) === false)))) moduleAlias = { default: 'not-a-module' };",
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality logical-and false primitives with instanceof boolean-left values as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      'if ((((({}) instanceof Array) && marker) === false)) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality logical-or true primitives with instanceof boolean-left values as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      'if ((((({}) instanceof Object) || marker) === true)) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats nullish-coalesced logical-and instanceof false-left predicates as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      'if ((((({}) instanceof Array) && marker) ?? true)) {',
      "  moduleAlias = { default: 'not-a-module' };",
      '} else {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats nullish-coalesced logical-or instanceof true-left predicates as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      'if ((((({}) instanceof Object) || marker) ?? false)) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality instanceof conditional true-selected boolean results as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if ((((true ? !left : marker) instanceof Object) === false)) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality instanceof conditional unknown-selected boolean results as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      'if (((((marker === 1 ? !left : !right) instanceof Object) === false))) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality instanceof nullish-coalesced conditional-negation operands as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      'if ((((((marker ? !left : !right) ?? (marker === 2 ? up : down)) instanceof Object) === false))) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('keeps strict-equality instanceof conditional mixed-selected results conservative for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      "if (((((marker === 1 ? !left : right) instanceof Object) === false))) moduleAlias = { default: 'not-a-module' };",
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('keeps strict-equality instanceof nullish-coalesced mixed conditional operands conservative for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      "if ((((((marker ? !left : right) ?? (marker === 2 ? up : down)) instanceof Object) === false))) moduleAlias = { default: 'not-a-module' };",
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality instanceof conditional-selected delete operands as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      'if (((((true ? delete ({ safe: 1 }).safe : marker) instanceof Object) === false))) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality instanceof conditional-delete unknown-selected operands as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      'if (((((marker === 1 ? delete ({ safe: 1 }).safe : delete ({ guard: 1 }).guard) instanceof Object) === false))) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality instanceof direct-delete operands as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if ((((delete ({ safe: 1 }).safe) instanceof Object) === false)) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality instanceof nullish-selected delete operands as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if (((((null ?? delete ({ safe: 1 }).safe) instanceof Object) === false))) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('keeps strict-equality instanceof nullish-mixed delete operands conservative for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = globalThis as any;',
      "if (((((marker ?? delete ({ safe: 1 }).safe) instanceof Object) === false))) moduleAlias = { default: 'not-a-module' };",
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('keeps strict-equality instanceof conditional mixed-delete operands conservative for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      "if (((((marker === 1 ? delete ({ safe: 1 }).safe : marker) instanceof Object) === false))) moduleAlias = { default: 'not-a-module' };",
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality logical-and false primitives with typeof boolean-left values as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      "if ((((typeof 1 === 'string') && marker) === false)) {",
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality logical-or true primitives with typeof boolean-left values as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      "if ((((typeof 1 === 'number') || marker) === true)) {",
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality typeof logical-and false-selected boolean results as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      "if (((typeof ((marker === 1) && false)) === 'boolean')) {",
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality typeof logical-or true-selected boolean results as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      "if (((typeof ((marker === 1) || true)) === 'boolean')) {",
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality typeof conditional true-selected boolean results as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      "if (((typeof (true ? !left : marker)) === 'boolean')) {",
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality typeof conditional unknown-selected boolean results as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      "if (((typeof (marker === 1 ? !left : !right)) === 'boolean')) {",
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality typeof conditional-selected delete results as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      "if (((typeof (true ? delete ({ safe: 1 }).safe : marker)) === 'boolean')) {",
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality typeof conditional-delete unknown-selected results as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      "if (((typeof (marker === 1 ? delete ({ safe: 1 }).safe : delete ({ guard: 1 }).guard)) === 'boolean')) {",
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality typeof direct-delete results as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      "if (((typeof (delete ({ safe: 1 }).safe)) === 'boolean')) {",
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality typeof nullish-selected delete results as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      "if (((typeof ((null ?? delete ({ safe: 1 }).safe))) === 'boolean')) {",
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('keeps strict-equality typeof nullish-mixed delete results conservative for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = globalThis as any;',
      "if (((typeof ((marker ?? delete ({ safe: 1 }).safe))) === 'boolean')) moduleAlias = { default: 'not-a-module' };",
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('keeps strict-equality typeof conditional mixed-delete results conservative for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      "if (((typeof (marker === 1 ? delete ({ safe: 1 }).safe : right)) === 'boolean')) moduleAlias = { default: 'not-a-module' };",
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('keeps strict-equality typeof conditional mixed-selected results conservative for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      "if (((typeof (marker === 1 ? !left : right)) === 'boolean')) moduleAlias = { default: 'not-a-module' };",
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('keeps strict-equality typeof logical-and unknown-selected results conservative for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      "if (((typeof ((marker === 1) && marker)) === 'boolean')) moduleAlias = { default: 'not-a-module' };",
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('keeps strict-equality typeof logical-or unknown-selected results conservative for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      "if (((typeof ((marker === 1) || marker)) === 'boolean')) moduleAlias = { default: 'not-a-module' };",
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality typeof nullish-coalesced conditional-negation boolean operands as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      "if (((typeof (((marker ? !left : !right) ?? (marker === 2 ? !up : !down))) === 'boolean'))) {",
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality typeof nullish-coalesced mixed conditional operands as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      "if (((typeof (((marker ? !left : !right) ?? (marker === 2 ? up : down))) === 'boolean'))) moduleAlias = { default: 'not-a-module' };",
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.have.length(0);
  });

  it('treats nullish-coalesced logical-and typeof false-left predicates as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      "if ((((typeof 1 === 'string') && marker) ?? true)) {",
      "  moduleAlias = { default: 'not-a-module' };",
      '} else {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats nullish-coalesced logical-or typeof true-left predicates as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      "if ((((typeof 1 === 'number') || marker) ?? false)) {",
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('keeps nullish-coalesced typeof-and-false predicates conservative for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      "if ((((typeof marker) && false) ?? true)) moduleAlias = { default: 'not-a-module' };",
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('keeps nullish-coalesced typeof-and-unknown predicates conservative for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      "if ((((typeof marker) && marker) ?? true)) moduleAlias = { default: 'not-a-module' };",
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('keeps strict-equality logical-and false primitives with nullish-conditional-selected nonboolean left values conservative for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      "if (((((((marker === 1 ? null : undefined) ?? marker) && false) === false)))) moduleAlias = { default: 'not-a-module' };",
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('keeps strict-equality logical-or true primitives with nullish-conditional-selected nonboolean left values conservative for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      "if (((((((marker === 1 ? null : undefined) ?? marker) || true) === true)))) moduleAlias = { default: 'not-a-module' };",
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('keeps strict-equality logical-and false primitives with null-coalesced right-nonboolean-selected left values conservative for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      "if (((((null ?? marker) && false) === false))) moduleAlias = require('./fixtures/other-module.js');",
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps strict-equality logical-or true primitives with null-coalesced right-nonboolean-selected left values conservative for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      "if (((((null ?? marker) || true) === true))) moduleAlias = require('./fixtures/other-module.js');",
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps strict-equality logical-and false primitives with nested nullish-nonboolean left values conservative for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      "if ((((marker ?? false) && false) === false)) moduleAlias = { default: 'not-a-module' };",
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('keeps strict-equality logical-or true primitives with nested nullish-nonboolean left values conservative for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      "if ((((marker ?? false) || true) === true)) moduleAlias = { default: 'not-a-module' };",
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality logical primitives with truthy non-primitive left values as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if (((({}) && 2) === 2)) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-inequality logical primitives with truthy non-primitive left values as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if (((({}) && 2) !== 3)) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('keeps strict-comparison logical primitives with truthy non-primitive left unknown-right values conservative for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      "if (((({}) && marker) === 2)) moduleAlias = { default: 'not-a-module' };",
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality non-primitive literal comparisons as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if ((({} === 1))) {',
      "  moduleAlias = { default: 'not-a-module' };",
      '} else {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-inequality non-primitive literal comparisons as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if ((({} !== 1))) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats loose-equality non-primitive nullish comparisons as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if ((({} == null))) {',
      "  moduleAlias = { default: 'not-a-module' };",
      '} else {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats loose-inequality non-primitive nullish comparisons as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if ((({} != null))) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('keeps loose-comparison mixed non-primitive unknown operands conservative for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      "if (((marker === 1 ? {} : marker) == null)) moduleAlias = { default: 'not-a-module' };",
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('treats loose-equality non-primitive comparisons as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if ((({} == []))) {',
      "  moduleAlias = { default: 'not-a-module' };",
      '} else {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats loose-inequality non-primitive comparisons as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if ((({} != []))) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-inequality wrapped non-primitive comparisons with matching unknown selectors as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      'if (((marker === 1 ? {} : []) !== (marker === 1 ? [] : {}))) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality wrapped non-primitive comparisons with matching unknown selectors as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      'if (((marker === 1 ? {} : []) === (marker === 1 ? [] : {}))) {',
      "  moduleAlias = { default: 'not-a-module' };",
      '} else {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats loose-inequality wrapped non-primitive comparisons with matching unknown selectors as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      'if (((marker === 1 ? {} : []) != (marker === 1 ? [] : {}))) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats loose-equality wrapped non-primitive comparisons with matching unknown selectors as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      'if (((marker === 1 ? {} : []) == (marker === 1 ? [] : {}))) {',
      "  moduleAlias = { default: 'not-a-module' };",
      '} else {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('keeps wrapped non-primitive comparisons with differing unknown selectors conservative for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      "if (((marker === 1 ? {} : marker) != (marker === 1 ? [] : marker))) moduleAlias = { default: 'not-a-module' };",
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('keeps loose-equality wrapped non-primitive comparisons with differing unknown selectors conservative for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      "if (((marker === 1 ? {} : marker) == (marker === 1 ? [] : marker))) moduleAlias = { default: 'not-a-module' };",
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality logical-or non-primitive primitives as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if ((((0 || {}) === 1))) {',
      "  moduleAlias = { default: 'not-a-module' };",
      '} else {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-inequality conditional non-primitive primitives with matching unknown selectors as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      'if (((marker === 1 ? {} : []) !== 1)) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('keeps strict-comparison conditional non-primitive primitives with differing unknown selectors conservative for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      "if (((marker === 1 ? {} : 1) === 1)) moduleAlias = { default: 'not-a-module' };",
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality negated primitive conditions as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if ((!0) === true) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-inequality negated primitive conditions as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if ((!1) !== false) {',
      "  moduleAlias = { default: 'not-a-module' };",
      '} else {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('keeps strict-comparison negated unknown predicates conservative for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      "if ((!(marker === 1)) === true) moduleAlias = { default: 'not-a-module' };",
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-inequality logical-and primitives as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      'if (((0 && marker) !== 1)) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-inequality logical-or primitives as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      'if (((1 || marker) !== 2)) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('keeps strict-inequality logical primitives with unknown left values conservative for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      "if ((((marker === 1) && 2) !== 1)) moduleAlias = { default: 'not-a-module' };",
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-inequality nullish primitives with null left values as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if (((null ?? 1) !== 2)) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-inequality nullish primitives with undefined left values as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if (((void 0 ?? 1) !== 2)) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-inequality nullish primitives with non-nullish left values as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      'if (((2 ?? marker) !== 1)) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('keeps strict-inequality nullish primitives with unknown left values conservative for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      "if ((((marker === 1) ?? 1) !== 2)) moduleAlias = { default: 'not-a-module' };",
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-inequality conditional primitives with static selectors as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if ((true ? 1 : 2) !== 2) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-inequality conditional primitives with matching unknown selectors as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      'if ((marker === 1 ? 1 : 1) !== 2) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('keeps strict-inequality conditional primitives with differing unknown selectors conservative for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      "if ((marker === 1 ? 1 : 2) !== 2) moduleAlias = { default: 'not-a-module' };",
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality signed numeric primitives as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if (((-1) === -1)) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-inequality signed numeric primitives as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if (((+1) !== 2)) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality nested signed numeric primitives as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if (((-(-1)) === 1)) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-inequality nested signed numeric primitives as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if (((+(+1)) !== 2)) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality signed coercible primitives as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if (((+true) === 1)) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality signed string primitives as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if (((+("1")) === 1)) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-inequality signed coercible primitives as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if (((-null) !== 1)) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-inequality signed boolean primitives as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if (((-(true)) !== 1)) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality signed undefined NaN primitives as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if (((+undefined) === 1)) {',
      "  moduleAlias = { default: 'not-a-module' };",
      '} else {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality signed NaN primitives as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if (((+("not-a-number")) === 1)) {',
      "  moduleAlias = { default: 'not-a-module' };",
      '} else {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality comma primitives as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if (((0, 1) === 1)) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-inequality comma primitives as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if (((0, 1) !== 2)) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('keeps strict-comparison comma unknown-right predicates conservative for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      "if (((0, marker) === 1)) moduleAlias = { default: 'not-a-module' };",
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('treats loose-equality primitives as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      "if ((('1' == 1))) {",
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats loose-inequality primitives as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      "if ((('1' != 2))) {",
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('keeps loose-comparison unknown operands conservative for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      "if (((marker == 1))) moduleAlias = { default: 'not-a-module' };",
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality arithmetic primitives as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if ((((1 + 2) * 3) === 9)) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-inequality arithmetic primitives as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      "if (((('ab' + 'cd') !== 'xx'))) {",
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('keeps strict-comparison arithmetic unknown operands conservative for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      "if ((((marker + 1) === 2))) moduleAlias = { default: 'not-a-module' };",
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality bitwise primitives as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if ((((5 & 3) << 1) === 2)) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-inequality bitwise primitives as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if ((((5 ^ 1) >>> 1) !== 3)) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('keeps strict-comparison bitwise unknown operands conservative for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      "if ((((marker & 1) << 1) === 2)) moduleAlias = { default: 'not-a-module' };",
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality comparison primitives as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if ((((1 < 2) === true))) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-inequality comparison primitives as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if ((((2 <= 1) !== true))) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('keeps strict-comparison comparison unknown operands conservative for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      "if ((((marker < 2) === true))) moduleAlias = { default: 'not-a-module' };",
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality signed bitwise-not primitives as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if (((~1) === -2)) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-inequality signed bitwise-not primitives as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if (((~1) !== 1)) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('keeps strict-comparison signed bitwise-not unknown predicates conservative for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      "if (((~marker) === -2)) moduleAlias = { default: 'not-a-module' };",
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('keeps strict-comparison signed unknown predicates conservative for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      "if (((-marker) === -1)) moduleAlias = { default: 'not-a-module' };",
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-inequality true conditions as true branches for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if (1 !== 2) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-inequality false conditions as false branches for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if (1 !== 1) {',
      "  moduleAlias = { default: 'not-a-module' };",
      '} else {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats logical-and false conditions as false branches for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if (true && false) {',
      "  moduleAlias = { default: 'not-a-module' };",
      '} else {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats logical-or true conditions as true branches for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if (false || true) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats logical-and short-circuit false conditions as false branches for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      'if (marker === 1 && false) {',
      "  moduleAlias = { default: 'not-a-module' };",
      '} else {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats logical-or short-circuit true conditions as true branches for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      'if (marker === 1 || true) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('keeps logical-and true predicates unknown for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      "if (marker === 1 && true) moduleAlias = { default: 'not-a-module' };",
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('keeps logical-or false predicates unknown for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      "if (marker === 1 || false) moduleAlias = { default: 'not-a-module' };",
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('treats conditional-expression true selectors as selected branches for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if (true ? false : true) {',
      "  moduleAlias = { default: 'not-a-module' };",
      '} else {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats conditional-expression false selectors as selected branches for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if (false ? false : true) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats conditional-expression unknown selectors with matching branches as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      "if (marker === 1 ? false : false) moduleAlias = { default: 'not-a-module' };",
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('treats conditional-expression unknown selectors with matching true branches as deterministic for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      'if (marker === 1 ? true : true) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('keeps conditional-expression unknown selectors with differing branches conservative for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      "if (marker === 1 ? true : false) moduleAlias = { default: 'not-a-module' };",
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('keeps conditional-expression selected unknown branches conservative for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      "if (true ? marker === 1 : false) moduleAlias = { default: 'not-a-module' };",
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-inequality null-undefined conditions as true branches for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if (null !== undefined) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('treats strict-equality void-undefined conditions as true branches for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if (void 0 === undefined) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('keeps strict-comparison identifier predicates unknown for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const marker = Math.random();',
      "if (marker === 1) moduleAlias = { default: 'not-a-module' };",
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('keeps object-literal strict-comparison predicates unknown for module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if ({ marker: 1 } === { marker: 1 }) {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('keeps possible branch module-source aliases in symbol sources for unknown if-else conditions', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if (Math.random() > 0.5) {',
      "  moduleAlias = require('./fixtures/other-module.js');",
      '} else {',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('clears module-source aliases in symbol sources when all unknown if branches overwrite to non-module values', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if (Math.random() > 0.5) {',
      "  moduleAlias = { default: 'not-a-module' };",
      '} else {',
      "  moduleAlias = { default: 'still-not-a-module' };",
      '}',
      'const shadowedDefault = moduleAlias.default;',
      "const directDefault = require('./fixtures/guard-module.js').default;",
      'void shadowedDefault;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(
      references.filter(
        (reference) => reference === 'default@./fixtures/guard-module.js',
      ).length,
    ).to.equal(1);
  });

  it('does not leak if-branch class module-source alias shadowing before declaration to outer symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if (true) {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  class moduleAlias {}',
      '  void preDeclarationSymbol;',
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('inner@./fixtures/guard-module.js');
  });

  it('does not leak else-branch class module-source alias shadowing before declaration to outer symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if (false) {',
      '  void 0;',
      '} else {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  class moduleAlias {}',
      '  void preDeclarationSymbol;',
      '}',
      'const postElseDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('inner@./fixtures/guard-module.js');
  });

  it('does not leak hoisted if-branch function module-source alias shadowing to outer symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if (true) {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  function moduleAlias(_value: unknown) {',
      '    return _value;',
      '  }',
      '  void preDeclarationSymbol;',
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('inner@./fixtures/guard-module.js');
  });

  it('does not leak hoisted else-branch function module-source alias shadowing to outer symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if (false) {',
      '  void 0;',
      '} else {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  function moduleAlias(_value: unknown) {',
      '    return _value;',
      '  }',
      '  void preDeclarationSymbol;',
      '}',
      'const postElseDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('inner@./fixtures/guard-module.js');
  });

  it('does not leak if-branch enum module-source alias shadowing before declaration to outer symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if (true) {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  enum moduleAlias {',
      '    Marker = 0,',
      '  }',
      '  void preDeclarationSymbol;',
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('inner@./fixtures/guard-module.js');
  });

  it('does not leak else-branch enum module-source alias shadowing before declaration to outer symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if (false) {',
      '  void 0;',
      '} else {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  enum moduleAlias {',
      '    Marker = 0,',
      '  }',
      '  void preDeclarationSymbol;',
      '}',
      'const postElseDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('inner@./fixtures/guard-module.js');
  });

  it('does not leak if-branch class module-source alias declarations to outer symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if (true) {',
      '  class moduleAlias {}',
      '  const postDeclarationSymbol = moduleAlias.inner;',
      '  void postDeclarationSymbol;',
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('inner@./fixtures/guard-module.js');
  });

  it('does not leak else-branch class module-source alias declarations to outer symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if (false) {',
      '  void 0;',
      '} else {',
      '  class moduleAlias {}',
      '  const postDeclarationSymbol = moduleAlias.inner;',
      '  void postDeclarationSymbol;',
      '}',
      'const postElseDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('inner@./fixtures/guard-module.js');
  });

  it('does not leak if-branch function module-source alias declarations to outer symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if (true) {',
      '  function moduleAlias(_value: unknown) {',
      '    return _value;',
      '  }',
      '  const postDeclarationSymbol = moduleAlias.inner;',
      '  void postDeclarationSymbol;',
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('inner@./fixtures/guard-module.js');
  });

  it('does not leak else-branch function module-source alias declarations to outer symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if (false) {',
      '  void 0;',
      '} else {',
      '  function moduleAlias(_value: unknown) {',
      '    return _value;',
      '  }',
      '  const postDeclarationSymbol = moduleAlias.inner;',
      '  void postDeclarationSymbol;',
      '}',
      'const postElseDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('inner@./fixtures/guard-module.js');
  });

  it('does not leak if-branch enum module-source alias declarations to outer symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if (true) {',
      '  enum moduleAlias {',
      '    Marker = 0,',
      '  }',
      '  const postDeclarationSymbol = moduleAlias.inner;',
      '  void postDeclarationSymbol;',
      '}',
      'const postIfDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('inner@./fixtures/guard-module.js');
  });

  it('does not leak else-branch enum module-source alias declarations to outer symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'if (false) {',
      '  void 0;',
      '} else {',
      '  enum moduleAlias {',
      '    Marker = 0,',
      '  }',
      '  const postDeclarationSymbol = moduleAlias.inner;',
      '  void postDeclarationSymbol;',
      '}',
      'const postElseDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('inner@./fixtures/guard-module.js');
  });

  it('does not leak hoisted while-block function module-source alias shadowing to outer symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'while (true) {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  function moduleAlias(_value: unknown) {',
      '    return _value;',
      '  }',
      '  void preDeclarationSymbol;',
      '  break;',
      '}',
      'const postWhileDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('inner@./fixtures/guard-module.js');
  });

  it('does not leak hoisted do-while function module-source alias shadowing to outer symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'do {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  function moduleAlias(_value: unknown) {',
      '    return _value;',
      '  }',
      '  void preDeclarationSymbol;',
      '} while (false);',
      'const postDoWhileDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('inner@./fixtures/guard-module.js');
  });

  it('does not leak while-block enum module-source alias shadowing before declaration to outer symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'while (true) {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  enum moduleAlias {',
      '    Marker = 0,',
      '  }',
      '  void preDeclarationSymbol;',
      '  break;',
      '}',
      'const postWhileDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('inner@./fixtures/guard-module.js');
  });

  it('does not leak do-while enum module-source alias shadowing before declaration to outer symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'do {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  enum moduleAlias {',
      '    Marker = 0,',
      '  }',
      '  void preDeclarationSymbol;',
      '} while (false);',
      'const postDoWhileDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('inner@./fixtures/guard-module.js');
  });

  it('does not leak while-block class module-source alias declarations to outer symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'while (true) {',
      '  class moduleAlias {}',
      '  const postDeclarationSymbol = moduleAlias.inner;',
      '  void postDeclarationSymbol;',
      '  break;',
      '}',
      'const postWhileDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('inner@./fixtures/guard-module.js');
  });

  it('does not leak do-while class module-source alias declarations to outer symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'do {',
      '  class moduleAlias {}',
      '  const postDeclarationSymbol = moduleAlias.inner;',
      '  void postDeclarationSymbol;',
      '} while (false);',
      'const postDoWhileDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('inner@./fixtures/guard-module.js');
  });

  it('does not leak while-block function module-source alias declarations to outer symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'while (true) {',
      '  function moduleAlias(_value: unknown) {',
      '    return _value;',
      '  }',
      '  const postDeclarationSymbol = moduleAlias.inner;',
      '  void postDeclarationSymbol;',
      '  break;',
      '}',
      'const postWhileDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('inner@./fixtures/guard-module.js');
  });

  it('does not leak do-while function module-source alias declarations to outer symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'do {',
      '  function moduleAlias(_value: unknown) {',
      '    return _value;',
      '  }',
      '  const postDeclarationSymbol = moduleAlias.inner;',
      '  void postDeclarationSymbol;',
      '} while (false);',
      'const postDoWhileDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('inner@./fixtures/guard-module.js');
  });

  it('does not leak while-block enum module-source alias declarations to outer symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'while (true) {',
      '  enum moduleAlias {',
      '    Marker = 0,',
      '  }',
      '  const postDeclarationSymbol = moduleAlias.inner;',
      '  void postDeclarationSymbol;',
      '  break;',
      '}',
      'const postWhileDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('inner@./fixtures/guard-module.js');
  });

  it('does not leak do-while enum module-source alias declarations to outer symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'do {',
      '  enum moduleAlias {',
      '    Marker = 0,',
      '  }',
      '  const postDeclarationSymbol = moduleAlias.inner;',
      '  void postDeclarationSymbol;',
      '} while (false);',
      'const postDoWhileDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('inner@./fixtures/guard-module.js');
  });

  it('does not leak lexical for-loop enum module-source alias shadowing before declaration to outer symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'for (const iteration of [1]) {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  enum moduleAlias {',
      '    Marker = 0,',
      '  }',
      '  void preDeclarationSymbol;',
      '  void iteration;',
      '}',
      'const postLoopDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('inner@./fixtures/guard-module.js');
  });

  it('does not leak lexical for-loop enum module-source alias declarations to outer symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'for (const iteration of [1]) {',
      '  enum moduleAlias {',
      '    Marker = 0,',
      '  }',
      '  const postDeclarationSymbol = moduleAlias.inner;',
      '  void postDeclarationSymbol;',
      '  void iteration;',
      '}',
      'const postLoopDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('inner@./fixtures/guard-module.js');
  });

  it('does not leak lexical for-loop class module-source alias shadowing before declaration to outer symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'for (const iteration of [1]) {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  class moduleAlias {}',
      '  void preDeclarationSymbol;',
      '  void iteration;',
      '}',
      'const postLoopDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('inner@./fixtures/guard-module.js');
  });

  it('does not leak lexical for-loop class module-source alias declarations to outer symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'for (const iteration of [1]) {',
      '  class moduleAlias {}',
      '  const postDeclarationSymbol = moduleAlias.inner;',
      '  void postDeclarationSymbol;',
      '  void iteration;',
      '}',
      'const postLoopDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('inner@./fixtures/guard-module.js');
  });

  it('does not leak direct require symbol-source shadowing across lexical for-of scopes', () => {
    const source = [
      'for (const require of [() => undefined]) {',
      "  require('./fixtures/other-module.js').default;",
      '}',
      "const postLoopDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('does not leak direct require symbol-source shadowing across lexical for-in scopes', () => {
    const source = [
      'for (const require in { item: 1 }) {',
      "  require('./fixtures/other-module.js').default;",
      '}',
      "const postLoopDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('does not leak direct require symbol-source shadowing across lexical for scopes', () => {
    const source = [
      'for (let require = () => undefined; ; ) {',
      "  require('./fixtures/other-module.js').default;",
      '  break;',
      '}',
      "const postLoopDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('does not treat binding-pattern shadowed aliases as module-sourced', () => {
    const source = [
      'const reqAlias = require;',
      '{',
      '  const { reqAlias } = { reqAlias: () => undefined };',
      "  reqAlias('./fixtures/other-module.js').default;",
      '}',
      "const postBlockDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('does not treat loop binding-pattern shadowed aliases as module-sourced', () => {
    const source = [
      'const reqAlias = require;',
      'for (const { reqAlias } of [{ reqAlias: () => undefined }]) {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '}',
      "const postLoopDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('does not treat assignment-pattern shadowed aliases as module-sourced', () => {
    const source = [
      'let reqAlias = require;',
      '({ reqAlias } = { reqAlias: () => undefined });',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('keeps module-source alias assignments made inside block scopes', () => {
    const source = [
      'let moduleAlias: any;',
      '{',
      "  moduleAlias = require('./fixtures/guard-module.js');",
      '}',
      'const postBlockDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('keeps block type-alias declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      '{',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  type reqAlias = (_value: unknown) => unknown;',
      '}',
      "const postBlockDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps block interface declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      '{',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  interface reqAlias {',
      '    value: string;',
      '  }',
      '}',
      "const postBlockDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps block ambient class declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      '{',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  declare class reqAlias {}',
      '}',
      "const postBlockDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps block ambient enum declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      '{',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  declare enum reqAlias {',
      '    Marker = 0,',
      '  }',
      '}',
      "const postBlockDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps block ambient function declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      '{',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  declare function reqAlias(_path: string): unknown;',
      '}',
      "const postBlockDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps block ambient namespace declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      '{',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  declare namespace reqAlias {',
      '    const marker: unknown;',
      '  }',
      '}',
      "const postBlockDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps block ambient module declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      '{',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  declare module reqAlias {',
      '    const marker: unknown;',
      '  }',
      '}',
      "const postBlockDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps block ambient const declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      '{',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  declare const reqAlias: (_path: string) => unknown;',
      '}',
      "const postBlockDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps block ambient let declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      '{',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  declare let reqAlias: (_path: string) => unknown;',
      '}',
      "const postBlockDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps block ambient var declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      '{',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  declare var reqAlias: (_path: string) => unknown;',
      '}',
      "const postBlockDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps block type-alias declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      '{',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  type moduleAlias = { inner: unknown };',
      '  void preDeclarationSymbol;',
      '}',
      'const postBlockDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps block interface declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      '{',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  interface moduleAlias {',
      '    inner: unknown;',
      '  }',
      '  void preDeclarationSymbol;',
      '}',
      'const postBlockDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps block ambient class declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      '{',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  declare class moduleAlias {}',
      '  void preDeclarationSymbol;',
      '}',
      'const postBlockDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps block ambient enum declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      '{',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  declare enum moduleAlias {',
      '    Marker = 0,',
      '  }',
      '  void preDeclarationSymbol;',
      '}',
      'const postBlockDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps block ambient function declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      '{',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  declare function moduleAlias(_path: string): unknown;',
      '  void preDeclarationSymbol;',
      '}',
      'const postBlockDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps block ambient namespace declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      '{',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  declare namespace moduleAlias {',
      '    const marker: unknown;',
      '  }',
      '  void preDeclarationSymbol;',
      '}',
      'const postBlockDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps block ambient module declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      '{',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  declare module moduleAlias {',
      '    const marker: unknown;',
      '  }',
      '  void preDeclarationSymbol;',
      '}',
      'const postBlockDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps block ambient const declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      '{',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  declare const moduleAlias: { inner: unknown };',
      '  void preDeclarationSymbol;',
      '}',
      'const postBlockDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps block ambient let declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      '{',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  declare let moduleAlias: { inner: unknown };',
      '  void preDeclarationSymbol;',
      '}',
      'const postBlockDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps block ambient var declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      '{',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  declare var moduleAlias: { inner: unknown };',
      '  void preDeclarationSymbol;',
      '}',
      'const postBlockDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('does not leak block lexical module-source alias shadowing before declaration to outer symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      '{',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  const moduleAlias = { inner: preDeclarationSymbol };',
      '  void moduleAlias;',
      '}',
      'const postBlockDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('inner@./fixtures/guard-module.js');
  });

  it('does not leak hoisted block function module-source alias shadowing to outer symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      '{',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  function moduleAlias(_value: unknown) {',
      '    return _value;',
      '  }',
      '  void preDeclarationSymbol;',
      '}',
      'const postBlockDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('inner@./fixtures/guard-module.js');
  });

  it('does not leak block class module-source alias shadowing before declaration to outer symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      '{',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  class moduleAlias {}',
      '  void preDeclarationSymbol;',
      '  void moduleAlias;',
      '}',
      'const postBlockDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('inner@./fixtures/guard-module.js');
  });

  it('does not leak block class module-source alias declarations to outer symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      '{',
      '  class moduleAlias {}',
      '  const postDeclarationSymbol = moduleAlias.inner;',
      '  void postDeclarationSymbol;',
      '  void moduleAlias;',
      '}',
      'const postBlockDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('inner@./fixtures/guard-module.js');
  });

  it('does not leak block lexical alias shadowing before declaration to outer symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      '{',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  const reqAlias = () => undefined;',
      '}',
      "const postBlockDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('does not leak hoisted block function alias shadowing to outer symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      '{',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  function reqAlias(_value: unknown) {',
      '    return _value;',
      '  }',
      '}',
      "const postBlockDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('does not leak block class alias shadowing before declaration to outer symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      '{',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  class reqAlias {}',
      '  void reqAlias;',
      '}',
      "const postBlockDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('does not leak block class alias declarations to outer symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      '{',
      '  class reqAlias {}',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  void reqAlias;',
      '}',
      "const postBlockDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('does not leak block enum alias shadowing before declaration to outer symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      '{',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  enum reqAlias {',
      '    Marker = 0,',
      '  }',
      '  void reqAlias;',
      '}',
      "const postBlockDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('does not leak block enum alias declarations to outer symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      '{',
      '  enum reqAlias {',
      '    Marker = 0,',
      '  }',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  void reqAlias;',
      '}',
      "const postBlockDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('does not leak block enum module-source alias shadowing before declaration to outer symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      '{',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  enum moduleAlias {',
      '    Marker = 0,',
      '  }',
      '  void preDeclarationSymbol;',
      '  void moduleAlias;',
      '}',
      'const postBlockDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('inner@./fixtures/guard-module.js');
  });

  it('does not leak block enum module-source alias declarations to outer symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      '{',
      '  enum moduleAlias {',
      '    Marker = 0,',
      '  }',
      '  const postDeclarationSymbol = moduleAlias.inner;',
      '  void postDeclarationSymbol;',
      '  void moduleAlias;',
      '}',
      'const postBlockDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('inner@./fixtures/guard-module.js');
  });

  it('clears module-source alias assignments to non-module values inside block scopes', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      '{',
      "  moduleAlias = { default: 'not-a-module' };",
      '}',
      'const shadowedDefault = moduleAlias.default;',
      "const directDefault = require('./fixtures/guard-module.js').default;",
      'void shadowedDefault;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(
      references.filter(
        (reference) => reference === 'default@./fixtures/guard-module.js',
      ).length,
    ).to.equal(1);
  });

  it('keeps module-source alias var declarations made inside block scopes', () => {
    const source = [
      '{',
      "  var moduleAlias = require('./fixtures/guard-module.js');",
      '}',
      'const postBlockDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('keeps require alias var declarations made inside switch case scopes in symbol sources', () => {
    const source = [
      'switch (1) {',
      '  case 1:',
      '    var reqAlias = require;',
      "    reqAlias('./fixtures/guard-module.js').default;",
      '    break;',
      '}',
      "const postCaseDefault = reqAlias('./fixtures/other-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('clears require alias var declarations to non-require values inside switch case scopes in symbol sources', () => {
    const source = [
      'switch (1) {',
      '  case 1:',
      '    var reqAlias = require;',
      "    reqAlias('./fixtures/guard-module.js').default;",
      '    reqAlias = () => undefined;',
      '    break;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('keeps require alias assignments made inside switch case scopes in symbol sources', () => {
    const source = [
      'let reqAlias: any;',
      'switch (1) {',
      '  case 1:',
      '    reqAlias = require;',
      '    break;',
      '}',
      "const postCaseDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('clears require alias assignments to non-require values inside switch case scopes in symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'switch (1) {',
      '  case 1:',
      '    reqAlias = () => undefined;',
      '    break;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('applies switch-case destructuring assignments to outer require aliases for symbol sources', () => {
    const source = [
      'let reqAlias: any = require;',
      'switch (1) {',
      '  case 1:',
      '    ({ reqAlias } = { reqAlias: () => undefined });',
      '    break;',
      '}',
      "reqAlias('./fixtures/other-module.js').default;",
      "const directDefault = require('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('applies switch-case require assignments to outer aliases for symbol sources', () => {
    const source = [
      'let reqAlias: any = () => undefined;',
      'switch (1) {',
      '  case 1:',
      '    reqAlias = require;',
      '    break;',
      '}',
      "const postCaseDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('keeps module-source alias assignments made inside switch case scopes', () => {
    const source = [
      'let moduleAlias: any;',
      'switch (1) {',
      '  case 1:',
      "    moduleAlias = require('./fixtures/guard-module.js');",
      '    break;',
      '}',
      'const postCaseDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('clears module-source alias assignments to non-module values inside switch case scopes', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'switch (1) {',
      '  case 1:',
      "    moduleAlias = { default: 'not-a-module' };",
      '    break;',
      '}',
      'const shadowedDefault = moduleAlias.default;',
      "const directDefault = require('./fixtures/guard-module.js').default;",
      'void shadowedDefault;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(
      references.filter(
        (reference) => reference === 'default@./fixtures/guard-module.js',
      ).length,
    ).to.equal(1);
  });

  it('keeps module-source alias var declarations made inside switch case scopes', () => {
    const source = [
      'switch (1) {',
      '  case 1:',
      "    var moduleAlias = require('./fixtures/guard-module.js');",
      '    break;',
      '}',
      'const postCaseDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('clears module-source alias var declarations to non-module values inside switch case scopes', () => {
    const source = [
      'switch (1) {',
      '  case 1:',
      "    var moduleAlias = require('./fixtures/guard-module.js');",
      "    moduleAlias = { default: 'not-a-module' };",
      '    break;',
      '}',
      'const shadowedDefault = moduleAlias.default;',
      "const directDefault = require('./fixtures/guard-module.js').default;",
      'void shadowedDefault;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(
      references.filter(
        (reference) => reference === 'default@./fixtures/guard-module.js',
      ).length,
    ).to.equal(1);
  });

  it('applies switch-case destructuring assignments to outer module-source aliases for symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      "const fallbackDefault = require('./fixtures/other-module.js').default;",
      'switch (1) {',
      '  case 1:',
      '    ({ moduleAlias } = { moduleAlias: { default: fallbackDefault } });',
      '    break;',
      '}',
      'const postCaseDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('applies switch-case require assignments to outer module-source aliases for symbol sources', () => {
    const source = [
      'let moduleAlias: any = { default: 0 };',
      'switch (1) {',
      '  case 1:',
      "    moduleAlias = require('./fixtures/guard-module.js');",
      '    break;',
      '}',
      'const postCaseDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('does not leak switch-case lexical alias declarations to outer symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'switch (1) {',
      '  case 1: {',
      '    const reqAlias = () => undefined;',
      "    reqAlias('./fixtures/other-module.js').default;",
      '    break;',
      '  }',
      '}',
      "const postCaseDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('does not leak switch-case lexical alias shadowing before declaration to outer symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'switch (1) {',
      '  case 1:',
      "    reqAlias('./fixtures/other-module.js').default;",
      '    const reqAlias = () => undefined;',
      '    break;',
      '  default:',
      '    break;',
      '}',
      "const postCaseDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('keeps switch-case type-alias declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'switch (1) {',
      '  case 1:',
      "    reqAlias('./fixtures/other-module.js').default;",
      '    type reqAlias = (_value: unknown) => unknown;',
      '    break;',
      '  default:',
      '    break;',
      '}',
      "const postCaseDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps switch-case interface declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'switch (1) {',
      '  case 1:',
      "    reqAlias('./fixtures/other-module.js').default;",
      '    interface reqAlias {',
      '      value: string;',
      '    }',
      '    break;',
      '  default:',
      '    break;',
      '}',
      "const postCaseDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps switch-case ambient class declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'switch (1) {',
      '  case 1:',
      "    reqAlias('./fixtures/other-module.js').default;",
      '    declare class reqAlias {}',
      '    break;',
      '  default:',
      '    break;',
      '}',
      "const postCaseDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps switch-case ambient enum declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'switch (1) {',
      '  case 1:',
      "    reqAlias('./fixtures/other-module.js').default;",
      '    declare enum reqAlias {',
      '      Marker = 0,',
      '    }',
      '    break;',
      '  default:',
      '    break;',
      '}',
      "const postCaseDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps switch-case ambient function declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'switch (1) {',
      '  case 1:',
      "    reqAlias('./fixtures/other-module.js').default;",
      '    declare function reqAlias(_path: string): unknown;',
      '    break;',
      '  default:',
      '    break;',
      '}',
      "const postCaseDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps switch-case ambient namespace declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'switch (1) {',
      '  case 1:',
      "    reqAlias('./fixtures/other-module.js').default;",
      '    declare namespace reqAlias {',
      '      const marker: unknown;',
      '    }',
      '    break;',
      '  default:',
      '    break;',
      '}',
      "const postCaseDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps switch-case ambient module declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'switch (1) {',
      '  case 1:',
      "    reqAlias('./fixtures/other-module.js').default;",
      '    declare module reqAlias {',
      '      const marker: unknown;',
      '    }',
      '    break;',
      '  default:',
      '    break;',
      '}',
      "const postCaseDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps switch-case ambient const declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'switch (1) {',
      '  case 1:',
      "    reqAlias('./fixtures/other-module.js').default;",
      '    declare const reqAlias: (_path: string) => unknown;',
      '    break;',
      '  default:',
      '    break;',
      '}',
      "const postCaseDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps switch-case ambient let declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'switch (1) {',
      '  case 1:',
      "    reqAlias('./fixtures/other-module.js').default;",
      '    declare let reqAlias: (_path: string) => unknown;',
      '    break;',
      '  default:',
      '    break;',
      '}',
      "const postCaseDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps switch-case ambient var declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'switch (1) {',
      '  case 1:',
      "    reqAlias('./fixtures/other-module.js').default;",
      '    declare var reqAlias: (_path: string) => unknown;',
      '    break;',
      '  default:',
      '    break;',
      '}',
      "const postCaseDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('does not leak hoisted switch-case function alias shadowing to outer symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'switch (1) {',
      '  case 1:',
      "    reqAlias('./fixtures/other-module.js').default;",
      '    function reqAlias(_value: unknown) {',
      '      return _value;',
      '    }',
      '    break;',
      '  default:',
      '    break;',
      '}',
      "const postCaseDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('does not leak switch-case class alias declarations to outer symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'switch (1) {',
      '  case 1: {',
      '    class reqAlias {}',
      "    reqAlias('./fixtures/other-module.js').default;",
      '    break;',
      '  }',
      '}',
      "const postCaseDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('does not leak switch-case class alias shadowing before declaration to outer symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'switch (1) {',
      '  case 1:',
      "    reqAlias('./fixtures/other-module.js').default;",
      '    class reqAlias {}',
      '    break;',
      '  default:',
      '    break;',
      '}',
      "const postCaseDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('does not leak switch-case enum alias shadowing before declaration to outer symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'switch (1) {',
      '  case 1:',
      "    reqAlias('./fixtures/other-module.js').default;",
      '    enum reqAlias {',
      '      Marker = 0,',
      '    }',
      '    break;',
      '  default:',
      '    break;',
      '}',
      "const postCaseDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('does not leak switch-case enum alias declarations to outer symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'switch (1) {',
      '  case 1: {',
      '    enum reqAlias {',
      '      Marker = 0,',
      '    }',
      "    reqAlias('./fixtures/other-module.js').default;",
      '    break;',
      '  }',
      '}',
      "const postCaseDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('does not leak switch-case lexical module-source alias shadowing before declaration to outer symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'switch (1) {',
      '  case 1:',
      '    const preDeclarationSymbol = moduleAlias.inner;',
      '    const moduleAlias = { inner: preDeclarationSymbol };',
      '    void moduleAlias;',
      '    break;',
      '  default:',
      '    break;',
      '}',
      'const postCaseDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('inner@./fixtures/guard-module.js');
  });

  it('keeps switch-case type-alias declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'switch (1) {',
      '  case 1:',
      '    const preDeclarationSymbol = moduleAlias.inner;',
      '    type moduleAlias = { inner: unknown };',
      '    void preDeclarationSymbol;',
      '    break;',
      '  default:',
      '    break;',
      '}',
      'const postCaseDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps switch-case interface declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'switch (1) {',
      '  case 1:',
      '    const preDeclarationSymbol = moduleAlias.inner;',
      '    interface moduleAlias {',
      '      inner: unknown;',
      '    }',
      '    void preDeclarationSymbol;',
      '    break;',
      '  default:',
      '    break;',
      '}',
      'const postCaseDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps switch-case ambient class declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'switch (1) {',
      '  case 1:',
      '    const preDeclarationSymbol = moduleAlias.inner;',
      '    declare class moduleAlias {}',
      '    void preDeclarationSymbol;',
      '    break;',
      '  default:',
      '    break;',
      '}',
      'const postCaseDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps switch-case ambient enum declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'switch (1) {',
      '  case 1:',
      '    const preDeclarationSymbol = moduleAlias.inner;',
      '    declare enum moduleAlias {',
      '      Marker = 0,',
      '    }',
      '    void preDeclarationSymbol;',
      '    break;',
      '  default:',
      '    break;',
      '}',
      'const postCaseDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps switch-case ambient function declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'switch (1) {',
      '  case 1:',
      '    const preDeclarationSymbol = moduleAlias.inner;',
      '    declare function moduleAlias(_path: string): unknown;',
      '    void preDeclarationSymbol;',
      '    break;',
      '  default:',
      '    break;',
      '}',
      'const postCaseDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps switch-case ambient namespace declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'switch (1) {',
      '  case 1:',
      '    const preDeclarationSymbol = moduleAlias.inner;',
      '    declare namespace moduleAlias {',
      '      const marker: unknown;',
      '    }',
      '    void preDeclarationSymbol;',
      '    break;',
      '  default:',
      '    break;',
      '}',
      'const postCaseDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps switch-case ambient module declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'switch (1) {',
      '  case 1:',
      '    const preDeclarationSymbol = moduleAlias.inner;',
      '    declare module moduleAlias {',
      '      const marker: unknown;',
      '    }',
      '    void preDeclarationSymbol;',
      '    break;',
      '  default:',
      '    break;',
      '}',
      'const postCaseDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps switch-case ambient const declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'switch (1) {',
      '  case 1:',
      '    const preDeclarationSymbol = moduleAlias.inner;',
      '    declare const moduleAlias: { inner: unknown };',
      '    void preDeclarationSymbol;',
      '    break;',
      '  default:',
      '    break;',
      '}',
      'const postCaseDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps switch-case ambient let declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'switch (1) {',
      '  case 1:',
      '    const preDeclarationSymbol = moduleAlias.inner;',
      '    declare let moduleAlias: { inner: unknown };',
      '    void preDeclarationSymbol;',
      '    break;',
      '  default:',
      '    break;',
      '}',
      'const postCaseDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps switch-case ambient var declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'switch (1) {',
      '  case 1:',
      '    const preDeclarationSymbol = moduleAlias.inner;',
      '    declare var moduleAlias: { inner: unknown };',
      '    void preDeclarationSymbol;',
      '    break;',
      '  default:',
      '    break;',
      '}',
      'const postCaseDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('does not leak hoisted switch-case function module-source alias shadowing to outer symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'switch (1) {',
      '  case 1:',
      '    const preDeclarationSymbol = moduleAlias.inner;',
      '    function moduleAlias(_value: unknown) {',
      '      return _value;',
      '    }',
      '    void preDeclarationSymbol;',
      '    break;',
      '  default:',
      '    break;',
      '}',
      'const postCaseDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('inner@./fixtures/guard-module.js');
  });

  it('does not leak switch-case class module-source alias shadowing before declaration to outer symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'switch (1) {',
      '  case 1:',
      '    const preDeclarationSymbol = moduleAlias.inner;',
      '    class moduleAlias {}',
      '    void preDeclarationSymbol;',
      '    break;',
      '  default:',
      '    break;',
      '}',
      'const postCaseDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('inner@./fixtures/guard-module.js');
  });

  it('does not leak switch-case class module-source alias declarations to outer symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'switch (1) {',
      '  case 1: {',
      '    class moduleAlias {}',
      '    const postDeclarationSymbol = moduleAlias.inner;',
      '    void postDeclarationSymbol;',
      '    break;',
      '  }',
      '  default:',
      '    break;',
      '}',
      'const postCaseDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('inner@./fixtures/guard-module.js');
  });

  it('does not leak switch-case enum module-source alias shadowing before declaration to outer symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'switch (1) {',
      '  case 1:',
      '    const preDeclarationSymbol = moduleAlias.inner;',
      '    enum moduleAlias {',
      '      Marker = 0,',
      '    }',
      '    void preDeclarationSymbol;',
      '    break;',
      '  default:',
      '    break;',
      '}',
      'const postCaseDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('inner@./fixtures/guard-module.js');
  });

  it('does not leak switch-case enum module-source alias declarations to outer symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'switch (1) {',
      '  case 1: {',
      '    enum moduleAlias {',
      '      Marker = 0,',
      '    }',
      '    const postDeclarationSymbol = moduleAlias.inner;',
      '    void postDeclarationSymbol;',
      '    break;',
      '  }',
      '  default:',
      '    break;',
      '}',
      'const postCaseDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('inner@./fixtures/guard-module.js');
  });

  it('does not leak class static-block lexical alias declarations to outer symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'class ShadowContainer {',
      '  static {',
      '    const reqAlias = () => undefined;',
      "    reqAlias('./fixtures/other-module.js').default;",
      '  }',
      '}',
      "const postStaticDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('does not leak class static-block function declaration alias shadowing to outer symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'class ShadowContainer {',
      '  static {',
      '    function reqAlias(_value: unknown) {',
      '      return _value;',
      '    }',
      "    reqAlias('./fixtures/other-module.js').default;",
      '  }',
      '}',
      "const postStaticDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('does not leak class static-block class alias declarations to outer symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'class ShadowContainer {',
      '  static {',
      '    class reqAlias {}',
      "    reqAlias('./fixtures/other-module.js').default;",
      '  }',
      '}',
      "const postStaticDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('does not leak hoisted class static-block function alias shadowing to outer symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'class ShadowContainer {',
      '  static {',
      "    reqAlias('./fixtures/other-module.js').default;",
      '    function reqAlias(_value: unknown) {',
      '      return _value;',
      '    }',
      '  }',
      '}',
      "const postStaticDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('does not leak class static-block lexical alias shadowing before declaration to outer symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'class ShadowContainer {',
      '  static {',
      "    reqAlias('./fixtures/other-module.js').default;",
      '    const reqAlias = () => undefined;',
      '  }',
      '}',
      "const postStaticDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('does not leak class static-block class alias shadowing before declaration to outer symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'class ShadowContainer {',
      '  static {',
      "    reqAlias('./fixtures/other-module.js').default;",
      '    class reqAlias {}',
      '  }',
      '}',
      "const postStaticDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('does not leak class static-block enum alias shadowing before declaration to outer symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'class ShadowContainer {',
      '  static {',
      "    reqAlias('./fixtures/other-module.js').default;",
      '    enum reqAlias {',
      '      Marker = 0,',
      '    }',
      '  }',
      '}',
      "const postStaticDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('does not leak class static-block enum alias declarations to outer symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'class ShadowContainer {',
      '  static {',
      '    enum reqAlias {',
      '      Marker = 0,',
      '    }',
      "    reqAlias('./fixtures/other-module.js').default;",
      '  }',
      '}',
      "const postStaticDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('keeps class static-block type-alias declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'class ShadowContainer {',
      '  static {',
      "    reqAlias('./fixtures/other-module.js').default;",
      '    type reqAlias = (_value: unknown) => unknown;',
      '  }',
      '}',
      "const postStaticDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps class static-block interface declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'class ShadowContainer {',
      '  static {',
      "    reqAlias('./fixtures/other-module.js').default;",
      '    interface reqAlias {',
      '      value: string;',
      '    }',
      '  }',
      '}',
      "const postStaticDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps class static-block ambient class declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'class ShadowContainer {',
      '  static {',
      "    reqAlias('./fixtures/other-module.js').default;",
      '    declare class reqAlias {}',
      '  }',
      '}',
      "const postStaticDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps class static-block ambient enum declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'class ShadowContainer {',
      '  static {',
      "    reqAlias('./fixtures/other-module.js').default;",
      '    declare enum reqAlias {',
      '      Marker = 0,',
      '    }',
      '  }',
      '}',
      "const postStaticDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps class static-block ambient function declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'class ShadowContainer {',
      '  static {',
      "    reqAlias('./fixtures/other-module.js').default;",
      '    declare function reqAlias(_path: string): unknown;',
      '  }',
      '}',
      "const postStaticDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps class static-block ambient namespace declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'class ShadowContainer {',
      '  static {',
      "    reqAlias('./fixtures/other-module.js').default;",
      '    declare namespace reqAlias {',
      '      const marker: unknown;',
      '    }',
      '  }',
      '}',
      "const postStaticDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps class static-block ambient module declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'class ShadowContainer {',
      '  static {',
      "    reqAlias('./fixtures/other-module.js').default;",
      '    declare module reqAlias {',
      '      const marker: unknown;',
      '    }',
      '  }',
      '}',
      "const postStaticDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps class static-block ambient const declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'class ShadowContainer {',
      '  static {',
      "    reqAlias('./fixtures/other-module.js').default;",
      '    declare const reqAlias: (_path: string) => unknown;',
      '  }',
      '}',
      "const postStaticDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps class static-block ambient let declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'class ShadowContainer {',
      '  static {',
      "    reqAlias('./fixtures/other-module.js').default;",
      '    declare let reqAlias: (_path: string) => unknown;',
      '  }',
      '}',
      "const postStaticDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps class static-block ambient var declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'class ShadowContainer {',
      '  static {',
      "    reqAlias('./fixtures/other-module.js').default;",
      '    declare var reqAlias: (_path: string) => unknown;',
      '  }',
      '}',
      "const postStaticDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('does not leak class static-block var alias shadowing to outer symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'class ShadowContainer {',
      '  static {',
      '    var reqAlias = () => undefined;',
      "    reqAlias('./fixtures/other-module.js').default;",
      '  }',
      '}',
      "const postStaticDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('does not leak nested class static-block var alias shadowing to outer symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'class ShadowContainer {',
      '  static {',
      '    if (true) {',
      '      var reqAlias = () => undefined;',
      "      reqAlias('./fixtures/other-module.js').default;",
      '    }',
      '  }',
      '}',
      "const postStaticDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('does not leak class static-block for-of var alias shadowing to outer symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'class ShadowContainer {',
      '  static {',
      '    for (var reqAlias of [() => undefined]) {',
      "      reqAlias('./fixtures/other-module.js').default;",
      '    }',
      '  }',
      '}',
      "const postStaticDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('does not leak class static-block for-in var alias shadowing to outer symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'class ShadowContainer {',
      '  static {',
      '    const aliases: Record<string, (value: unknown) => unknown> = { first: () => undefined };',
      '    for (var aliasKey in aliases) {',
      '      var reqAlias = aliases[aliasKey];',
      "      reqAlias('./fixtures/other-module.js').default;",
      '    }',
      '  }',
      '}',
      "const postStaticDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('does not leak class static-block switch-case var alias shadowing to outer symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'class ShadowContainer {',
      '  static {',
      '    switch (1) {',
      '      case 1:',
      '        var reqAlias = () => undefined;',
      "        reqAlias('./fixtures/other-module.js').default;",
      '        break;',
      '      default:',
      '        break;',
      '    }',
      '  }',
      '}',
      "const postStaticDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('does not leak class static-block for var alias shadowing to outer symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'class ShadowContainer {',
      '  static {',
      '    for (var i = 0; i < 1; i += 1) {',
      '      var reqAlias = () => undefined;',
      "      reqAlias('./fixtures/other-module.js').default;",
      '    }',
      '  }',
      '}',
      "const postStaticDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('does not leak class static-block do-while var alias shadowing to outer symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'class ShadowContainer {',
      '  static {',
      '    do {',
      '      var reqAlias = () => undefined;',
      "      reqAlias('./fixtures/other-module.js').default;",
      '      break;',
      '    } while (false);',
      '  }',
      '}',
      "const postStaticDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('does not leak class static-block while var alias shadowing to outer symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'class ShadowContainer {',
      '  static {',
      '    while (true) {',
      '      var reqAlias = () => undefined;',
      "      reqAlias('./fixtures/other-module.js').default;",
      '      break;',
      '    }',
      '  }',
      '}',
      "const postStaticDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('does not leak class static-block try-block var alias shadowing to outer symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'class ShadowContainer {',
      '  static {',
      '    try {',
      '      var reqAlias = () => undefined;',
      "      reqAlias('./fixtures/other-module.js').default;",
      '    } catch (error) {',
      '      void error;',
      '    }',
      '  }',
      '}',
      "const postStaticDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('does not leak class static-block catch-block var alias shadowing to outer symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'class ShadowContainer {',
      '  static {',
      '    try {',
      "      throw new Error('boom');",
      '    } catch (error) {',
      '      var reqAlias = () => undefined;',
      "      reqAlias('./fixtures/other-module.js').default;",
      '      void error;',
      '    }',
      '  }',
      '}',
      "const postStaticDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('does not leak class static-block finally-block var alias shadowing to outer symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'class ShadowContainer {',
      '  static {',
      '    try {',
      '      void 0;',
      '    } finally {',
      '      var reqAlias = () => undefined;',
      "      reqAlias('./fixtures/other-module.js').default;",
      '    }',
      '  }',
      '}',
      "const postStaticDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('applies class static-block assignments to outer require aliases for symbol sources', () => {
    const source = [
      "const guardDefault = require('./fixtures/guard-module.js').default;",
      'let reqAlias: any = require;',
      'class ShadowContainer {',
      '  static {',
      '    reqAlias = () => undefined;',
      '  }',
      '}',
      "const shadowedDefault = reqAlias('./fixtures/other-module.js').default;",
      'void shadowedDefault;',
      'void guardDefault;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('applies class static-block require assignments to outer aliases for symbol sources', () => {
    const source = [
      'let reqAlias: any;',
      'class ShadowContainer {',
      '  static {',
      '    reqAlias = require;',
      '  }',
      '}',
      "const postStaticDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('applies class static-block destructuring assignments to outer require aliases for symbol sources', () => {
    const source = [
      "const guardDefault = require('./fixtures/guard-module.js').default;",
      'let reqAlias: any = require;',
      'class ShadowContainer {',
      '  static {',
      '    ({ reqAlias } = { reqAlias: () => undefined });',
      '  }',
      '}',
      "const shadowedDefault = reqAlias('./fixtures/other-module.js').default;",
      'void shadowedDefault;',
      'void guardDefault;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('applies class static-block assignments to outer module-source aliases for symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'class ShadowContainer {',
      '  static {',
      "    moduleAlias = require('./fixtures/other-module.js');",
      '  }',
      '}',
      'const postStaticDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('applies class static-block require-call assignments to outer module-source aliases for symbol sources', () => {
    const source = [
      'let moduleAlias: any;',
      'class ShadowContainer {',
      '  static {',
      "    moduleAlias = require('./fixtures/guard-module.js');",
      '  }',
      '}',
      'const postStaticDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('applies class static-block destructuring assignments to outer module-source aliases for symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'class ShadowContainer {',
      '  static {',
      "    ({ moduleAlias } = { moduleAlias: require('./fixtures/other-module.js') });",
      '  }',
      '}',
      'const postStaticDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('applies nested class static-block assignments to outer module-source aliases for symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'class ShadowContainer {',
      '  static {',
      '    if (true) {',
      "      moduleAlias = require('./fixtures/other-module.js');",
      '    }',
      '  }',
      '}',
      'const postStaticDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/other-module.js');
    expect(references).to.not.include('default@./fixtures/guard-module.js');
  });

  it('does not leak nested class static-block var module-source aliases to outer symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'class ShadowContainer {',
      '  static {',
      '    if (true) {',
      "      var moduleAlias = require('./fixtures/other-module.js');",
      '      void moduleAlias;',
      '    }',
      '  }',
      '}',
      'const postStaticDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('does not leak class static-block var module-source aliases to outer symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'class ShadowContainer {',
      '  static {',
      "    var moduleAlias = require('./fixtures/other-module.js');",
      '    void moduleAlias;',
      '  }',
      '}',
      'const postStaticDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('does not leak class static-block do-while var module-source aliases to outer symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'class ShadowContainer {',
      '  static {',
      '    do {',
      "      var moduleAlias = require('./fixtures/other-module.js');",
      '      void moduleAlias;',
      '      break;',
      '    } while (false);',
      '  }',
      '}',
      'const postStaticDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('does not leak class static-block while var module-source aliases to outer symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'class ShadowContainer {',
      '  static {',
      '    while (true) {',
      "      var moduleAlias = require('./fixtures/other-module.js');",
      '      void moduleAlias;',
      '      break;',
      '    }',
      '  }',
      '}',
      'const postStaticDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('does not leak class static-block lexical module-source alias shadowing before declaration to outer symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'class ShadowContainer {',
      '  static {',
      '    const preDeclarationSymbol = moduleAlias.inner;',
      '    const moduleAlias = { inner: preDeclarationSymbol };',
      '    void moduleAlias;',
      '  }',
      '}',
      'const postStaticDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('inner@./fixtures/guard-module.js');
  });

  it('keeps class static-block type-alias declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'class ShadowContainer {',
      '  static {',
      '    const preDeclarationSymbol = moduleAlias.inner;',
      '    type moduleAlias = { inner: unknown };',
      '    void preDeclarationSymbol;',
      '  }',
      '}',
      'const postStaticDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps class static-block interface declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'class ShadowContainer {',
      '  static {',
      '    const preDeclarationSymbol = moduleAlias.inner;',
      '    interface moduleAlias {',
      '      inner: unknown;',
      '    }',
      '    void preDeclarationSymbol;',
      '  }',
      '}',
      'const postStaticDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps class static-block ambient class declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'class ShadowContainer {',
      '  static {',
      '    const preDeclarationSymbol = moduleAlias.inner;',
      '    declare class moduleAlias {}',
      '    void preDeclarationSymbol;',
      '  }',
      '}',
      'const postStaticDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps class static-block ambient enum declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'class ShadowContainer {',
      '  static {',
      '    const preDeclarationSymbol = moduleAlias.inner;',
      '    declare enum moduleAlias {',
      '      Marker = 0,',
      '    }',
      '    void preDeclarationSymbol;',
      '  }',
      '}',
      'const postStaticDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps class static-block ambient function declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'class ShadowContainer {',
      '  static {',
      '    const preDeclarationSymbol = moduleAlias.inner;',
      '    declare function moduleAlias(_path: string): unknown;',
      '    void preDeclarationSymbol;',
      '  }',
      '}',
      'const postStaticDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps class static-block ambient namespace declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'class ShadowContainer {',
      '  static {',
      '    const preDeclarationSymbol = moduleAlias.inner;',
      '    declare namespace moduleAlias {',
      '      const marker: unknown;',
      '    }',
      '    void preDeclarationSymbol;',
      '  }',
      '}',
      'const postStaticDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps class static-block ambient module declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'class ShadowContainer {',
      '  static {',
      '    const preDeclarationSymbol = moduleAlias.inner;',
      '    declare module moduleAlias {',
      '      const marker: unknown;',
      '    }',
      '    void preDeclarationSymbol;',
      '  }',
      '}',
      'const postStaticDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps class static-block ambient const declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'class ShadowContainer {',
      '  static {',
      '    const preDeclarationSymbol = moduleAlias.inner;',
      '    declare const moduleAlias: { inner: unknown };',
      '    void preDeclarationSymbol;',
      '  }',
      '}',
      'const postStaticDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps class static-block ambient let declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'class ShadowContainer {',
      '  static {',
      '    const preDeclarationSymbol = moduleAlias.inner;',
      '    declare let moduleAlias: { inner: unknown };',
      '    void preDeclarationSymbol;',
      '  }',
      '}',
      'const postStaticDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps class static-block ambient var declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'class ShadowContainer {',
      '  static {',
      '    const preDeclarationSymbol = moduleAlias.inner;',
      '    declare var moduleAlias: { inner: unknown };',
      '    void preDeclarationSymbol;',
      '  }',
      '}',
      'const postStaticDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('does not leak hoisted class static-block function module-source alias shadowing to outer symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'class ShadowContainer {',
      '  static {',
      '    const preDeclarationSymbol = moduleAlias.inner;',
      '    function moduleAlias(_value: unknown) {',
      '      return _value;',
      '    }',
      '    void preDeclarationSymbol;',
      '  }',
      '}',
      'const postStaticDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('inner@./fixtures/guard-module.js');
  });

  it('does not leak class static-block class module-source alias shadowing before declaration to outer symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'class ShadowContainer {',
      '  static {',
      '    const preDeclarationSymbol = moduleAlias.inner;',
      '    class moduleAlias {}',
      '    void preDeclarationSymbol;',
      '  }',
      '}',
      'const postStaticDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('inner@./fixtures/guard-module.js');
  });

  it('does not leak class static-block class module-source alias declarations to outer symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'class ShadowContainer {',
      '  static {',
      '    class moduleAlias {}',
      '    const postDeclarationSymbol = moduleAlias.inner;',
      '    void postDeclarationSymbol;',
      '  }',
      '}',
      'const postStaticDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('inner@./fixtures/guard-module.js');
  });

  it('does not leak class static-block enum module-source alias shadowing before declaration to outer symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'class ShadowContainer {',
      '  static {',
      '    const preDeclarationSymbol = moduleAlias.inner;',
      '    enum moduleAlias {',
      '      Marker = 0,',
      '    }',
      '    void preDeclarationSymbol;',
      '  }',
      '}',
      'const postStaticDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('inner@./fixtures/guard-module.js');
  });

  it('does not leak class static-block enum module-source alias declarations to outer symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'class ShadowContainer {',
      '  static {',
      '    enum moduleAlias {',
      '      Marker = 0,',
      '    }',
      '    const postDeclarationSymbol = moduleAlias.inner;',
      '    void postDeclarationSymbol;',
      '  }',
      '}',
      'const postStaticDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('inner@./fixtures/guard-module.js');
  });

  it('does not leak namespace lexical alias declarations to outer symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'namespace ShadowSpace {',
      '  const reqAlias = () => undefined;',
      "  reqAlias('./fixtures/other-module.js').default;",
      '}',
      "const postNamespaceDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('does not leak namespace lexical alias shadowing before declaration to outer symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'namespace ShadowSpace {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  const reqAlias = () => undefined;',
      '}',
      "const postNamespaceDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('keeps namespace type-alias declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'namespace ShadowSpace {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  type reqAlias = (_value: unknown) => unknown;',
      '}',
      "const postNamespaceDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps namespace interface declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'namespace ShadowSpace {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  interface reqAlias {',
      '    value: string;',
      '  }',
      '}',
      "const postNamespaceDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps namespace ambient class declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'namespace ShadowNamespace {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  declare class reqAlias {}',
      '}',
      "const postNamespaceDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps namespace ambient enum declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'namespace ShadowNamespace {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  declare enum reqAlias {',
      '    Marker = 0,',
      '  }',
      '}',
      "const postNamespaceDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps namespace ambient function declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'namespace ShadowNamespace {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  declare function reqAlias(_path: string): unknown;',
      '}',
      "const postNamespaceDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps namespace ambient namespace declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'namespace ShadowNamespace {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  declare namespace reqAlias {',
      '    const marker: unknown;',
      '  }',
      '}',
      "const postNamespaceDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps namespace ambient module declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'namespace ShadowNamespace {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  declare module reqAlias {',
      '    const marker: unknown;',
      '  }',
      '}',
      "const postNamespaceDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps namespace ambient const declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'namespace ShadowNamespace {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  declare const reqAlias: (_path: string) => unknown;',
      '}',
      "const postNamespaceDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps namespace ambient let declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'namespace ShadowNamespace {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  declare let reqAlias: (_path: string) => unknown;',
      '}',
      "const postNamespaceDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps namespace ambient var declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'namespace ShadowNamespace {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  declare var reqAlias: (_path: string) => unknown;',
      '}',
      "const postNamespaceDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('does not leak hoisted namespace function alias shadowing to outer symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'namespace ShadowSpace {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  function reqAlias(_value: unknown) {',
      '    return _value;',
      '  }',
      '}',
      "const postNamespaceDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('does not leak namespace class alias shadowing before declaration to outer symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'namespace ShadowSpace {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  class reqAlias {}',
      '}',
      "const postNamespaceDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('does not leak namespace class alias declarations to outer symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'namespace ShadowSpace {',
      '  class reqAlias {}',
      "  reqAlias('./fixtures/other-module.js').default;",
      '}',
      "const postNamespaceDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('does not leak namespace enum alias shadowing before declaration to outer symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'namespace ShadowSpace {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  enum reqAlias {',
      '    Marker = 0,',
      '  }',
      '}',
      "const postNamespaceDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('does not leak namespace enum alias declarations to outer symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'namespace ShadowSpace {',
      '  enum reqAlias {',
      '    Marker = 0,',
      '  }',
      "  reqAlias('./fixtures/other-module.js').default;",
      '}',
      "const postNamespaceDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('does not leak namespace lexical module-source alias shadowing before declaration to outer symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'namespace ShadowSpace {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  const moduleAlias = { inner: preDeclarationSymbol };',
      '  void moduleAlias;',
      '}',
      'const postNamespaceDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('inner@./fixtures/guard-module.js');
  });

  it('keeps namespace type-alias declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'namespace ShadowSpace {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  type moduleAlias = { inner: unknown };',
      '  void preDeclarationSymbol;',
      '}',
      'const postNamespaceDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps namespace interface declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'namespace ShadowSpace {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  interface moduleAlias {',
      '    inner: unknown;',
      '  }',
      '  void preDeclarationSymbol;',
      '}',
      'const postNamespaceDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps namespace ambient class declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'namespace ShadowNamespace {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  declare class moduleAlias {}',
      '  void preDeclarationSymbol;',
      '}',
      'const postNamespaceDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps namespace ambient enum declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'namespace ShadowNamespace {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  declare enum moduleAlias {',
      '    Marker = 0,',
      '  }',
      '  void preDeclarationSymbol;',
      '}',
      'const postNamespaceDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps namespace ambient function declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'namespace ShadowNamespace {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  declare function moduleAlias(_path: string): unknown;',
      '  void preDeclarationSymbol;',
      '}',
      'const postNamespaceDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps namespace ambient namespace declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'namespace ShadowNamespace {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  declare namespace moduleAlias {',
      '    const marker: unknown;',
      '  }',
      '  void preDeclarationSymbol;',
      '}',
      'const postNamespaceDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps namespace ambient module declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'namespace ShadowNamespace {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  declare module moduleAlias {',
      '    const marker: unknown;',
      '  }',
      '  void preDeclarationSymbol;',
      '}',
      'const postNamespaceDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps namespace ambient const declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'namespace ShadowNamespace {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  declare const moduleAlias: { inner: unknown };',
      '  void preDeclarationSymbol;',
      '}',
      'const postNamespaceDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps namespace ambient let declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'namespace ShadowNamespace {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  declare let moduleAlias: { inner: unknown };',
      '  void preDeclarationSymbol;',
      '}',
      'const postNamespaceDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps namespace ambient var declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'namespace ShadowNamespace {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  declare var moduleAlias: { inner: unknown };',
      '  void preDeclarationSymbol;',
      '}',
      'const postNamespaceDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('does not leak hoisted namespace function module-source alias shadowing to outer symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'namespace ShadowSpace {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  function moduleAlias(_value: unknown) {',
      '    return _value;',
      '  }',
      '  void preDeclarationSymbol;',
      '}',
      'const postNamespaceDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('inner@./fixtures/guard-module.js');
  });

  it('does not leak namespace class module-source alias shadowing before declaration to outer symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'namespace ShadowSpace {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  class moduleAlias {}',
      '  void preDeclarationSymbol;',
      '}',
      'const postNamespaceDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('inner@./fixtures/guard-module.js');
  });

  it('does not leak namespace class module-source alias declarations to outer symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'namespace ShadowSpace {',
      '  class moduleAlias {}',
      '  const postDeclarationSymbol = moduleAlias.inner;',
      '  void postDeclarationSymbol;',
      '}',
      'const postNamespaceDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('inner@./fixtures/guard-module.js');
  });

  it('does not leak namespace enum module-source alias shadowing before declaration to outer symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'namespace ShadowSpace {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  enum moduleAlias {',
      '    Marker = 0,',
      '  }',
      '  void preDeclarationSymbol;',
      '}',
      'const postNamespaceDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('inner@./fixtures/guard-module.js');
  });

  it('does not leak namespace enum module-source alias declarations to outer symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'namespace ShadowSpace {',
      '  enum moduleAlias {',
      '    Marker = 0,',
      '  }',
      '  const postDeclarationSymbol = moduleAlias.inner;',
      '  void postDeclarationSymbol;',
      '}',
      'const postNamespaceDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('inner@./fixtures/guard-module.js');
  });

  it('does not leak labeled lexical alias declarations to outer symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'label: {',
      '  const reqAlias = () => undefined;',
      "  reqAlias('./fixtures/other-module.js').default;",
      '}',
      "const postLabelDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('does not leak labeled lexical alias shadowing before declaration to outer symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'label: {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  const reqAlias = () => undefined;',
      '}',
      "const postLabelDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('keeps labeled type-alias declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'label: {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  type reqAlias = (_value: unknown) => unknown;',
      '}',
      "const postLabelDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps labeled interface declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'label: {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  interface reqAlias {',
      '    value: string;',
      '  }',
      '}',
      "const postLabelDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps labeled ambient class declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'label: {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  declare class reqAlias {}',
      '}',
      "const postLabelDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps labeled ambient enum declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'label: {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  declare enum reqAlias {',
      '    Marker = 0,',
      '  }',
      '}',
      "const postLabelDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps labeled ambient function declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'label: {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  declare function reqAlias(_path: string): unknown;',
      '}',
      "const postLabelDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps labeled ambient namespace declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'label: {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  declare namespace reqAlias {',
      '    const marker: unknown;',
      '  }',
      '}',
      "const postLabelDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps labeled ambient module declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'label: {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  declare module reqAlias {',
      '    const marker: unknown;',
      '  }',
      '}',
      "const postLabelDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps labeled ambient const declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'label: {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  declare const reqAlias: (_path: string) => unknown;',
      '}',
      "const postLabelDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps labeled ambient let declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'label: {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  declare let reqAlias: (_path: string) => unknown;',
      '}',
      "const postLabelDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps labeled ambient var declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'label: {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  declare var reqAlias: (_path: string) => unknown;',
      '}',
      "const postLabelDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('does not leak hoisted labeled function alias shadowing to outer symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'label: {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  function reqAlias(_value: unknown) {',
      '    return _value;',
      '  }',
      '}',
      "const postLabelDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('does not leak labeled class alias shadowing before declaration to outer symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'label: {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  class reqAlias {}',
      '}',
      "const postLabelDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('does not leak labeled class alias declarations to outer symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'label: {',
      '  class reqAlias {}',
      "  reqAlias('./fixtures/other-module.js').default;",
      '}',
      "const postLabelDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('does not leak labeled enum alias shadowing before declaration to outer symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'label: {',
      "  reqAlias('./fixtures/other-module.js').default;",
      '  enum reqAlias {',
      '    Marker = 0,',
      '  }',
      '}',
      "const postLabelDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('does not leak labeled enum alias declarations to outer symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      'label: {',
      '  enum reqAlias {',
      '    Marker = 0,',
      '  }',
      "  reqAlias('./fixtures/other-module.js').default;",
      '}',
      "const postLabelDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('does not leak labeled lexical module-source alias shadowing before declaration to outer symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'label: {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  const moduleAlias = { inner: preDeclarationSymbol };',
      '  void moduleAlias;',
      '}',
      'const postLabelDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('inner@./fixtures/guard-module.js');
  });

  it('keeps labeled type-alias declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'label: {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  type moduleAlias = { inner: unknown };',
      '  void preDeclarationSymbol;',
      '}',
      'const postLabelDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps labeled interface declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'label: {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  interface moduleAlias {',
      '    inner: unknown;',
      '  }',
      '  void preDeclarationSymbol;',
      '}',
      'const postLabelDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps labeled ambient class declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'label: {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  declare class moduleAlias {}',
      '  void preDeclarationSymbol;',
      '}',
      'const postLabelDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps labeled ambient enum declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'label: {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  declare enum moduleAlias {',
      '    Marker = 0,',
      '  }',
      '  void preDeclarationSymbol;',
      '}',
      'const postLabelDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps labeled ambient function declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'label: {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  declare function moduleAlias(_path: string): unknown;',
      '  void preDeclarationSymbol;',
      '}',
      'const postLabelDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps labeled ambient namespace declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'label: {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  declare namespace moduleAlias {',
      '    const marker: unknown;',
      '  }',
      '  void preDeclarationSymbol;',
      '}',
      'const postLabelDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps labeled ambient module declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'label: {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  declare module moduleAlias {',
      '    const marker: unknown;',
      '  }',
      '  void preDeclarationSymbol;',
      '}',
      'const postLabelDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps labeled ambient const declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'label: {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  declare const moduleAlias: { inner: unknown };',
      '  void preDeclarationSymbol;',
      '}',
      'const postLabelDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps labeled ambient let declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'label: {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  declare let moduleAlias: { inner: unknown };',
      '  void preDeclarationSymbol;',
      '}',
      'const postLabelDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps labeled ambient var declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'label: {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  declare var moduleAlias: { inner: unknown };',
      '  void preDeclarationSymbol;',
      '}',
      'const postLabelDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('does not leak hoisted labeled function module-source alias shadowing to outer symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'label: {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  function moduleAlias(_value: unknown) {',
      '    return _value;',
      '  }',
      '  void preDeclarationSymbol;',
      '}',
      'const postLabelDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('inner@./fixtures/guard-module.js');
  });

  it('does not leak labeled class module-source alias shadowing before declaration to outer symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'label: {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  class moduleAlias {}',
      '  void preDeclarationSymbol;',
      '}',
      'const postLabelDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('inner@./fixtures/guard-module.js');
  });

  it('does not leak labeled class module-source alias declarations to outer symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'label: {',
      '  class moduleAlias {}',
      '  const postDeclarationSymbol = moduleAlias.inner;',
      '  void postDeclarationSymbol;',
      '}',
      'const postLabelDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('inner@./fixtures/guard-module.js');
  });

  it('does not leak labeled enum module-source alias shadowing before declaration to outer symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'label: {',
      '  const preDeclarationSymbol = moduleAlias.inner;',
      '  enum moduleAlias {',
      '    Marker = 0,',
      '  }',
      '  void preDeclarationSymbol;',
      '}',
      'const postLabelDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('inner@./fixtures/guard-module.js');
  });

  it('does not leak labeled enum module-source alias declarations to outer symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'label: {',
      '  enum moduleAlias {',
      '    Marker = 0,',
      '  }',
      '  const postDeclarationSymbol = moduleAlias.inner;',
      '  void postDeclarationSymbol;',
      '}',
      'const postLabelDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('inner@./fixtures/guard-module.js');
  });

  it('keeps labeled var module-source alias declarations made inside block scopes', () => {
    const source = [
      'let moduleAlias: any;',
      'label: {',
      "  var moduleAlias = require('./fixtures/guard-module.js');",
      '}',
      'const postLabelDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('does not treat top-level function declaration named require as module-sourced', () => {
    const source = [
      "const preShadowDefault = require('./fixtures/guard-module.js').default;",
      'function require(_value: unknown) {',
      '  return _value;',
      '}',
      "const postShadowDefault = require('./fixtures/other-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('does not treat top-level class declaration named require alias as module-sourced', () => {
    const source = [
      'const reqAlias = require;',
      "const preShadowDefault = reqAlias('./fixtures/guard-module.js').default;",
      'class reqAlias {}',
      "const postShadowDefault = reqAlias('./fixtures/other-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('does not treat top-level enum declaration named require alias as module-sourced', () => {
    const source = [
      'const reqAlias = require;',
      "const preShadowDefault = reqAlias('./fixtures/guard-module.js').default;",
      'enum reqAlias { Primary = 1 }',
      "const postShadowDefault = reqAlias('./fixtures/other-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('keeps top-level ambient class declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      "const preAmbientDefault = reqAlias('./fixtures/guard-module.js').default;",
      'declare class reqAlias {}',
      "const postAmbientDefault = reqAlias('./fixtures/other-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps top-level ambient enum declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      "const preAmbientDefault = reqAlias('./fixtures/guard-module.js').default;",
      'declare enum reqAlias {',
      '  Primary = 1,',
      '}',
      "const postAmbientDefault = reqAlias('./fixtures/other-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps top-level ambient function declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      "const preAmbientDefault = reqAlias('./fixtures/guard-module.js').default;",
      'declare function reqAlias(_value: unknown): unknown;',
      "const postAmbientDefault = reqAlias('./fixtures/other-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps top-level ambient const declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      "const preAmbientDefault = reqAlias('./fixtures/guard-module.js').default;",
      'declare const reqAlias: (_value: unknown) => unknown;',
      "const postAmbientDefault = reqAlias('./fixtures/other-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps top-level ambient var declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      "const preAmbientDefault = reqAlias('./fixtures/guard-module.js').default;",
      'declare var reqAlias: (_value: unknown) => unknown;',
      "const postAmbientDefault = reqAlias('./fixtures/other-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps top-level ambient let declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      "const preAmbientDefault = reqAlias('./fixtures/guard-module.js').default;",
      'declare let reqAlias: (_value: unknown) => unknown;',
      "const postAmbientDefault = reqAlias('./fixtures/other-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps top-level ambient namespace declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      "const preAmbientDefault = reqAlias('./fixtures/guard-module.js').default;",
      'declare namespace reqAlias {',
      '  const marker: unknown;',
      '}',
      "const postAmbientDefault = reqAlias('./fixtures/other-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps top-level ambient module declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      "const preAmbientDefault = reqAlias('./fixtures/guard-module.js').default;",
      'declare module reqAlias {',
      '  const marker: unknown;',
      '}',
      "const postAmbientDefault = reqAlias('./fixtures/other-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps top-level type-alias declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      "const preTypeAliasDefault = reqAlias('./fixtures/guard-module.js').default;",
      'type reqAlias = (_value: unknown) => unknown;',
      "const postTypeAliasDefault = reqAlias('./fixtures/other-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps top-level interface declarations from shadowing runtime require aliases in symbol sources', () => {
    const source = [
      'const reqAlias = require;',
      "const preInterfaceDefault = reqAlias('./fixtures/guard-module.js').default;",
      'interface reqAlias {',
      '  marker: unknown;',
      '}',
      "const postInterfaceDefault = reqAlias('./fixtures/other-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('keeps top-level ambient class declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const preAmbientInner = moduleAlias.inner;',
      'declare class moduleAlias {}',
      'const postAmbientInner = moduleAlias.inner;',
      'void preAmbientInner;',
      'void postAmbientInner;',
      'const postAmbientDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps top-level ambient enum declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const preAmbientInner = moduleAlias.inner;',
      'declare enum moduleAlias {',
      '  Primary = 1,',
      '}',
      'const postAmbientInner = moduleAlias.inner;',
      'void preAmbientInner;',
      'void postAmbientInner;',
      'const postAmbientDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps top-level ambient function declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const preAmbientInner = moduleAlias.inner;',
      'declare function moduleAlias(_value: unknown): unknown;',
      'const postAmbientInner = moduleAlias.inner;',
      'void preAmbientInner;',
      'void postAmbientInner;',
      'const postAmbientDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps top-level ambient const declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const preAmbientInner = moduleAlias.inner;',
      'declare const moduleAlias: { inner: unknown };',
      'const postAmbientInner = moduleAlias.inner;',
      'void preAmbientInner;',
      'void postAmbientInner;',
      'const postAmbientDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps top-level ambient var declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const preAmbientInner = moduleAlias.inner;',
      'declare var moduleAlias: { inner: unknown };',
      'const postAmbientInner = moduleAlias.inner;',
      'void preAmbientInner;',
      'void postAmbientInner;',
      'const postAmbientDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps top-level ambient let declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const preAmbientInner = moduleAlias.inner;',
      'declare let moduleAlias: { inner: unknown };',
      'const postAmbientInner = moduleAlias.inner;',
      'void preAmbientInner;',
      'void postAmbientInner;',
      'const postAmbientDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps top-level ambient namespace declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const preAmbientInner = moduleAlias.inner;',
      'declare namespace moduleAlias {',
      '  const marker: unknown;',
      '}',
      'const postAmbientInner = moduleAlias.inner;',
      'void preAmbientInner;',
      'void postAmbientInner;',
      'const postAmbientDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps top-level ambient module declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const preAmbientInner = moduleAlias.inner;',
      'declare module moduleAlias {',
      '  const marker: unknown;',
      '}',
      'const postAmbientInner = moduleAlias.inner;',
      'void preAmbientInner;',
      'void postAmbientInner;',
      'const postAmbientDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps top-level type-alias declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const preTypeAliasInner = moduleAlias.inner;',
      'type moduleAlias = { inner: unknown };',
      'const postTypeAliasInner = moduleAlias.inner;',
      'void preTypeAliasInner;',
      'void postTypeAliasInner;',
      'const postTypeAliasDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('keeps top-level interface declarations from shadowing module-source aliases in symbol sources', () => {
    const source = [
      "let moduleAlias: any = require('./fixtures/guard-module.js');",
      'const preInterfaceInner = moduleAlias.inner;',
      'interface moduleAlias {',
      '  marker: unknown;',
      '}',
      'const postInterfaceInner = moduleAlias.inner;',
      'void preInterfaceInner;',
      'void postInterfaceInner;',
      'const postInterfaceDefault = moduleAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('inner@./fixtures/guard-module.js');
  });

  it('does not treat block-scoped function shadowing of require alias as module-sourced', () => {
    const source = [
      'const reqAlias = require;',
      '{',
      '  function reqAlias(_value: unknown) {',
      '    return _value;',
      '  }',
      "  const innerDefault = reqAlias('./fixtures/other-module.js').default;",
      '}',
      "const outerDefault = reqAlias('./fixtures/guard-module.js').default;",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.not.include('default@./fixtures/other-module.js');
  });

  it('tracks default symbol references through logical wrappers', () => {
    const source = [
      'declare const maybeAlias: unknown;',
      'declare const maybeNull: unknown;',
      "const logicalOrAlias = maybeAlias || require('./fixtures/guard-module.js');",
      "const logicalAndAlias = true && require('./fixtures/guard-module.js');",
      "const nullishAlias = maybeNull ?? require('./fixtures/guard-module.js');",
      'const logicalOrDefault = logicalOrAlias.default;',
      "const logicalAndDefault = logicalAndAlias['default'];",
      'const nullishDefault = nullishAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('tracks default symbol references for mixed-source logical wrappers', () => {
    const source = [
      "import * as otherModule from './fixtures/other-module.js';",
      "const mixedAlias = otherModule || require('./fixtures/guard-module.js');",
      'const mixedDefault = mixedAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('tracks default symbol references for mixed-source conditional wrappers', () => {
    const source = [
      "import * as otherModule from './fixtures/other-module.js';",
      'declare const useOtherModule: boolean;',
      "const mixedAlias = useOtherModule ? otherModule : require('./fixtures/guard-module.js');",
      'const mixedDefault = mixedAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
    expect(references).to.include('default@./fixtures/other-module.js');
  });

  it('tracks default symbol references through conditional wrappers', () => {
    const source = [
      'declare const useModuleAlias: boolean;',
      'declare const fallbackAlias: unknown;',
      "const conditionalAlias = useModuleAlias ? require('./fixtures/guard-module.js') : fallbackAlias;",
      'const conditionalDefault = conditionalAlias.default;',
      "const inlineConditionalDefault = (useModuleAlias ? require('./fixtures/guard-module.js') : fallbackAlias)['default'];",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('tracks default symbol references through logical assignment aliases', () => {
    const source = [
      'let alias: unknown;',
      "alias ||= require('./fixtures/guard-module.js');",
      'const orAssignmentDefault = alias.default;',
      "alias &&= require('./fixtures/guard-module.js');",
      "const andAssignmentDefault = alias['default'];",
      "alias ??= require('./fixtures/guard-module.js');",
      'const nullishAssignmentDefault = alias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('tracks default symbol references through optional chaining access', () => {
    const source = [
      "import * as infra from './fixtures/guard-module.js';",
      'const optionalDefault = infra?.default;',
      "const optionalElementDefault = infra?.['default'];",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('tracks default symbol references from template-literal specifiers', () => {
    const source = [
      'const templateAlias = require(`./fixtures/guard-module.js`);',
      'const templateDefault = templateAlias.default;',
      "const inlineTemplateDefault = require(`./fixtures/guard-module.js`)['default'];",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('tracks default symbol references through object-literal wrappers', () => {
    const source = [
      "const wrapped = { sdk: require('./fixtures/guard-module.js') };",
      'const wrappedAlias = wrapped.sdk;',
      'const wrappedDefault = wrappedAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('tracks default symbol references through array-literal wrappers', () => {
    const source = [
      "const wrapped = [require('./fixtures/guard-module.js')];",
      'const wrappedAlias = wrapped[0];',
      'const wrappedDefault = wrappedAlias.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('tracks default symbol references through nested binding patterns', () => {
    const source = [
      "const { nested: { default: nestedDefault }, default: topDefault } = require('./fixtures/guard-module.js');",
      'const nestedAliasDefault = nestedDefault.default;',
      "const topAliasDefault = topDefault['default'];",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('tracks default symbol references through array binding patterns', () => {
    const source = [
      "const [{ default: arrayDefault }] = require('./fixtures/guard-module.js');",
      'const arrayAliasDefault = arrayDefault.default;',
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('tracks default symbol references through destructuring assignment patterns', () => {
    const source = [
      'let directAlias: unknown;',
      'let nestedAlias: unknown;',
      "({ default: directAlias, nested: { default: nestedAlias } } = require('./fixtures/guard-module.js'));",
      "([{ default: directAlias }] = require('./fixtures/guard-module.js'));",
      'const directAliasDefault = directAlias.default;',
      "const nestedAliasDefault = nestedAlias['default'];",
    ].join('\n');
    const references = collectSymbolSourceReferences(source, 'fixture.ts').map(
      (reference) => `${reference.symbol}@${reference.source}`,
    );
    expect(references).to.include('default@./fixtures/guard-module.js');
  });

  it('prevents sdk source imports from infra paths', () => {
    const sourceFilePaths = collectSdkSourceFilePaths(
      path.resolve(process.cwd(), 'src'),
    );
    const infraModuleReferences: string[] = [];
    for (const sourceFilePath of sourceFilePaths) {
      const contents = fs.readFileSync(sourceFilePath, 'utf8');
      const references = collectModuleSpecifierReferences(
        contents,
        sourceFilePath,
      );
      for (const reference of references) {
        if (!isInfraModuleSpecifier(reference.source)) continue;
        infraModuleReferences.push(
          `${path.relative(process.cwd(), reference.filePath)} -> ${reference.source}`,
        );
      }
    }
    expect(
      infraModuleReferences,
      'Found sdk module specifier references to infra paths/packages',
    ).to.deep.equal([]);

    expectNoRipgrepMatches(
      String.raw`(?:from ['"]|require\(['"]|import\(['"])(?:@hyperlane-xyz/infra|.*typescript/infra|.*\/infra\/|\.\.\/\.\.\/infra)`,
      'sdk imports that reference infra paths or packages',
    );
  });

  it('prevents default imports from infra package entrypoint', () => {
    const sourceFilePaths = collectSdkSourceFilePaths(
      path.resolve(process.cwd(), 'src'),
    );
    const defaultInfraImports = collectDefaultImportsFromModule(
      sourceFilePaths,
      '@hyperlane-xyz/infra',
    );
    expect(defaultInfraImports).to.deep.equal([]);

    expectNoRipgrepMatches(
      String.raw`(?:import\s+[A-Za-z_$][A-Za-z0-9_$]*\s+from\s+['"]@hyperlane-xyz/infra['"]|import\s+(?:type\s+)?\{\s*(?:type\s+)?default(?:\s+as\s+[A-Za-z_$][A-Za-z0-9_$]*)?\s*\}\s*from\s+['"]@hyperlane-xyz/infra['"])`,
      'default imports from @hyperlane-xyz/infra',
    );
  });

  it('prevents infra default property access via namespace aliases', () => {
    const sourceFilePaths = collectSdkSourceFilePaths(
      path.resolve(process.cwd(), 'src'),
    );
    const defaultInfraReferences = collectDefaultSymbolReferencesFromModule(
      sourceFilePaths,
      '@hyperlane-xyz/infra',
    );
    expect(defaultInfraReferences).to.deep.equal([]);

    expectNoRipgrepMatches(
      String.raw`require\(['"]@hyperlane-xyz/infra['"]\)\s*(?:\.default|\[\s*['"]default['"]\s*\])`,
      'direct default property access from @hyperlane-xyz/infra',
    );
  });

  it('keeps gnosis safe helpers exported from sdk index', () => {
    const indexPath = path.resolve(process.cwd(), 'src/index.ts');
    const gnosisSafePath = path.resolve(
      process.cwd(),
      'src/utils/gnosisSafe.ts',
    );
    const indexText = fs.readFileSync(indexPath, 'utf8');
    const gnosisSafeText = fs.readFileSync(gnosisSafePath, 'utf8');
    expect(
      hasDefaultExportInSourceFile(gnosisSafeText, gnosisSafePath),
    ).to.equal(
      false,
      'Expected sdk gnosisSafe module to avoid default exports',
    );
    expect(
      hasDefaultReExportFromModule(
        indexText,
        indexPath,
        './utils/gnosisSafe.js',
      ),
    ).to.equal(
      false,
      'Expected sdk index to avoid default re-exports from gnosisSafe module',
    );

    const moduleExports = extractTopLevelDeclarationExports(
      gnosisSafeText,
      gnosisSafePath,
    );
    const gnosisSafeExportReferences = extractNamedExportSymbolReferences(
      indexText,
      './utils/gnosisSafe.js',
      indexPath,
      moduleExports,
    );
    const gnosisSafeExports = extractNamedExportSymbols(
      indexText,
      './utils/gnosisSafe.js',
      indexPath,
      moduleExports,
    );
    expect(gnosisSafeExports.length).to.be.greaterThan(
      0,
      'Expected to find named exports for ./utils/gnosisSafe.js in sdk index',
    );

    const requiredExports = [
      'asHex',
      'canProposeSafeTransactions',
      'getSafeAndService',
      'getPendingTxsForChains',
      'createSafeDeploymentTransaction',
      'createSafeTransaction',
      'createSafeTransactionData',
      'DEFAULT_SAFE_DEPLOYMENT_VERSIONS',
      'decodeMultiSendData',
      'deleteAllPendingSafeTxs',
      'deleteSafeTx',
      'executeTx',
      'getKnownMultiSendAddresses',
      'getOwnerChanges',
      'getSafe',
      'getSafeDelegates',
      'getSafeService',
      'getSafeTx',
      'hasSafeServiceTransactionPayload',
      'isLegacySafeApi',
      'normalizeSafeServiceUrl',
      'ParseableSafeTx',
      'parseSafeTx',
      'proposeSafeTransaction',
      'resolveSafeSigner',
      'retrySafeApi',
      'safeApiKeyRequired',
      'updateSafeOwner',
      'SafeAndService',
      'SafeCallData',
      'SafeDeploymentConfig',
      'SafeDeploymentTransaction',
      'SafeOwnerUpdateCall',
      'SafeServiceTransaction',
      'SafeServiceTransactionWithPayload',
      'SafeStatus',
      'SafeTxStatus',
    ];

    const requiredRuntimeExports = requiredExports.filter(
      (symbol) =>
        ![
          'ParseableSafeTx',
          'SafeAndService',
          'SafeCallData',
          'SafeDeploymentConfig',
          'SafeDeploymentTransaction',
          'SafeOwnerUpdateCall',
          'SafeServiceTransaction',
          'SafeServiceTransactionWithPayload',
          'SafeStatus',
        ].includes(symbol),
    );

    for (const exportedSymbol of requiredExports) {
      expect(
        gnosisSafeExports.includes(exportedSymbol),
        `Expected sdk index gnosisSafe export list to include ${exportedSymbol}`,
      ).to.equal(true);
    }

    for (const runtimeExportedSymbol of requiredRuntimeExports) {
      expect(
        hasValueExport(gnosisSafeExportReferences, runtimeExportedSymbol),
        `Expected sdk index gnosisSafe export ${runtimeExportedSymbol} to be value-exported`,
      ).to.equal(true);
    }

    const missingExports = moduleExports.filter(
      (symbol) => !gnosisSafeExports.includes(symbol),
    );
    expect(
      missingExports,
      'Expected sdk index to re-export all top-level gnosisSafe module exports',
    ).to.deep.equal([]);
  });

  it('keeps sdk package free of infra dependency edges', () => {
    const packageJsonPath = path.resolve(process.cwd(), 'package.json');
    const packageJson: SdkPackageJson = JSON.parse(
      fs.readFileSync(packageJsonPath, 'utf8'),
    );

    const allDependencyNames = [
      ...Object.keys(packageJson.dependencies ?? {}),
      ...Object.keys(packageJson.devDependencies ?? {}),
      ...Object.keys(packageJson.optionalDependencies ?? {}),
      ...Object.keys(packageJson.peerDependencies ?? {}),
    ];

    expect(
      allDependencyNames.includes('@hyperlane-xyz/infra'),
      'SDK package.json should not depend on @hyperlane-xyz/infra',
    ).to.equal(false);
  });
});
